{
  "source": "doc/api/all.md",
  "desc": [
    {
      "type": "html",
      "pre": false,
      "text": "<!-- [start-include:documentation.md] -->\n"
    }
  ],
  "miscs": [
    {
      "textRaw": "About this Documentation",
      "name": "About this Documentation",
      "type": "misc",
      "desc": "<p>The goal of this documentation is to comprehensively explain the Node.js\nAPI, both from a reference as well as a conceptual point of view.  Each\nsection describes a built-in module or high-level concept.</p>\n<p>Where appropriate, property types, method arguments, and the arguments\nprovided to event handlers are detailed in a list underneath the topic\nheading.</p>\n<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting\nthe same information in a structured manner.  This feature is\nexperimental, and added for the benefit of IDEs and other utilities that\nwish to do programmatic things with the documentation.</p>\n<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding\n<code>.md</code> file in the <code>doc/api/</code> folder in Node.js&#39;s source tree.  The\ndocumentation is generated using the <code>tools/doc/generate.js</code> program.\nThe HTML template is located at <code>doc/template.html</code>.</p>\n<p>If you find an error in this documentation, please [submit an issue][]\nor see [the contributing guide][] for directions on how to submit a patch.</p>\n",
      "miscs": [
        {
          "textRaw": "Stability Index",
          "name": "Stability Index",
          "type": "misc",
          "desc": "<p>Throughout the documentation, you will see indications of a section&#39;s\nstability.  The Node.js API is still somewhat changing, and as it\nmatures, certain parts are more reliable than others.  Some are so\nproven, and so relied upon, that they are unlikely to ever change at\nall.  Others are brand new and experimental, or known to be hazardous\nand in the process of being redesigned.</p>\n<p>The stability indices are as follows:</p>\n<pre><code>Stability: 0 - Deprecated\nThis feature is known to be problematic, and changes are\nplanned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards\ncompatibility should not be expected.\n</code></pre><pre><code>Stability: 1 - Experimental\nThis feature is subject to change, and is gated by a command line flag.\nIt may change or be removed in future versions.\n</code></pre><pre><code>Stability: 2 - Stable\nThe API has proven satisfactory. Compatibility with the npm ecosystem\nis a high priority, and will not be broken unless absolutely necessary.\n</code></pre><pre><code>Stability: 3 - Locked\nOnly fixes related to security, performance, or bug fixes will be accepted.\nPlease do not suggest API changes in this area; they will be refused.\n</code></pre>"
        },
        {
          "textRaw": "JSON Output",
          "name": "json_output",
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<p>Every HTML file in the markdown has a corresponding JSON file with the\nsame data.</p>\n<p>This feature was added in Node.js v0.6.12.  It is experimental.</p>\n",
          "type": "misc",
          "displayName": "JSON Output"
        },
        {
          "textRaw": "Syscalls and man pages",
          "name": "syscalls_and_man_pages",
          "desc": "<p>System calls like open(2) and read(2) define the interface between user programs\nand the underlying operating system. Node functions which simply wrap a syscall,\nlike <code>fs.open()</code>, will document that. The docs link to the corresponding man\npages (short for manual pages) which describe how the syscalls work.</p>\n<p><strong>Caveat:</strong> some syscalls, like lchown(2), are BSD-specific. That means, for\nexample, that <code>fs.lchown()</code> only works on Mac OS X and other BSD-derived systems,\nand is not available on Linux.</p>\n<p>Most Unix syscalls have Windows equivalents, but behavior may differ on Windows\nrelative to Linux and OS X. For an example of the subtle ways in which it&#39;s\nsometimes impossible to replace Unix syscall semantics on Windows, see <a href=\"https://github.com/nodejs/node/issues/4760\">Node\nissue 4760</a>.</p>\n<!-- [end-include:documentation.md] -->\n<!-- [start-include:synopsis.md] -->\n",
          "type": "misc",
          "displayName": "Syscalls and man pages"
        }
      ]
    },
    {
      "textRaw": "Usage",
      "name": "Usage",
      "type": "misc",
      "desc": "<p><code>node [options] [v8 options] [script.js | -e &quot;script&quot;] [arguments]</code></p>\n<p>Please see the [Command Line Options][] document for information about\ndifferent options and ways to run scripts with Node.</p>\n<h2>Example</h2>\n<p>An example of a [web server][] written with Node.js which responds with\n<code>&#39;Hello World&#39;</code>:</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\n\nconst hostname = &#39;127.0.0.1&#39;;\nconst port = 3000;\n\nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200;\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\n  res.end(&#39;Hello World\\n&#39;);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n</code></pre>\n<p>To run the server, put the code into a file called <code>example.js</code> and execute\nit with Node.js:</p>\n<pre><code>$ node example.js\nServer running at http://127.0.0.1:3000/\n</code></pre><p>All of the examples in the documentation can be run similarly.</p>\n<!-- [end-include:synopsis.md] -->\n<!-- [start-include:addons.md] -->\n"
    },
    {
      "textRaw": "Command Line Options",
      "name": "Command Line Options",
      "type": "misc",
      "desc": "<p>Node.js comes with a variety of CLI options. These options expose built-in\ndebugging, multiple ways to execute scripts, and other helpful runtime options.</p>\n<p>To view this documentation as a manual page in your terminal, run <code>man node</code>.</p>\n",
      "miscs": [
        {
          "textRaw": "Synopsis",
          "name": "synopsis",
          "desc": "<p><code>node [options] [v8 options] [script.js | -e &quot;script&quot;] [arguments]</code></p>\n<p><code>node debug [script.js | -e &quot;script&quot; | &lt;host&gt;:&lt;port&gt;] â€¦</code></p>\n<p><code>node --v8-options</code></p>\n<p>Execute without arguments to start the [REPL][].</p>\n<p><em>For more info about <code>node debug</code>, please see the [debugger][] documentation.</em></p>\n",
          "type": "misc",
          "displayName": "Synopsis"
        },
        {
          "textRaw": "Options",
          "name": "options",
          "modules": [
            {
              "textRaw": "`-v`, `--version`",
              "name": "`-v`,_`--version`",
              "meta": {
                "added": [
                  "v0.1.3"
                ]
              },
              "desc": "<p>Print node&#39;s version.</p>\n",
              "type": "module",
              "displayName": "`-v`, `--version`"
            },
            {
              "textRaw": "`-h`, `--help`",
              "name": "`-h`,_`--help`",
              "meta": {
                "added": [
                  "v0.1.3"
                ]
              },
              "desc": "<p>Print node command line options.\nThe output of this option is less detailed than this document.</p>\n",
              "type": "module",
              "displayName": "`-h`, `--help`"
            },
            {
              "textRaw": "`-e`, `--eval \"script\"`",
              "name": "`-e`,_`--eval_\"script\"`",
              "meta": {
                "added": [
                  "v0.5.2"
                ]
              },
              "desc": "<p>Evaluate the following argument as JavaScript.</p>\n",
              "type": "module",
              "displayName": "`-e`, `--eval \"script\"`"
            },
            {
              "textRaw": "`-p`, `--print \"script\"`",
              "name": "`-p`,_`--print_\"script\"`",
              "meta": {
                "added": [
                  "v0.6.4"
                ]
              },
              "desc": "<p>Identical to <code>-e</code> but prints the result.</p>\n",
              "type": "module",
              "displayName": "`-p`, `--print \"script\"`"
            },
            {
              "textRaw": "`-c`, `--check`",
              "name": "`-c`,_`--check`",
              "meta": {
                "added": [
                  "v4.2.0"
                ]
              },
              "desc": "<p>Syntax check the script without executing.</p>\n",
              "type": "module",
              "displayName": "`-c`, `--check`"
            },
            {
              "textRaw": "`-i`, `--interactive`",
              "name": "`-i`,_`--interactive`",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p>Opens the REPL even if stdin does not appear to be a terminal.</p>\n",
              "type": "module",
              "displayName": "`-i`, `--interactive`"
            },
            {
              "textRaw": "`-r`, `--require module`",
              "name": "`-r`,_`--require_module`",
              "meta": {
                "added": [
                  "v1.6.0"
                ]
              },
              "desc": "<p>Preload the specified module at startup.</p>\n<p>Follows <code>require()</code>&#39;s module resolution\nrules. <code>module</code> may be either a path to a file, or a node module name.</p>\n",
              "type": "module",
              "displayName": "`-r`, `--require module`"
            },
            {
              "textRaw": "`--no-deprecation`",
              "name": "`--no-deprecation`",
              "meta": {
                "added": [
                  "v0.8.0"
                ]
              },
              "desc": "<p>Silence deprecation warnings.</p>\n",
              "type": "module",
              "displayName": "`--no-deprecation`"
            },
            {
              "textRaw": "`--trace-deprecation`",
              "name": "`--trace-deprecation`",
              "meta": {
                "added": [
                  "v0.8.0"
                ]
              },
              "desc": "<p>Print stack traces for deprecations.</p>\n",
              "type": "module",
              "displayName": "`--trace-deprecation`"
            },
            {
              "textRaw": "`--throw-deprecation`",
              "name": "`--throw-deprecation`",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Throw errors for deprecations.</p>\n",
              "type": "module",
              "displayName": "`--throw-deprecation`"
            },
            {
              "textRaw": "`--trace-sync-io`",
              "name": "`--trace-sync-io`",
              "meta": {
                "added": [
                  "v2.1.0"
                ]
              },
              "desc": "<p>Prints a stack trace whenever synchronous I/O is detected after the first turn\nof the event loop.</p>\n",
              "type": "module",
              "displayName": "`--trace-sync-io`"
            },
            {
              "textRaw": "`--zero-fill-buffers`",
              "name": "`--zero-fill-buffers`",
              "meta": {
                "added": [
                  "v4.5.0"
                ]
              },
              "desc": "<p>Automatically zero-fills all newly allocated [Buffer][] and [SlowBuffer][]\ninstances.</p>\n",
              "type": "module",
              "displayName": "`--zero-fill-buffers`"
            },
            {
              "textRaw": "`--track-heap-objects`",
              "name": "`--track-heap-objects`",
              "meta": {
                "added": [
                  "v2.4.0"
                ]
              },
              "desc": "<p>Track heap object allocations for heap snapshots.</p>\n",
              "type": "module",
              "displayName": "`--track-heap-objects`"
            },
            {
              "textRaw": "`--prof-process`",
              "name": "`--prof-process`",
              "meta": {
                "added": [
                  "v4.4.0"
                ]
              },
              "desc": "<p>Process v8 profiler output generated using the v8 option <code>--prof</code>.</p>\n",
              "type": "module",
              "displayName": "`--prof-process`"
            },
            {
              "textRaw": "`--v8-options`",
              "name": "`--v8-options`",
              "meta": {
                "added": [
                  "v0.1.3"
                ]
              },
              "desc": "<p>Print v8 command line options.</p>\n",
              "type": "module",
              "displayName": "`--v8-options`"
            },
            {
              "textRaw": "`--tls-cipher-list=list`",
              "name": "`--tls-cipher-list=list`",
              "meta": {
                "added": [
                  "v4.0.0"
                ]
              },
              "desc": "<p>Specify an alternative default TLS cipher list. (Requires Node.js to be built\nwith crypto support. (Default))</p>\n",
              "type": "module",
              "displayName": "`--tls-cipher-list=list`"
            },
            {
              "textRaw": "`--enable-fips`",
              "name": "`--enable-fips`",
              "desc": "<p>Enable FIPS-compliant crypto at startup. (Requires Node.js to be built with\n<code>./configure --openssl-fips</code>)</p>\n",
              "type": "module",
              "displayName": "`--enable-fips`"
            },
            {
              "textRaw": "`--force-fips`",
              "name": "`--force-fips`",
              "desc": "<p>Force FIPS-compliant crypto on startup. (Cannot be disabled from script code.)\n(Same requirements as <code>--enable-fips</code>)</p>\n",
              "type": "module",
              "displayName": "`--force-fips`"
            },
            {
              "textRaw": "`--icu-data-dir=file`",
              "name": "`--icu-data-dir=file`",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "desc": "<p>Specify ICU data load path. (overrides <code>NODE_ICU_DATA</code>)</p>\n",
              "type": "module",
              "displayName": "`--icu-data-dir=file`"
            }
          ],
          "type": "misc",
          "displayName": "Options"
        },
        {
          "textRaw": "Environment Variables",
          "name": "environment_variables",
          "modules": [
            {
              "textRaw": "`NODE_DEBUG=module[,â€¦]`",
              "name": "`node_debug=module[,â€¦]`",
              "meta": {
                "added": [
                  "v0.1.32"
                ]
              },
              "desc": "<p><code>&#39;,&#39;</code>-separated list of core modules that should print debug information.</p>\n",
              "type": "module",
              "displayName": "`NODE_DEBUG=module[,â€¦]`"
            },
            {
              "textRaw": "`NODE_PATH=path[:â€¦]`",
              "name": "`node_path=path[:â€¦]`",
              "meta": {
                "added": [
                  "v0.1.32"
                ]
              },
              "desc": "<p><code>&#39;:&#39;</code>-separated list of directories prefixed to the module search path.</p>\n<p><em>Note: on Windows, this is a <code>&#39;;&#39;</code>-separated list instead.</em></p>\n",
              "type": "module",
              "displayName": "`NODE_PATH=path[:â€¦]`"
            },
            {
              "textRaw": "`NODE_DISABLE_COLORS=1`",
              "name": "`node_disable_colors=1`",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>When set to <code>1</code> colors will not be used in the REPL.</p>\n",
              "type": "module",
              "displayName": "`NODE_DISABLE_COLORS=1`"
            },
            {
              "textRaw": "`NODE_ICU_DATA=file`",
              "name": "`node_icu_data=file`",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "desc": "<p>Data path for ICU (Intl object) data. Will extend linked-in data when compiled\nwith small-icu support.</p>\n",
              "type": "module",
              "displayName": "`NODE_ICU_DATA=file`"
            },
            {
              "textRaw": "`NODE_REPL_HISTORY=file`",
              "name": "`node_repl_history=file`",
              "meta": {
                "added": [
                  "v3.0.0"
                ]
              },
              "desc": "<p>Path to the file used to store the persistent REPL history. The default path is\n<code>~/.node_repl_history</code>, which is overridden by this variable. Setting the value\nto an empty string (<code>&quot;&quot;</code> or <code>&quot; &quot;</code>) disables persistent REPL history.</p>\n<!-- [end-include:cli.md] -->\n<!-- [start-include:console.md] -->\n",
              "type": "module",
              "displayName": "`NODE_REPL_HISTORY=file`"
            }
          ],
          "type": "misc",
          "displayName": "Environment Variables"
        }
      ]
    },
    {
      "textRaw": "Debugger",
      "name": "Debugger",
      "stability": 2,
      "stabilityText": "Stable",
      "type": "misc",
      "desc": "<p>Node.js includes a full-featured out-of-process debugging utility accessible\nvia a simple [TCP-based protocol][] and built-in debugging client. To use it,\nstart Node.js with the <code>debug</code> argument followed by the path to the script to\ndebug; a prompt will be displayed indicating successful launch of the debugger:</p>\n<pre><code>$ node debug myscript.js\n&lt; debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(() =&gt; {\n  3   debugger;\ndebug&gt;\n</code></pre><p>Node.js&#39;s debugger client is not a full-featured debugger, but simple step and\ninspection are possible.</p>\n<p>Inserting the statement <code>debugger;</code> into the source code of a script will\nenable a breakpoint at that position in the code:</p>\n<pre><code class=\"lang-js\">// myscript.js\nx = 5;\nsetTimeout(() =&gt; {\n  debugger;\n  console.log(&#39;world&#39;);\n}, 1000);\nconsole.log(&#39;hello&#39;);\n</code></pre>\n<p>Once the debugger is run, a breakpoint will occur at line 4:</p>\n<pre><code>$ node debug myscript.js\n&lt; debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(() =&gt; {\n  3   debugger;\ndebug&gt; cont\n&lt; hello\nbreak in /home/indutny/Code/git/indutny/myscript.js:3\n  1 x = 5;\n  2 setTimeout(() =&gt; {\n  3   debugger;\n  4   console.log(&#39;world&#39;);\n  5 }, 1000);\ndebug&gt; next\nbreak in /home/indutny/Code/git/indutny/myscript.js:4\n  2 setTimeout(() =&gt; {\n  3   debugger;\n  4   console.log(&#39;world&#39;);\n  5 }, 1000);\n  6 console.log(&#39;hello&#39;);\ndebug&gt; repl\nPress Ctrl + C to leave debug repl\n&gt; x\n5\n&gt; 2+2\n4\ndebug&gt; next\n&lt; world\nbreak in /home/indutny/Code/git/indutny/myscript.js:5\n  3   debugger;\n  4   console.log(&#39;world&#39;);\n  5 }, 1000);\n  6 console.log(&#39;hello&#39;);\n  7\ndebug&gt; quit\n</code></pre><p>The <code>repl</code> command allows code to be evaluated remotely. The <code>next</code> command\nsteps to the next line. Type <code>help</code> to see what other commands are available.</p>\n",
      "miscs": [
        {
          "textRaw": "Watchers",
          "name": "watchers",
          "desc": "<p>It is possible to watch expression and variable values while debugging. On\nevery breakpoint, each expression from the watchers list will be evaluated\nin the current context and displayed immediately before the breakpoint&#39;s\nsource code listing.</p>\n<p>To begin watching an expression, type <code>watch(&#39;my_expression&#39;)</code>. The command\n<code>watchers</code> will print the active watchers. To remove a watcher, type\n<code>unwatch(&#39;my_expression&#39;)</code>.</p>\n",
          "type": "misc",
          "displayName": "Watchers"
        },
        {
          "textRaw": "Command reference",
          "name": "command_reference",
          "modules": [
            {
              "textRaw": "Stepping",
              "name": "Stepping",
              "desc": "<ul>\n<li><code>cont</code>, <code>c</code> - Continue execution</li>\n<li><code>next</code>, <code>n</code> - Step next</li>\n<li><code>step</code>, <code>s</code> - Step in</li>\n<li><code>out</code>, <code>o</code> - Step out</li>\n<li><code>pause</code> - Pause running code (like pause button in Developer Tools)</li>\n</ul>\n",
              "type": "module",
              "displayName": "Breakpoints"
            },
            {
              "textRaw": "Breakpoints",
              "name": "breakpoints",
              "desc": "<ul>\n<li><code>setBreakpoint()</code>, <code>sb()</code> - Set breakpoint on current line</li>\n<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - Set breakpoint on specific line</li>\n<li><code>setBreakpoint(&#39;fn()&#39;)</code>, <code>sb(...)</code> - Set breakpoint on a first statement in\nfunctions body</li>\n<li><code>setBreakpoint(&#39;script.js&#39;, 1)</code>, <code>sb(...)</code> - Set breakpoint on first line of\nscript.js</li>\n<li><code>clearBreakpoint(&#39;script.js&#39;, 1)</code>, <code>cb(...)</code> - Clear breakpoint in script.js\non line 1</li>\n</ul>\n<p>It is also possible to set a breakpoint in a file (module) that\nisn&#39;t loaded yet:</p>\n<pre><code>$ ./node debug test/fixtures/break-in-module/main.js\n&lt; debugger listening on port 5858\nconnecting to port 5858... ok\nbreak in test/fixtures/break-in-module/main.js:1\n  1 var mod = require(&#39;./mod.js&#39;);\n  2 mod.hello();\n  3 mod.hello();\ndebug&gt; setBreakpoint(&#39;mod.js&#39;, 23)\nWarning: script &#39;mod.js&#39; was not loaded yet.\n  1 var mod = require(&#39;./mod.js&#39;);\n  2 mod.hello();\n  3 mod.hello();\ndebug&gt; c\nbreak in test/fixtures/break-in-module/mod.js:23\n 21\n 22 exports.hello = () =&gt; {\n 23   return &#39;hello from module&#39;;\n 24 };\n 25\ndebug&gt;\n</code></pre>",
              "type": "module",
              "displayName": "Breakpoints"
            },
            {
              "textRaw": "Execution control",
              "name": "Execution control",
              "desc": "<ul>\n<li><code>run</code> - Run script (automatically runs on debugger&#39;s start)</li>\n<li><code>restart</code> - Restart script</li>\n<li><code>kill</code> - Kill script</li>\n</ul>\n",
              "type": "module",
              "displayName": "Various"
            },
            {
              "textRaw": "Various",
              "name": "various",
              "desc": "<ul>\n<li><code>scripts</code> - List all loaded scripts</li>\n<li><code>version</code> - Display V8&#39;s version</li>\n</ul>\n",
              "type": "module",
              "displayName": "Various"
            }
          ],
          "type": "misc",
          "displayName": "Command reference"
        },
        {
          "textRaw": "Advanced Usage",
          "name": "advanced_usage",
          "desc": "<p>An alternative way of enabling and accessing the debugger is to start\nNode.js with the <code>--debug</code> command-line flag or by signaling an existing\nNode.js process with <code>SIGUSR1</code>.</p>\n<p>Once a process has been set in debug mode this way, it can be inspected\nusing the Node.js debugger by either connecting to the <code>pid</code> of the running\nprocess or via URI reference to the listening debugger:</p>\n<ul>\n<li><code>node debug -p &lt;pid&gt;</code> - Connects to the process via the <code>pid</code></li>\n<li><code>node debug &lt;URI&gt;</code> - Connects to the process via the URI such as\nlocalhost:5858</li>\n</ul>\n<!-- [end-include:debugger.md] -->\n<!-- [start-include:dgram.md] -->\n",
          "type": "misc",
          "displayName": "Advanced Usage"
        }
      ]
    },
    {
      "textRaw": "Errors",
      "name": "Errors",
      "type": "misc",
      "desc": "<p>Applications running in Node.js will generally experience four categories of\nerrors:</p>\n<ul>\n<li>Standard JavaScript errors such as:<ul>\n<li>{EvalError} : thrown when a call to <code>eval()</code> fails.</li>\n<li>{SyntaxError} : thrown in response to improper JavaScript language\nsyntax.</li>\n<li>{RangeError} : thrown when a value is not within an expected range</li>\n<li>{ReferenceError} : thrown when using undefined variables</li>\n<li>{TypeError} : thrown when passing arguments of the wrong type</li>\n<li>{URIError} : thrown when a global URI handling function is misused.</li>\n</ul>\n</li>\n<li>System errors triggered by underlying operating system constraints such\nas attempting to open a file that does not exist, attempting to send data\nover a closed socket, etc;</li>\n<li>And User-specified errors triggered by application code.</li>\n<li>Assertion Errors are a special class of error that can be triggered whenever\nNode.js detects an exceptional logic violation that should never occur. These\nare raised typically by the <code>assert</code> module.</li>\n</ul>\n<p>All JavaScript and System errors raised by Node.js inherit from, or are\ninstances of, the standard JavaScript {Error} class and are guaranteed\nto provide <em>at least</em> the properties available on that class.</p>\n",
      "miscs": [
        {
          "textRaw": "Error Propagation and Interception",
          "name": "Error Propagation and Interception",
          "type": "misc",
          "desc": "<p>Node.js supports several mechanisms for propagating and handling errors that\noccur while an application is running. How these errors are reported and\nhandled depends entirely on the type of Error and the style of the API that is\ncalled.</p>\n<p>All JavaScript errors are handled as exceptions that <em>immediately</em> generate\nand throw an error using the standard JavaScript <code>throw</code> mechanism. These\nare handled using the [<code>try / catch</code> construct][try-catch] provided by the JavaScript\nlanguage.</p>\n<pre><code class=\"lang-js\">// Throws with a ReferenceError because z is undefined\ntry {\n  const m = 1;\n  const n = m + z;\n} catch (err) {\n  // Handle the error here.\n}\n</code></pre>\n<p>Any use of the JavaScript <code>throw</code> mechanism will raise an exception that\n<em>must</em> be handled using <code>try / catch</code> or the Node.js process will exit\nimmediately.</p>\n<p>With few exceptions, <em>Synchronous</em> APIs (any blocking method that does not\naccept a <code>callback</code> function, such as [<code>fs.readFileSync</code>][]), will use <code>throw</code>\nto report errors.</p>\n<p>Errors that occur within <em>Asynchronous APIs</em> may be reported in multiple ways:</p>\n<ul>\n<li><p>Most asynchronous methods that accept a <code>callback</code> function will accept an\n<code>Error</code> object passed as the first argument to that function. If that first\nargument is not <code>null</code> and is an instance of <code>Error</code>, then an error occurred\nthat should be handled.</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\nfs.readFile(&#39;a file that does not exist&#39;, (err, data) =&gt; {\n  if (err) {\n    console.error(&#39;There was an error reading the file!&#39;, err);\n    return;\n  }\n  // Otherwise handle the data\n});\n</code></pre>\n</li>\n<li><p>When an asynchronous method is called on an object that is an <code>EventEmitter</code>,\nerrors can be routed to that object&#39;s <code>&#39;error&#39;</code> event.</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst connection = net.connect(&#39;localhost&#39;);\n\n// Adding an &#39;error&#39; event handler to a stream:\nconnection.on(&#39;error&#39;, (err) =&gt; {\n  // If the connection is reset by the server, or if it can&#39;t\n  // connect at all, or on any sort of error encountered by\n  // the connection, the error will be sent here.\n  console.error(err);\n});\n\nconnection.pipe(process.stdout);\n</code></pre>\n</li>\n<li><p>A handful of typically asynchronous methods in the Node.js API may still\nuse the <code>throw</code> mechanism to raise exceptions that must be handled using\n<code>try / catch</code>. There is no comprehensive list of such methods; please\nrefer to the documentation of each method to determine the appropriate\nerror handling mechanism required.</p>\n</li>\n</ul>\n<p>The use of the <code>&#39;error&#39;</code> event mechanism is most common for [stream-based][]\nand [event emitter-based][] APIs, which themselves represent a series of\nasynchronous operations over time (as opposed to a single operation that may\npass or fail).</p>\n<p>For <em>all</em> <code>EventEmitter</code> objects, if an <code>&#39;error&#39;</code> event handler is not\nprovided, the error will be thrown, causing the Node.js process to report an\nunhandled exception and  crash unless either: The [<code>domain</code>][domains] module is used\nappropriately or a handler has been registered for the\n[<code>process.on(&#39;uncaughtException&#39;)</code>][] event.</p>\n<pre><code class=\"lang-js\">const EventEmitter = require(&#39;events&#39;);\nconst ee = new EventEmitter();\n\nsetImmediate(() =&gt; {\n  // This will crash the process because no &#39;error&#39; event\n  // handler has been added.\n  ee.emit(&#39;error&#39;, new Error(&#39;This will crash&#39;));\n});\n</code></pre>\n<p>Errors generated in this way <em>cannot</em> be intercepted using <code>try / catch</code> as\nthey are thrown <em>after</em> the calling code has already exited.</p>\n<p>Developers must refer to the documentation for each method to determine\nexactly how errors raised by those methods are propagated.</p>\n",
          "miscs": [
            {
              "textRaw": "Node.js style callbacks",
              "name": "Node.js style callbacks",
              "type": "misc",
              "desc": "<p>Most asynchronous methods exposed by the Node.js core API follow an idiomatic\npattern  referred to as a &quot;Node.js style callback&quot;. With this pattern, a\ncallback function is passed to the method as an argument. When the operation\neither completes or an error is raised, the callback function is called with\nthe Error object (if any) passed as the first argument. If no error was raised,\nthe first argument will be passed as <code>null</code>.</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\n\nfunction nodeStyleCallback(err, data) {\n if (err) {\n   console.error(&#39;There was an error&#39;, err);\n   return;\n }\n console.log(data);\n}\n\nfs.readFile(&#39;/some/file/that/does-not-exist&#39;, nodeStyleCallback);\nfs.readFile(&#39;/some/file/that/does-exist&#39;, nodeStyleCallback)\n</code></pre>\n<p>The JavaScript <code>try / catch</code> mechanism <strong>cannot</strong> be used to intercept errors\ngenerated by asynchronous APIs.  A common mistake for beginners is to try to\nuse <code>throw</code> inside a Node.js style callback:</p>\n<pre><code class=\"lang-js\">// THIS WILL NOT WORK:\nconst fs = require(&#39;fs&#39;);\n\ntry {\n  fs.readFile(&#39;/some/file/that/does-not-exist&#39;, (err, data) =&gt; {\n    // mistaken assumption: throwing here...\n    if (err) {\n      throw err;\n    }\n  });\n} catch(err) {\n  // This will not catch the throw!\n  console.log(err);\n}\n</code></pre>\n<p>This will not work because the callback function passed to <code>fs.readFile()</code> is\ncalled asynchronously. By the time the callback has been called, the\nsurrounding code (including the <code>try { } catch(err) { }</code> block will have\nalready exited. Throwing an error inside the callback <strong>can crash the Node.js\nprocess</strong> in most cases. If [domains][] are enabled, or a handler has been\nregistered with <code>process.on(&#39;uncaughtException&#39;)</code>, such errors can be\nintercepted.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Exceptions vs. Errors",
          "name": "Exceptions vs. Errors",
          "type": "misc",
          "desc": "<p>A JavaScript exception is a value that is thrown as a result of an invalid\noperation or as the target of a <code>throw</code> statement. While it is not required\nthat these values are instances of <code>Error</code> or classes which inherit from\n<code>Error</code>, all exceptions thrown by Node.js or the JavaScript runtime <em>will</em> be\ninstances of Error.</p>\n<p>Some exceptions are <em>unrecoverable</em> at the JavaScript layer. Such exceptions\nwill <em>always</em> cause the Node.js process to crash. Examples include <code>assert()</code>\nchecks or <code>abort()</code> calls in the C++ layer.</p>\n"
        },
        {
          "textRaw": "System Errors",
          "name": "system_errors",
          "desc": "<p>System errors are generated when exceptions occur within the program&#39;s\nruntime environment. Typically, these are operational errors that occur\nwhen an application violates an operating system constraint such as attempting\nto read a file that does not exist or when the user does not have sufficient\npermissions.</p>\n<p>System errors are typically generated at the syscall level: an exhaustive list\nof error codes and their meanings is available by running <code>man 2 intro</code> or\n<code>man 3 errno</code> on most Unices; or [online][].</p>\n<p>In Node.js, system errors are represented as augmented <code>Error</code> objects with\nadded properties.</p>\n",
          "classes": [
            {
              "textRaw": "Class: System Error",
              "type": "class",
              "name": "System",
              "properties": [
                {
                  "textRaw": "error.code",
                  "name": "code",
                  "desc": "<p>Returns a string representing the error code, which is always <code>E</code> followed by\na sequence of capital letters, and may be referenced in <code>man 2 intro</code>.</p>\n<p>The properties <code>error.code</code> and <code>error.errno</code> are aliases of one another and\nreturn the same value.</p>\n"
                },
                {
                  "textRaw": "error.errno",
                  "name": "errno",
                  "desc": "<p>Returns a string representing the error code, which is always <code>E</code> followed by\na sequence of capital letters, and may be referenced in <code>man 2 intro</code>.</p>\n<p>The properties <code>error.code</code> and <code>error.errno</code> are aliases of one another and\nreturn the same value.</p>\n"
                },
                {
                  "textRaw": "error.syscall",
                  "name": "syscall",
                  "desc": "<p>Returns a string describing the [syscall][] that failed.</p>\n"
                }
              ]
            }
          ],
          "modules": [
            {
              "textRaw": "Common System Errors",
              "name": "common_system_errors",
              "desc": "<p>This list is <strong>not exhaustive</strong>, but enumerates many of the common system\nerrors encountered when writing a Node.js program. An exhaustive list may be\nfound [here][online].</p>\n<ul>\n<li><p><code>EACCES</code> (Permission denied): An attempt was made to access a file in a way\nforbidden by its file access permissions.</p>\n</li>\n<li><p><code>EADDRINUSE</code> (Address already in use):  An attempt to bind a server\n([<code>net</code>][], [<code>http</code>][], or [<code>https</code>][]) to a local address failed due to\nanother server on the local system already occupying that address.</p>\n</li>\n<li><p><code>ECONNREFUSED</code> (Connection refused): No connection could be made because the\ntarget machine actively refused it. This usually results from trying to\nconnect to a service that is inactive on the foreign host.</p>\n</li>\n<li><p><code>ECONNRESET</code> (Connection reset by peer): A connection was forcibly closed by\na peer. This normally results from a loss of the connection on the remote\nsocket due to a timeout or reboot. Commonly encountered via the [<code>http</code>][]\nand [<code>net</code>][] modules.</p>\n</li>\n<li><p><code>EEXIST</code> (File exists): An existing file was the target of an operation that\nrequired that the target not exist.</p>\n</li>\n<li><p><code>EISDIR</code> (Is a directory): An operation expected a file, but the given\npathname was a directory.</p>\n</li>\n<li><p><code>EMFILE</code> (Too many open files in system): Maximum number of\n[file descriptors][] allowable on the system has been reached, and\nrequests for another descriptor cannot be fulfilled until at least one\nhas been closed. This is encountered when opening many files at once in\nparallel, especially on systems (in particular, OS X) where there is a low\nfile descriptor limit for processes. To remedy a low limit, run\n<code>ulimit -n 2048</code> in the same shell that will run the Node.js process.</p>\n</li>\n<li><p><code>ENOENT</code> (No such file or directory): Commonly raised by [<code>fs</code>][] operations\nto indicate that a component of the specified pathname does not exist -- no\nentity (file or directory) could be found by the given path.</p>\n</li>\n<li><p><code>ENOTDIR</code> (Not a directory): A component of the given pathname existed, but\nwas not a directory as expected. Commonly raised by [<code>fs.readdir</code>][].</p>\n</li>\n<li><p><code>ENOTEMPTY</code> (Directory not empty): A directory with entries was the target\nof an operation that requires an empty directory -- usually [<code>fs.unlink</code>][].</p>\n</li>\n<li><p><code>EPERM</code> (Operation not permitted): An attempt was made to perform an\noperation that requires elevated privileges.</p>\n</li>\n<li><p><code>EPIPE</code> (Broken pipe): A write on a pipe, socket, or FIFO for which there is\nno process to read the data. Commonly encountered at the [<code>net</code>][] and\n[<code>http</code>][] layers, indicative that the remote side of the stream being\nwritten to has been closed.</p>\n</li>\n<li><p><code>ETIMEDOUT</code> (Operation timed out): A connect or send request failed because\nthe connected party did not properly respond after a period of time. Usually\nencountered by [<code>http</code>][] or [<code>net</code>][] -- often a sign that a <code>socket.end()</code>\nwas not properly called.</p>\n</li>\n</ul>\n<!-- [end-include:errors.md] -->\n<!-- [start-include:events.md] -->\n",
              "type": "module",
              "displayName": "Common System Errors"
            }
          ],
          "type": "misc",
          "displayName": "System Errors"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Error",
          "type": "class",
          "name": "Error",
          "desc": "<p>A generic JavaScript <code>Error</code> object that does not denote any specific\ncircumstance of why the error occurred. <code>Error</code> objects capture a &quot;stack trace&quot;\ndetailing the point in the code at which the <code>Error</code> was instantiated, and may\nprovide a text description of the error.</p>\n<p>All errors generated by Node.js, including all System and JavaScript errors,\nwill either be instances of, or inherit from, the <code>Error</code> class.</p>\n",
          "methods": [
            {
              "textRaw": "Error.captureStackTrace(targetObject[, constructorOpt])",
              "type": "method",
              "name": "captureStackTrace",
              "desc": "<p>Creates a <code>.stack</code> property on <code>targetObject</code>, which when accessed returns\na string representing the location in the code at which\n<code>Error.captureStackTrace()</code> was called.</p>\n<pre><code class=\"lang-js\">const myObject = {};\nError.captureStackTrace(myObject);\nmyObject.stack  // similar to `new Error().stack`\n</code></pre>\n<p>The first line of the trace, instead of being prefixed with <code>ErrorType:\nmessage</code>, will be the result of calling <code>targetObject.toString()</code>.</p>\n<p>The optional <code>constructorOpt</code> argument accepts a function. If given, all frames\nabove <code>constructorOpt</code>, including <code>constructorOpt</code>, will be omitted from the\ngenerated stack trace.</p>\n<p>The <code>constructorOpt</code> argument is useful for hiding implementation\ndetails of error generation from an end user. For instance:</p>\n<pre><code class=\"lang-js\">function MyError() {\n  Error.captureStackTrace(this, MyError);\n}\n\n// Without passing MyError to captureStackTrace, the MyError\n// frame would show up in the .stack property. By passing\n// the constructor, we omit that frame and all frames above it.\nnew MyError().stack\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "targetObject"
                    },
                    {
                      "name": "constructorOpt",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "Error.stackTraceLimit",
              "name": "stackTraceLimit",
              "desc": "<p>The <code>Error.stackTraceLimit</code> property specifies the number of stack frames\ncollected by a stack trace (whether generated by <code>new Error().stack</code> or\n<code>Error.captureStackTrace(obj)</code>).</p>\n<p>The default value is <code>10</code> but may be set to any valid JavaScript number. Changes\nwill affect any stack trace captured <em>after</em> the value has been changed.</p>\n<p>If set to a non-number value, or set to a negative number, stack traces will\nnot capture any frames.</p>\n",
              "properties": [
                {
                  "textRaw": "error.message",
                  "name": "message",
                  "desc": "<p>Returns the string description of error as set by calling <code>new Error(message)</code>.\nThe <code>message</code> passed to the constructor will also appear in the first line of\nthe stack trace of the <code>Error</code>, however changing this property after the\n<code>Error</code> object is created <em>may not</em> change the first line of the stack trace.</p>\n<pre><code class=\"lang-js\">const err = new Error(&#39;The message&#39;);\nconsole.log(err.message);\n  // Prints: The message\n</code></pre>\n"
                },
                {
                  "textRaw": "error.stack",
                  "name": "stack",
                  "desc": "<p>Returns a string describing the point in the code at which the <code>Error</code> was\ninstantiated.</p>\n<p>For example:</p>\n<pre><code>Error: Things keep happening!\n   at /home/gbusey/file.js:525:2\n   at Frobnicator.refrobulate (/home/gbusey/business-logic.js:424:21)\n   at Actor.&lt;anonymous&gt; (/home/gbusey/actors.js:400:8)\n   at increaseSynergy (/home/gbusey/actors.js:701:6)\n</code></pre><p>The first line is formatted as <code>&lt;error class name&gt;: &lt;error message&gt;</code>, and\nis followed by a series of stack frames (each line beginning with &quot;at &quot;).\nEach frame describes a call site within the code that lead to the error being\ngenerated. V8 attempts to display a name for each function (by variable name,\nfunction name, or object method name), but occasionally it will not be able to\nfind a suitable name. If V8 cannot determine a name for the function, only\nlocation information will be displayed for that frame. Otherwise, the\ndetermined function name will be displayed with location information appended\nin parentheses.</p>\n<p>It is important to note that frames are <strong>only</strong> generated for JavaScript\nfunctions. If, for example, execution synchronously passes through a C++ addon\nfunction called <code>cheetahify</code>, which itself calls a JavaScript function, the\nframe representing the <code>cheetahify</code> call will <strong>not</strong> be present in the stack\ntraces:</p>\n<pre><code class=\"lang-js\">const cheetahify = require(&#39;./native-binding.node&#39;);\n\nfunction makeFaster() {\n  // cheetahify *synchronously* calls speedy.\n  cheetahify(function speedy() {\n    throw new Error(&#39;oh no!&#39;);\n  });\n}\n\nmakeFaster(); // will throw:\n  // /home/gbusey/file.js:6\n  //     throw new Error(&#39;oh no!&#39;);\n  //           ^\n  // Error: oh no!\n  //     at speedy (/home/gbusey/file.js:6:11)\n  //     at makeFaster (/home/gbusey/file.js:5:3)\n  //     at Object.&lt;anonymous&gt; (/home/gbusey/file.js:10:1)\n  //     at Module._compile (module.js:456:26)\n  //     at Object.Module._extensions..js (module.js:474:10)\n  //     at Module.load (module.js:356:32)\n  //     at Function.Module._load (module.js:312:12)\n  //     at Function.Module.runMain (module.js:497:10)\n  //     at startup (node.js:119:16)\n  //     at node.js:906:3\n</code></pre>\n<p>The location information will be one of:</p>\n<ul>\n<li><code>native</code>, if the frame represents a call internal to V8 (as in <code>[].forEach</code>).</li>\n<li><code>plain-filename.js:line:column</code>, if the frame represents a call internal\n to Node.js.</li>\n<li><code>/absolute/path/to/file.js:line:column</code>, if the frame represents a call in\na user program, or its dependencies.</li>\n</ul>\n<p>The string representing the stack trace is lazily generated when the\n<code>error.stack</code> property is <strong>accessed</strong>.</p>\n<p>The number of frames captured by the stack trace is bounded by the smaller of\n<code>Error.stackTraceLimit</code> or the number of available frames on the current event\nloop tick.</p>\n<p>System-level errors are generated as augmented <code>Error</code> instances, which are\ndetailed <a href=\"#errors_system_errors\">here</a>.</p>\n"
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "message"
                }
              ],
              "desc": "<p>Creates a new <code>Error</code> object and sets the <code>error.message</code> property to the\nprovided text message. If an object is passed as <code>message</code>, the text message\nis generated by calling <code>message.toString()</code>. The <code>error.stack</code> property will\nrepresent the point in the code at which <code>new Error()</code> was called. Stack traces\nare dependent on [V8&#39;s stack trace API][]. Stack traces extend only to either\n(a) the beginning of  <em>synchronous code execution</em>, or (b) the number of frames\ngiven by the property <code>Error.stackTraceLimit</code>, whichever is smaller.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: RangeError",
          "type": "class",
          "name": "RangeError",
          "desc": "<p>A subclass of <code>Error</code> that indicates that a provided argument was not within the\nset or range of acceptable values for a function; whether that is a numeric\nrange, or outside the set of options for a given function parameter.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">require(&#39;net&#39;).connect(-1);\n  // throws RangeError, port should be &gt; 0 &amp;&amp; &lt; 65536\n</code></pre>\n<p>Node.js will generate and throw <code>RangeError</code> instances <em>immediately</em> as a form\nof argument validation.</p>\n"
        },
        {
          "textRaw": "Class: ReferenceError",
          "type": "class",
          "name": "ReferenceError",
          "desc": "<p>A subclass of <code>Error</code> that indicates that an attempt is being made to access a\nvariable that is not defined. Such errors commonly indicate typos in code, or\nan otherwise broken program.</p>\n<p>While client code may generate and propagate these errors, in practice, only V8\nwill do so.</p>\n<pre><code class=\"lang-js\">doesNotExist;\n  // throws ReferenceError, doesNotExist is not a variable in this program.\n</code></pre>\n<p><code>ReferenceError</code> instances will have an <code>error.arguments</code> property whose value\nis an array containing a single element: a string representing the variable\nthat was not defined.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\ntry {\n  doesNotExist;\n} catch(err) {\n  assert(err.arguments[0], &#39;doesNotExist&#39;);\n}\n</code></pre>\n<p>Unless an application is dynamically generating and running code,\n<code>ReferenceError</code> instances should always be considered a bug in the code\nor its dependencies.</p>\n"
        },
        {
          "textRaw": "Class: SyntaxError",
          "type": "class",
          "name": "SyntaxError",
          "desc": "<p>A subclass of <code>Error</code> that indicates that a program is not valid JavaScript.\nThese errors may only be generated and propagated as a result of code\nevaluation. Code evaluation may happen as a result of <code>eval</code>, <code>Function</code>,\n<code>require</code>, or [vm][]. These errors are almost always indicative of a broken\nprogram.</p>\n<pre><code class=\"lang-js\">try {\n  require(&#39;vm&#39;).runInThisContext(&#39;binary ! isNotOk&#39;);\n} catch(err) {\n  // err will be a SyntaxError\n}\n</code></pre>\n<p><code>SyntaxError</code> instances are unrecoverable in the context that created them â€“\nthey may only be caught by other contexts.</p>\n"
        },
        {
          "textRaw": "Class: TypeError",
          "type": "class",
          "name": "TypeError",
          "desc": "<p>A subclass of <code>Error</code> that indicates that a provided argument is not an\nallowable type. For example, passing a function to a parameter which expects a\nstring would be considered a TypeError.</p>\n<pre><code class=\"lang-js\">require(&#39;url&#39;).parse(() =&gt; { });\n  // throws TypeError, since it expected a string\n</code></pre>\n<p>Node.js will generate and throw <code>TypeError</code> instances <em>immediately</em> as a form\nof argument validation.</p>\n"
        }
      ]
    },
    {
      "textRaw": "Global Objects",
      "name": "Global Objects",
      "type": "misc",
      "desc": "<p>These objects are available in all modules. Some of these objects aren&#39;t\nactually in the global scope but in the module scope - this will be noted.</p>\n<p>The objects listed here are specific to Node.js. There are a number of\n[built-in objects][] that are part of the JavaScript language itself, which are\nalso globally accessible.</p>\n",
      "globals": [
        {
          "textRaw": "Class: Buffer",
          "type": "global",
          "name": "Buffer",
          "desc": "<ul>\n<li>{Function}</li>\n</ul>\n<p>Used to handle binary data. See the [buffer section][].</p>\n"
        },
        {
          "textRaw": "clearImmediate(immediateObject)",
          "type": "global",
          "name": "clearImmediate",
          "desc": "<p>[<code>clearImmediate</code>] is described in the [timers][] section.</p>\n"
        },
        {
          "textRaw": "clearInterval(intervalObject)",
          "type": "global",
          "name": "clearInterval",
          "desc": "<p>[<code>clearInterval</code>] is described in the [timers][] section.</p>\n"
        },
        {
          "textRaw": "clearTimeout(timeoutObject)",
          "type": "global",
          "name": "clearTimeout",
          "desc": "<p>[<code>clearTimeout</code>] is described in the [timers][] section.</p>\n"
        },
        {
          "textRaw": "console",
          "name": "console",
          "type": "global",
          "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>Used to print to stdout and stderr. See the [<code>console</code>][] section.</p>\n"
        },
        {
          "textRaw": "global",
          "name": "global",
          "type": "global",
          "desc": "<ul>\n<li>{Object} The global namespace object.</li>\n</ul>\n<p>In browsers, the top-level scope is the global scope. That means that in\nbrowsers if you&#39;re in the global scope <code>var something</code> will define a global\nvariable. In Node.js this is different. The top-level scope is not the global\nscope; <code>var something</code> inside an Node.js module will be local to that module.</p>\n"
        },
        {
          "textRaw": "process",
          "name": "process",
          "type": "global",
          "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>The process object. See the [<code>process</code> object][] section.</p>\n"
        },
        {
          "textRaw": "setImmediate(callback[, arg][, ...])",
          "type": "global",
          "name": "setImmediate",
          "desc": "<p>[<code>setImmediate</code>] is described in the [timers][] section.</p>\n"
        },
        {
          "textRaw": "setInterval(callback, delay[, arg][, ...])",
          "type": "global",
          "name": "setInterval",
          "desc": "<p>[<code>setInterval</code>] is described in the [timers][] section.</p>\n"
        },
        {
          "textRaw": "setTimeout(callback, delay[, arg][, ...])",
          "type": "global",
          "name": "setTimeout",
          "desc": "<p>[<code>setTimeout</code>] is described in the [timers][] section.</p>\n<!-- [end-include:globals.md] -->\n<!-- [start-include:http.md] -->\n"
        },
        {
          "textRaw": "process",
          "name": "process",
          "type": "global",
          "desc": "<p>The <code>process</code> object is a global object and can be accessed from anywhere.\nIt is an instance of [<code>EventEmitter</code>][].</p>\n",
          "events": [
            {
              "textRaw": "Event: 'beforeExit'",
              "type": "event",
              "name": "beforeExit",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>This event is emitted when Node.js empties its event loop and has nothing else\nto schedule. Normally, Node.js exits when there is no work scheduled, but a\nlistener for <code>&#39;beforeExit&#39;</code> can make asynchronous calls, and cause Node.js to\ncontinue.</p>\n<p><code>&#39;beforeExit&#39;</code> is not emitted for conditions causing explicit termination, such\nas [<code>process.exit()</code>][] or uncaught exceptions, and should not be used as an\nalternative to the <code>&#39;exit&#39;</code> event unless the intention is to schedule more work.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "meta": {
                "added": [
                  "v0.1.7"
                ]
              },
              "desc": "<p>Emitted when the process is about to exit. There is no way to prevent the\nexiting of the event loop at this point, and once all <code>&#39;exit&#39;</code> listeners have\nfinished running the process will exit. Therefore you <strong>must</strong> only perform\n<strong>synchronous</strong> operations in this handler. This is a good hook to perform\nchecks on the module&#39;s state (like for unit tests). The callback takes one\nargument, the code the process is exiting with.</p>\n<p>This event is only emitted when Node.js exits explicitly by process.exit() or\nimplicitly by the event loop draining.</p>\n<p>Example of listening for <code>&#39;exit&#39;</code>:</p>\n<pre><code class=\"lang-js\">process.on(&#39;exit&#39;, (code) =&gt; {\n  // do *NOT* do this\n  setTimeout(() =&gt; {\n    console.log(&#39;This will not run&#39;);\n  }, 0);\n  console.log(&#39;About to exit with code:&#39;, code);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "meta": {
                "added": [
                  "v0.5.10"
                ]
              },
              "params": [],
              "desc": "<p>Messages sent by [<code>ChildProcess.send()</code>][] are obtained using the <code>&#39;message&#39;</code>\nevent on the child&#39;s process object.</p>\n"
            },
            {
              "textRaw": "Event: 'rejectionHandled'",
              "type": "event",
              "name": "rejectionHandled",
              "meta": {
                "added": [
                  "v1.4.1"
                ]
              },
              "desc": "<p>Emitted whenever a Promise was rejected and an error handler was attached to it\n(for example with <code>.catch()</code>) later than after an event loop turn. This event\nis emitted with the following arguments:</p>\n<ul>\n<li><code>p</code> the promise that was previously emitted in an <code>&#39;unhandledRejection&#39;</code>\nevent, but which has now gained a rejection handler.</li>\n</ul>\n<p>There is no notion of a top level for a promise chain at which rejections can\nalways be handled. Being inherently asynchronous in nature, a promise rejection\ncan be handled at a future point in time â€” possibly much later than the\nevent loop turn it takes for the <code>&#39;unhandledRejection&#39;</code> event to be emitted.</p>\n<p>Another way of stating this is that, unlike in synchronous code where there is\nan ever-growing list of unhandled exceptions, with promises there is a\ngrowing-and-shrinking list of unhandled rejections. In synchronous code, the\n<code>&#39;uncaughtException&#39;</code> event tells you when the list of unhandled exceptions\ngrows. And in asynchronous code, the <code>&#39;unhandledRejection&#39;</code> event tells you\nwhen the list of unhandled rejections grows, while the <code>&#39;rejectionHandled&#39;</code>\nevent tells you when the list of unhandled rejections shrinks.</p>\n<p>For example using the rejection detection hooks in order to keep a map of all\nthe rejected promise reasons at a given time:</p>\n<pre><code class=\"lang-js\">const unhandledRejections = new Map();\nprocess.on(&#39;unhandledRejection&#39;, (reason, p) =&gt; {\n  unhandledRejections.set(p, reason);\n});\nprocess.on(&#39;rejectionHandled&#39;, (p) =&gt; {\n  unhandledRejections.delete(p);\n});\n</code></pre>\n<p>This map will grow and shrink over time, reflecting rejections that start\nunhandled and then become handled. You could record the errors in some error\nlog, either periodically (probably best for long-running programs, allowing\nyou to clear the map, which in the case of a very buggy program could grow\nindefinitely) or upon process exit (more convenient for scripts).</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'uncaughtException'",
              "type": "event",
              "name": "uncaughtException",
              "meta": {
                "added": [
                  "v0.1.18"
                ]
              },
              "desc": "<p>The <code>&#39;uncaughtException&#39;</code> event is emitted when an exception bubbles all the\nway back to the event loop. By default, Node.js handles such exceptions by\nprinting the stack trace to stderr and exiting. Adding a handler for the\n<code>&#39;uncaughtException&#39;</code> event overrides this default behavior.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">process.on(&#39;uncaughtException&#39;, (err) =&gt; {\n  console.log(`Caught exception: ${err}`);\n});\n\nsetTimeout(() =&gt; {\n  console.log(&#39;This will still run.&#39;);\n}, 500);\n\n// Intentionally cause an exception, but don&#39;t catch it.\nnonexistentFunc();\nconsole.log(&#39;This will not run.&#39;);\n</code></pre>\n",
              "modules": [
                {
                  "textRaw": "Warning: Using `'uncaughtException'` correctly",
                  "name": "warning:_using_`'uncaughtexception'`_correctly",
                  "desc": "<p>Note that <code>&#39;uncaughtException&#39;</code> is a crude mechanism for exception handling\nintended to be used only as a last resort. The event <em>should not</em> be used as\nan equivalent to <code>On Error Resume Next</code>. Unhandled exceptions inherently mean\nthat an application is in an undefined state. Attempting to resume application\ncode without properly recovering from the exception can cause additional\nunforeseen and unpredictable issues.</p>\n<p>Exceptions thrown from within the event handler will not be caught. Instead the\nprocess will exit with a non-zero exit code and the stack trace will be printed.\nThis is to avoid infinite recursion.</p>\n<p>Attempting to resume normally after an uncaught exception can be similar to\npulling out of the power cord when upgrading a computer -- nine out of ten\ntimes nothing happens - but the 10th time, the system becomes corrupted.</p>\n<p>The correct use of <code>&#39;uncaughtException&#39;</code> is to perform synchronous cleanup\nof allocated resources (e.g. file descriptors, handles, etc) before shutting\ndown the process. It is not safe to resume normal operation after\n<code>&#39;uncaughtException&#39;</code>.</p>\n",
                  "type": "module",
                  "displayName": "Warning: Using `'uncaughtException'` correctly"
                }
              ],
              "params": []
            },
            {
              "textRaw": "Event: 'unhandledRejection'",
              "type": "event",
              "name": "unhandledRejection",
              "meta": {
                "added": [
                  "v1.4.1"
                ]
              },
              "desc": "<p>Emitted whenever a <code>Promise</code> is rejected and no error handler is attached to\nthe promise within a turn of the event loop. When programming with promises\nexceptions are encapsulated as rejected promises. Such promises can be caught\nand handled using [<code>promise.catch(...)</code>][] and rejections are propagated through\na promise chain. This event is useful for detecting and keeping track of\npromises that were rejected whose rejections were not handled yet. This event\nis emitted with the following arguments:</p>\n<ul>\n<li><code>reason</code> the object with which the promise was rejected (usually an\n[<code>Error</code>][] instance).</li>\n<li><code>p</code> the promise that was rejected.</li>\n</ul>\n<p>Here is an example that logs every unhandled rejection to the console</p>\n<pre><code class=\"lang-js\">process.on(&#39;unhandledRejection&#39;, (reason, p) =&gt; {\n    console.log(&quot;Unhandled Rejection at: Promise &quot;, p, &quot; reason: &quot;, reason);\n    // application specific logging, throwing an error, or other logic here\n});\n</code></pre>\n<p>For example, here is a rejection that will trigger the <code>&#39;unhandledRejection&#39;</code>\nevent:</p>\n<pre><code class=\"lang-js\">somePromise.then((res) =&gt; {\n  return reportToUser(JSON.pasre(res)); // note the typo (`pasre`)\n}); // no `.catch` or `.then`\n</code></pre>\n<p>Here is an example of a coding pattern that will also trigger\n<code>&#39;unhandledRejection&#39;</code>:</p>\n<pre><code class=\"lang-js\">function SomeResource() {\n  // Initially set the loaded status to a rejected promise\n  this.loaded = Promise.reject(new Error(&#39;Resource not yet loaded!&#39;));\n}\n\nvar resource = new SomeResource();\n// no .catch or .then on resource.loaded for at least a turn\n</code></pre>\n<p>In cases like this, you may not want to track the rejection as a developer\nerror like you would for other <code>&#39;unhandledRejection&#39;</code> events. To address\nthis, you can either attach a dummy <code>.catch(() =&gt; { })</code> handler to\n<code>resource.loaded</code>, preventing the <code>&#39;unhandledRejection&#39;</code> event from being\nemitted, or you can use the [<code>&#39;rejectionHandled&#39;</code>][] event.</p>\n",
              "params": []
            },
            {
              "textRaw": "Signal Events",
              "name": "SIGINT, SIGHUP, etc.",
              "type": "event",
              "desc": "<p>Emitted when the processes receives a signal. See sigaction(2) for a list of\nstandard POSIX signal names such as <code>SIGINT</code>, <code>SIGHUP</code>, etc.</p>\n<p>Example of listening for <code>SIGINT</code>:</p>\n<pre><code class=\"lang-js\">// Start reading from stdin so we don&#39;t exit.\nprocess.stdin.resume();\n\nprocess.on(&#39;SIGINT&#39;, () =&gt; {\n  console.log(&#39;Got SIGINT.  Press Control-D to exit.&#39;);\n});\n</code></pre>\n<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal\nprograms.</p>\n<p>Note:</p>\n<ul>\n<li><code>SIGUSR1</code> is reserved by Node.js to start the debugger.  It&#39;s possible to\ninstall a listener but that won&#39;t stop the debugger from starting.</li>\n<li><code>SIGTERM</code> and <code>SIGINT</code> have default handlers on non-Windows platforms that\nresets the terminal mode before exiting with code <code>128 + signal number</code>. If\none of these signals has a listener installed, its default behavior will be\nremoved (Node.js will no longer exit).</li>\n<li><code>SIGPIPE</code> is ignored by default. It can have a listener installed.</li>\n<li><code>SIGHUP</code> is generated on Windows when the console window is closed, and on other\nplatforms under various similar conditions, see signal(7). It can have a\nlistener installed, however Node.js will be unconditionally terminated by\nWindows about 10 seconds later. On non-Windows platforms, the default\nbehavior of <code>SIGHUP</code> is to terminate Node.js, but once a listener has been\ninstalled its default behavior will be removed.</li>\n<li><code>SIGTERM</code> is not supported on Windows, it can be listened on.</li>\n<li><code>SIGINT</code> from the terminal is supported on all platforms, and can usually be\ngenerated with <code>CTRL+C</code> (though this may be configurable). It is not generated\nwhen terminal raw mode is enabled.</li>\n<li><code>SIGBREAK</code> is delivered on Windows when <code>CTRL+BREAK</code> is pressed, on\nnon-Windows\nplatforms it can be listened on, but there is no way to send or generate it.</li>\n<li><code>SIGWINCH</code> is delivered when the console has been resized. On Windows, this\nwill only happen on write to the console when the cursor is being moved, or\nwhen a readable tty is used in raw mode.</li>\n<li><code>SIGKILL</code> cannot have a listener installed, it will unconditionally terminate\nNode.js on all platforms.</li>\n<li><code>SIGSTOP</code> cannot have a listener installed.</li>\n</ul>\n<p>Note that Windows does not support sending Signals, but Node.js offers some\nemulation with <code>process.kill()</code>, and <code>child_process.kill()</code>. Sending signal <code>0</code>\ncan be used to test for the existence of a process. Sending <code>SIGINT</code>,\n<code>SIGTERM</code>, and <code>SIGKILL</code> cause the unconditional termination of the target\nprocess.</p>\n",
              "params": []
            }
          ],
          "modules": [
            {
              "textRaw": "Exit Codes",
              "name": "exit_codes",
              "desc": "<p>Node.js will normally exit with a <code>0</code> status code when no more async\noperations are pending.  The following status codes are used in other\ncases:</p>\n<ul>\n<li><code>1</code> <strong>Uncaught Fatal Exception</strong> - There was an uncaught exception,\nand it was not handled by a domain or an <code>&#39;uncaughtException&#39;</code> event\nhandler.</li>\n<li><code>2</code> - Unused (reserved by Bash for builtin misuse)</li>\n<li><code>3</code> <strong>Internal JavaScript Parse Error</strong> - The JavaScript source code\ninternal in Node.js&#39;s bootstrapping process caused a parse error.  This\nis extremely rare, and generally can only happen during development\nof Node.js itself.</li>\n<li><code>4</code> <strong>Internal JavaScript Evaluation Failure</strong> - The JavaScript\nsource code internal in Node.js&#39;s bootstrapping process failed to\nreturn a function value when evaluated.  This is extremely rare, and\ngenerally can only happen during development of Node.js itself.</li>\n<li><code>5</code> <strong>Fatal Error</strong> - There was a fatal unrecoverable error in V8.\nTypically a message will be printed to stderr with the prefix <code>FATAL\nERROR</code>.</li>\n<li><code>6</code> <strong>Non-function Internal Exception Handler</strong> - There was an\nuncaught exception, but the internal fatal exception handler\nfunction was somehow set to a non-function, and could not be called.</li>\n<li><code>7</code> <strong>Internal Exception Handler Run-Time Failure</strong> - There was an\nuncaught exception, and the internal fatal exception handler\nfunction itself threw an error while attempting to handle it.  This\ncan happen, for example, if a <code>process.on(&#39;uncaughtException&#39;)</code> or\n<code>domain.on(&#39;error&#39;)</code> handler throws an error.</li>\n<li><code>8</code> - Unused.  In previous versions of Node.js, exit code 8 sometimes\nindicated an uncaught exception.</li>\n<li><code>9</code> - <strong>Invalid Argument</strong> - Either an unknown option was specified,\nor an option requiring a value was provided without a value.</li>\n<li><code>10</code> <strong>Internal JavaScript Run-Time Failure</strong> - The JavaScript\nsource code internal in Node.js&#39;s bootstrapping process threw an error\nwhen the bootstrapping function was called.  This is extremely rare,\nand generally can only happen during development of Node.js itself.</li>\n<li><code>12</code> <strong>Invalid Debug Argument</strong> - The <code>--debug</code> and/or <code>--debug-brk</code>\noptions were set, but an invalid port number was chosen.</li>\n<li><code>&gt;128</code> <strong>Signal Exits</strong> - If Node.js receives a fatal signal such as\n<code>SIGKILL</code> or <code>SIGHUP</code>, then its exit code will be <code>128</code> plus the\nvalue of the signal code.  This is a standard Unix practice, since\nexit codes are defined to be 7-bit integers, and signal exits set\nthe high-order bit, and then contain the value of the signal code.</li>\n</ul>\n",
              "type": "module",
              "displayName": "Exit Codes"
            }
          ],
          "methods": [
            {
              "textRaw": "process.abort()",
              "type": "method",
              "name": "abort",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p>This causes Node.js to emit an abort. This will cause Node.js to exit and\ngenerate a core file.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.chdir(directory)",
              "type": "method",
              "name": "chdir",
              "meta": {
                "added": [
                  "v0.1.17"
                ]
              },
              "desc": "<p>Changes the current working directory of the process or throws an exception if that fails.</p>\n<pre><code class=\"lang-js\">console.log(`Starting directory: ${process.cwd()}`);\ntry {\n  process.chdir(&#39;/tmp&#39;);\n  console.log(`New directory: ${process.cwd()}`);\n}\ncatch (err) {\n  console.log(`chdir: ${err}`);\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "directory"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.cwd()",
              "type": "method",
              "name": "cwd",
              "meta": {
                "added": [
                  "v0.1.8"
                ]
              },
              "desc": "<p>Returns the current working directory of the process.</p>\n<pre><code class=\"lang-js\">console.log(`Current directory: ${process.cwd()}`);\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.disconnect()",
              "type": "method",
              "name": "disconnect",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>Close the IPC channel to the parent process, allowing this child to exit\ngracefully once there are no other connections keeping it alive.</p>\n<p>Identical to the parent process&#39;s [<code>ChildProcess.disconnect()</code>][].</p>\n<p>If Node.js was not spawned with an IPC channel, <code>process.disconnect()</code> will be\nundefined.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.exit([code])",
              "type": "method",
              "name": "exit",
              "meta": {
                "added": [
                  "v0.1.13"
                ]
              },
              "desc": "<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the\n&#39;success&#39; code <code>0</code>.</p>\n<p>To exit with a &#39;failure&#39; code:</p>\n<pre><code class=\"lang-js\">process.exit(1);\n</code></pre>\n<p>The shell that executed Node.js should see the exit code as 1.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "code",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.getegid()",
              "type": "method",
              "name": "getegid",
              "meta": {
                "added": [
                  "v2.0.0"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the effective group identity of the process. (See getegid(2).)\nThis is the numerical group id, not the group name.</p>\n<pre><code class=\"lang-js\">if (process.getegid) {\n  console.log(`Current gid: ${process.getegid()}`);\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.geteuid()",
              "type": "method",
              "name": "geteuid",
              "meta": {
                "added": [
                  "v2.0.0"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the effective user identity of the process. (See geteuid(2).)\nThis is the numerical userid, not the username.</p>\n<pre><code class=\"lang-js\">if (process.geteuid) {\n  console.log(`Current uid: ${process.geteuid()}`);\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.getgid()",
              "type": "method",
              "name": "getgid",
              "meta": {
                "added": [
                  "v0.1.31"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the group identity of the process. (See getgid(2).)\nThis is the numerical group id, not the group name.</p>\n<pre><code class=\"lang-js\">if (process.getgid) {\n  console.log(`Current gid: ${process.getgid()}`);\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.getgroups()",
              "type": "method",
              "name": "getgroups",
              "meta": {
                "added": [
                  "v0.9.4"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Returns an array with the supplementary group IDs. POSIX leaves it unspecified\nif the effective group ID is included but Node.js ensures it always is.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.getuid()",
              "type": "method",
              "name": "getuid",
              "meta": {
                "added": [
                  "v0.1.28"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the user identity of the process. (See getuid(2).)\nThis is the numerical userid, not the username.</p>\n<pre><code class=\"lang-js\">if (process.getuid) {\n  console.log(`Current uid: ${process.getuid()}`);\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.hrtime()",
              "type": "method",
              "name": "hrtime",
              "meta": {
                "added": [
                  "v0.7.6"
                ]
              },
              "desc": "<p>Returns the current high-resolution real time in a <code>[seconds, nanoseconds]</code>\ntuple Array. It is relative to an arbitrary time in the past. It is not\nrelated to the time of day and therefore not subject to clock drift. The\nprimary use is for measuring performance between intervals.</p>\n<p>You may pass in the result of a previous call to <code>process.hrtime()</code> to get\na diff reading, useful for benchmarks and measuring intervals:</p>\n<pre><code class=\"lang-js\">var time = process.hrtime();\n// [ 1800216, 25 ]\n\nsetTimeout(() =&gt; {\n  var diff = process.hrtime(time);\n  // [ 1, 552 ]\n\n  console.log(&#39;benchmark took %d nanoseconds&#39;, diff[0] * 1e9 + diff[1]);\n  // benchmark took 1000000527 nanoseconds\n}, 1000);\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.initgroups(user, extra_group)",
              "type": "method",
              "name": "initgroups",
              "meta": {
                "added": [
                  "v0.9.4"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Reads /etc/group and initializes the group access list, using all groups of\nwhich the user is a member. This is a privileged operation, meaning you need\nto be root or have the <code>CAP_SETGID</code> capability.</p>\n<p><code>user</code> is a user name or user ID. <code>extra_group</code> is a group name or group ID.</p>\n<p>Some care needs to be taken when dropping privileges. Example:</p>\n<pre><code class=\"lang-js\">console.log(process.getgroups());         // [ 0 ]\nprocess.initgroups(&#39;bnoordhuis&#39;, 1000);   // switch user\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]\nprocess.setgid(1000);                     // drop root gid\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000 ]\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "user"
                    },
                    {
                      "name": "extra_group"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.kill(pid[, signal])",
              "type": "method",
              "name": "kill",
              "meta": {
                "added": [
                  "v0.0.6"
                ]
              },
              "desc": "<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the\nstring describing the signal to send.  Signal names are strings like\n<code>SIGINT</code> or <code>SIGHUP</code>.  If omitted, the signal will be <code>SIGTERM</code>.\nSee [Signal Events][] and kill(2) for more information.</p>\n<p>Will throw an error if target does not exist, and as a special case, a signal\nof <code>0</code> can be used to test for the existence of a process. Windows platforms\nwill throw an error if the <code>pid</code> is used to kill a process group.</p>\n<p>Note that even though the name of this function is <code>process.kill</code>, it is really\njust a signal sender, like the <code>kill</code> system call.  The signal sent may do\nsomething other than kill the target process.</p>\n<p>Example of sending a signal to yourself:</p>\n<pre><code class=\"lang-js\">process.on(&#39;SIGHUP&#39;, () =&gt; {\n  console.log(&#39;Got SIGHUP signal.&#39;);\n});\n\nsetTimeout(() =&gt; {\n  console.log(&#39;Exiting.&#39;);\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, &#39;SIGHUP&#39;);\n</code></pre>\n<p>Note: When SIGUSR1 is received by Node.js it starts the debugger, see\n[Signal Events][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "pid"
                    },
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.memoryUsage()",
              "type": "method",
              "name": "memoryUsage",
              "meta": {
                "added": [
                  "v0.1.16"
                ]
              },
              "desc": "<p>Returns an object describing the memory usage of the Node.js process\nmeasured in bytes.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nconsole.log(util.inspect(process.memoryUsage()));\n</code></pre>\n<p>This will generate:</p>\n<pre><code class=\"lang-js\">{ rss: 4935680,\n  heapTotal: 1826816,\n  heapUsed: 650472 }\n</code></pre>\n<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8&#39;s memory usage.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.nextTick(callback[, arg][, ...])",
              "type": "method",
              "name": "nextTick",
              "meta": {
                "added": [
                  "v0.1.26"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    },
                    {
                      "name": "arg",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "callback"
                    },
                    {
                      "name": "arg",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Once the current event loop turn runs to completion, call the callback\nfunction.</p>\n<p>This is <em>not</em> a simple alias to [<code>setTimeout(fn, 0)</code>][], it&#39;s much more\nefficient.  It runs before any additional I/O events (including\ntimers) fire in subsequent ticks of the event loop.</p>\n<pre><code class=\"lang-js\">console.log(&#39;start&#39;);\nprocess.nextTick(() =&gt; {\n  console.log(&#39;nextTick callback&#39;);\n});\nconsole.log(&#39;scheduled&#39;);\n// Output:\n// start\n// scheduled\n// nextTick callback\n</code></pre>\n<p>This is important in developing APIs where you want to give the user the\nchance to assign event handlers after an object has been constructed,\nbut before any I/O has occurred.</p>\n<pre><code class=\"lang-js\">function MyThing(options) {\n  this.setupOptions(options);\n\n  process.nextTick(() =&gt; {\n    this.startDoingStuff();\n  });\n}\n\nvar thing = new MyThing();\nthing.getReadyForStuff();\n\n// thing.startDoingStuff() gets called now, not before.\n</code></pre>\n<p>It is very important for APIs to be either 100% synchronous or 100%\nasynchronous.  Consider this example:</p>\n<pre><code class=\"lang-js\">// WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat(&#39;file&#39;, cb);\n}\n</code></pre>\n<p>This API is hazardous.  If you do this:</p>\n<pre><code class=\"lang-js\">maybeSync(true, () =&gt; {\n  foo();\n});\nbar();\n</code></pre>\n<p>then it&#39;s not clear whether <code>foo()</code> or <code>bar()</code> will be called first.</p>\n<p>This approach is much better:</p>\n<pre><code class=\"lang-js\">function definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\n  fs.stat(&#39;file&#39;, cb);\n}\n</code></pre>\n<p>Note: the nextTick queue is completely drained on each pass of the\nevent loop <strong>before</strong> additional I/O is processed.  As a result,\nrecursively setting nextTick callbacks will block any I/O from\nhappening, just like a <code>while(true);</code> loop.</p>\n"
            },
            {
              "textRaw": "process.send(message[, sendHandle][, callback])",
              "type": "method",
              "name": "send",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle object} ",
                      "name": "sendHandle",
                      "type": "Handle object",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>When Node.js is spawned with an IPC channel attached, it can send messages to its\nparent process using <code>process.send()</code>. Each will be received as a\n[<code>&#39;message&#39;</code>][] event on the parent&#39;s <code>ChildProcess</code> object.</p>\n<p><em>Note: this function uses [<code>JSON.stringify()</code>][] internally to serialize the <code>message</code>.</em></p>\n<p>If Node.js was not spawned with an IPC channel, <code>process.send()</code> will be undefined.</p>\n"
            },
            {
              "textRaw": "process.setegid(id)",
              "type": "method",
              "name": "setegid",
              "meta": {
                "added": [
                  "v2.0.0"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the effective group identity of the process. (See setegid(2).)\nThis accepts either a numerical ID or a groupname string. If a groupname\nis specified, this method blocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.getegid &amp;&amp; process.setegid) {\n  console.log(`Current gid: ${process.getegid()}`);\n  try {\n    process.setegid(501);\n    console.log(`New gid: ${process.getegid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set gid: ${err}`);\n  }\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.seteuid(id)",
              "type": "method",
              "name": "seteuid",
              "meta": {
                "added": [
                  "v2.0.0"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the effective user identity of the process. (See seteuid(2).)\nThis accepts either a numerical ID or a username string.  If a username\nis specified, this method blocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.geteuid &amp;&amp; process.seteuid) {\n  console.log(`Current uid: ${process.geteuid()}`);\n  try {\n    process.seteuid(501);\n    console.log(`New uid: ${process.geteuid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set uid: ${err}`);\n  }\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.setgid(id)",
              "type": "method",
              "name": "setgid",
              "meta": {
                "added": [
                  "v0.1.31"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the group identity of the process. (See setgid(2).)  This accepts either\na numerical ID or a groupname string. If a groupname is specified, this method\nblocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.getgid &amp;&amp; process.setgid) {\n  console.log(`Current gid: ${process.getgid()}`);\n  try {\n    process.setgid(501);\n    console.log(`New gid: ${process.getgid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set gid: ${err}`);\n  }\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.setgroups(groups)",
              "type": "method",
              "name": "setgroups",
              "meta": {
                "added": [
                  "v0.9.4"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the supplementary group IDs. This is a privileged operation, meaning you\nneed to be root or have the <code>CAP_SETGID</code> capability.</p>\n<p>The list can contain group IDs, group names or both.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "groups"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.setuid(id)",
              "type": "method",
              "name": "setuid",
              "meta": {
                "added": [
                  "v0.1.28"
                ]
              },
              "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the user identity of the process. (See setuid(2).)  This accepts either\na numerical ID or a username string.  If a username is specified, this method\nblocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.getuid &amp;&amp; process.setuid) {\n  console.log(`Current uid: ${process.getuid()}`);\n  try {\n    process.setuid(501);\n    console.log(`New uid: ${process.getuid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set uid: ${err}`);\n  }\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.umask([mask])",
              "type": "method",
              "name": "umask",
              "meta": {
                "added": [
                  "v0.1.19"
                ]
              },
              "desc": "<p>Sets or reads the process&#39;s file mode creation mask. Child processes inherit\nthe mask from the parent process. Returns the old mask if <code>mask</code> argument is\ngiven, otherwise returns the current mask.</p>\n<pre><code class=\"lang-js\">const newmask = 0o022;\nconst oldmask = process.umask(newmask);\nconsole.log(\n  `Changed umask from ${oldmask.toString(8)} to ${newmask.toString(8)}`\n);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "mask",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.uptime()",
              "type": "method",
              "name": "uptime",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Number of seconds Node.js has been running.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "process.arch",
              "name": "arch",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>What processor architecture you&#39;re running on: <code>&#39;arm&#39;</code>, <code>&#39;ia32&#39;</code>, or <code>&#39;x64&#39;</code>.</p>\n<pre><code class=\"lang-js\">console.log(&#39;This processor architecture is &#39; + process.arch);\n</code></pre>\n"
            },
            {
              "textRaw": "process.argv",
              "name": "argv",
              "meta": {
                "added": [
                  "v0.1.27"
                ]
              },
              "desc": "<p>An array containing the command line arguments.  The first element will be\n&#39;node&#39;, the second element will be the name of the JavaScript file.  The\nnext elements will be any additional command line arguments.</p>\n<pre><code class=\"lang-js\">// print process.argv\nprocess.argv.forEach((val, index, array) =&gt; {\n  console.log(`${index}: ${val}`);\n});\n</code></pre>\n<p>This will generate:</p>\n<pre><code>$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four\n</code></pre>"
            },
            {
              "textRaw": "process.config",
              "name": "config",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p>An Object containing the JavaScript representation of the configure options\nthat were used to compile the current Node.js executable. This is the same as\nthe <code>config.gypi</code> file that was produced when running the <code>./configure</code> script.</p>\n<p>An example of the possible output looks like:</p>\n<pre><code>{\n  target_defaults:\n   { cflags: [],\n     default_configuration: &#39;Release&#39;,\n     defines: [],\n     include_dirs: [],\n     libraries: [] },\n  variables:\n   {\n     host_arch: &#39;x64&#39;,\n     node_install_npm: &#39;true&#39;,\n     node_prefix: &#39;&#39;,\n     node_shared_cares: &#39;false&#39;,\n     node_shared_http_parser: &#39;false&#39;,\n     node_shared_libuv: &#39;false&#39;,\n     node_shared_zlib: &#39;false&#39;,\n     node_use_dtrace: &#39;false&#39;,\n     node_use_openssl: &#39;true&#39;,\n     node_shared_openssl: &#39;false&#39;,\n     strict_aliasing: &#39;true&#39;,\n     target_arch: &#39;x64&#39;,\n     v8_use_snapshot: &#39;true&#39;\n   }\n}\n</code></pre><p><em>Note: the <code>process.config</code> property is <strong>not</strong> read-only and there are existing\nmodules in the ecosystem that are known to extend, modify, or entirely replace\nthe value of <code>process.config</code>.</em></p>\n"
            },
            {
              "textRaw": "`connected` {Boolean} Set to false after `process.disconnect()` is called ",
              "type": "Boolean",
              "name": "connected",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>If <code>process.connected</code> is false, it is no longer possible to send messages.</p>\n",
              "shortDesc": "Set to false after `process.disconnect()` is called"
            },
            {
              "textRaw": "process.env",
              "name": "env",
              "meta": {
                "added": [
                  "v0.1.27"
                ]
              },
              "desc": "<p>An object containing the user environment. See environ(7).</p>\n<p>An example of this object looks like:</p>\n<pre><code class=\"lang-js\">{ TERM: &#39;xterm-256color&#39;,\n  SHELL: &#39;/usr/local/bin/bash&#39;,\n  USER: &#39;maciej&#39;,\n  PATH: &#39;~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#39;,\n  PWD: &#39;/Users/maciej&#39;,\n  EDITOR: &#39;vim&#39;,\n  SHLVL: &#39;1&#39;,\n  HOME: &#39;/Users/maciej&#39;,\n  LOGNAME: &#39;maciej&#39;,\n  _: &#39;/usr/local/bin/node&#39; }\n</code></pre>\n<p>You can write to this object, but changes won&#39;t be reflected outside of your\nprocess. That means that the following won&#39;t work:</p>\n<pre><code>$ node -e &#39;process.env.foo = &quot;bar&quot;&#39; &amp;&amp; echo $foo\n</code></pre><p>But this will:</p>\n<pre><code class=\"lang-js\">process.env.foo = &#39;bar&#39;;\nconsole.log(process.env.foo);\n</code></pre>\n<p>Assigning a property on <code>process.env</code> will implicitly convert the value\nto a string.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">process.env.test = null;\nconsole.log(process.env.test);\n// =&gt; &#39;null&#39;\nprocess.env.test = undefined;\nconsole.log(process.env.test);\n// =&gt; &#39;undefined&#39;\n</code></pre>\n<p>Use <code>delete</code> to delete a property from <code>process.env</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">process.env.TEST = 1;\ndelete process.env.TEST;\nconsole.log(process.env.TEST);\n// =&gt; undefined\n</code></pre>\n"
            },
            {
              "textRaw": "process.execArgv",
              "name": "execArgv",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p>This is the set of Node.js-specific command line options from the\nexecutable that started the process.  These options do not show up in\n<code>process.argv</code>, and do not include the Node.js executable, the name of\nthe script, or any options following the script name. These options\nare useful in order to spawn child processes with the same execution\nenvironment as the parent.</p>\n<p>Example:</p>\n<pre><code>$ node --harmony script.js --version\n</code></pre><p>results in process.execArgv:</p>\n<pre><code class=\"lang-js\">[&#39;--harmony&#39;]\n</code></pre>\n<p>and process.argv:</p>\n<pre><code class=\"lang-js\">[&#39;/usr/local/bin/node&#39;, &#39;script.js&#39;, &#39;--version&#39;]\n</code></pre>\n"
            },
            {
              "textRaw": "process.execPath",
              "name": "execPath",
              "meta": {
                "added": [
                  "v0.1.100"
                ]
              },
              "desc": "<p>This is the absolute pathname of the executable that started the process.</p>\n<p>Example:</p>\n<pre><code>/usr/local/bin/node\n</code></pre>"
            },
            {
              "textRaw": "process.exitCode",
              "name": "exitCode",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>A number which will be the process exit code, when the process either\nexits gracefully, or is exited via [<code>process.exit()</code>][] without specifying\na code.</p>\n<p>Specifying a code to <code>process.exit(code)</code> will override any previous\nsetting of <code>process.exitCode</code>.</p>\n"
            },
            {
              "textRaw": "process.mainModule",
              "name": "mainModule",
              "meta": {
                "added": [
                  "v0.1.17"
                ]
              },
              "desc": "<p>Alternate way to retrieve [<code>require.main</code>][]. The difference is that if the main\nmodule changes at runtime, <code>require.main</code> might still refer to the original main\nmodule in modules that were required before the change occurred. Generally it&#39;s\nsafe to assume that the two refer to the same module.</p>\n<p>As with <code>require.main</code>, it will be <code>undefined</code> if there was no entry script.</p>\n"
            },
            {
              "textRaw": "process.pid",
              "name": "pid",
              "meta": {
                "added": [
                  "v0.1.15"
                ]
              },
              "desc": "<p>The PID of the process.</p>\n<pre><code class=\"lang-js\">console.log(`This process is pid ${process.pid}`);\n</code></pre>\n"
            },
            {
              "textRaw": "process.platform",
              "name": "platform",
              "meta": {
                "added": [
                  "v0.1.16"
                ]
              },
              "desc": "<p>What platform you&#39;re running on:\n<code>&#39;darwin&#39;</code>, <code>&#39;freebsd&#39;</code>, <code>&#39;linux&#39;</code>, <code>&#39;sunos&#39;</code> or <code>&#39;win32&#39;</code></p>\n<pre><code class=\"lang-js\">console.log(`This platform is ${process.platform}`);\n</code></pre>\n"
            },
            {
              "textRaw": "process.release",
              "name": "release",
              "meta": {
                "added": [
                  "v3.0.0"
                ]
              },
              "desc": "<p>An Object containing metadata related to the current release, including URLs\nfor the source tarball and headers-only tarball.</p>\n<p><code>process.release</code> contains the following properties:</p>\n<ul>\n<li><code>name</code>: a string with a value that will always be <code>&#39;node&#39;</code> for Node.js. For\nlegacy io.js releases, this will be <code>&#39;io.js&#39;</code>.</li>\n<li><code>sourceUrl</code>: a complete URL pointing to a <em>.tar.gz</em> file containing the\nsource of the current release.</li>\n<li><code>headersUrl</code>: a complete URL pointing to a <em>.tar.gz</em> file containing only\nthe header files for the current release. This file is significantly smaller\nthan the full source file and can be used for compiling add-ons against\nNode.js.</li>\n<li><code>libUrl</code>: a complete URL pointing to an <em>node.lib</em> file matching the\narchitecture and version of the current release. This file is used for\ncompiling add-ons against Node.js. <em>This property is only present on Windows\nbuilds of Node.js and will be missing on all other platforms.</em></li>\n</ul>\n<p>e.g.</p>\n<pre><code class=\"lang-js\">{ name: &#39;node&#39;,\n  sourceUrl: &#39;https://nodejs.org/download/release/v4.0.0/node-v4.0.0.tar.gz&#39;,\n  headersUrl: &#39;https://nodejs.org/download/release/v4.0.0/node-v4.0.0-headers.tar.gz&#39;,\n  libUrl: &#39;https://nodejs.org/download/release/v4.0.0/win-x64/node.lib&#39; }\n</code></pre>\n<p>In custom builds from non-release versions of the source tree, only the\n<code>name</code> property may be present. The additional properties should not be\nrelied upon to exist.</p>\n"
            },
            {
              "textRaw": "process.stderr",
              "name": "stderr",
              "desc": "<p>A writable stream to stderr (on fd <code>2</code>).</p>\n<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node.js in\nthat they cannot be closed (<code>end()</code> will throw), they never emit the <code>finish</code>\nevent and that writes can block when output is redirected to a file (although\ndisks are fast and operating systems normally employ write-back caching so it\nshould be a very rare occurrence indeed.)</p>\n<p>Additionally, <code>process.stderr</code> and <code>process.stdout</code> are blocking when outputting\nto TTYs (terminals) on OS X as a workaround for the OS&#39;s very small, 1kb\nbuffer size. This is to prevent interleaving between <code>stdout</code> and <code>stderr</code>.</p>\n"
            },
            {
              "textRaw": "process.stdin",
              "name": "stdin",
              "desc": "<p>A <code>Readable Stream</code> for stdin (on fd <code>0</code>).</p>\n<p>Example of opening standard input and listening for both events:</p>\n<pre><code class=\"lang-js\">process.stdin.setEncoding(&#39;utf8&#39;);\n\nprocess.stdin.on(&#39;readable&#39;, () =&gt; {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    process.stdout.write(`data: ${chunk}`);\n  }\n});\n\nprocess.stdin.on(&#39;end&#39;, () =&gt; {\n  process.stdout.write(&#39;end&#39;);\n});\n</code></pre>\n<p>As a Stream, <code>process.stdin</code> can also be used in &quot;old&quot; mode that is compatible\nwith scripts written for node.js prior to v0.10.\nFor more information see [Stream compatibility][].</p>\n<p>In &quot;old&quot; Streams mode the stdin stream is paused by default, so one\nmust call <code>process.stdin.resume()</code> to read from it. Note also that calling\n<code>process.stdin.resume()</code> itself would switch stream to &quot;old&quot; mode.</p>\n<p>If you are starting a new project you should prefer a more recent &quot;new&quot; Streams\nmode over &quot;old&quot; one.</p>\n"
            },
            {
              "textRaw": "process.stdout",
              "name": "stdout",
              "desc": "<p>A <code>Writable Stream</code> to <code>stdout</code> (on fd <code>1</code>).</p>\n<p>For example, a <code>console.log</code> equivalent could look like this:</p>\n<pre><code class=\"lang-js\">console.log = (msg) =&gt; {\n  process.stdout.write(`${msg}\\n`);\n};\n</code></pre>\n<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node.js in\nthat they cannot be closed (<code>end()</code> will throw), they never emit the <code>&#39;finish&#39;</code>\nevent and that writes can block when output is redirected to a file (although\ndisks are fast and operating systems normally employ write-back caching so it\nshould be a very rare occurrence indeed.)</p>\n<p>Additionally, <code>process.stderr</code> and <code>process.stdout</code> are blocking when outputting\nto TTYs (terminals) on OS X as a workaround for the OS&#39;s very small, 1kb\nbuffer size. This is to prevent interleaving between <code>stdout</code> and <code>stderr</code>.</p>\n<p>To check if Node.js is being run in a TTY context, read the <code>isTTY</code> property\non <code>process.stderr</code>, <code>process.stdout</code>, or <code>process.stdin</code>:</p>\n<pre><code>$ node -p &quot;Boolean(process.stdin.isTTY)&quot;\ntrue\n$ echo &quot;foo&quot; | node -p &quot;Boolean(process.stdin.isTTY)&quot;\nfalse\n\n$ node -p &quot;Boolean(process.stdout.isTTY)&quot;\ntrue\n$ node -p &quot;Boolean(process.stdout.isTTY)&quot; | cat\nfalse\n</code></pre><p>See [the tty docs][] for more information.</p>\n"
            },
            {
              "textRaw": "process.title",
              "name": "title",
              "meta": {
                "added": [
                  "v0.1.104"
                ]
              },
              "desc": "<p>Getter/setter to set what is displayed in <code>ps</code>.</p>\n<p>When used as a setter, the maximum length is platform-specific and probably\nshort.</p>\n<p>On Linux and OS X, it&#39;s limited to the size of the binary name plus the\nlength of the command line arguments because it overwrites the argv memory.</p>\n<p>v0.8 allowed for longer process title strings by also overwriting the environ\nmemory but that was potentially insecure/confusing in some (rather obscure)\ncases.</p>\n"
            },
            {
              "textRaw": "process.version",
              "name": "version",
              "meta": {
                "added": [
                  "v0.1.3"
                ]
              },
              "desc": "<p>A compiled-in property that exposes <code>NODE_VERSION</code>.</p>\n<pre><code class=\"lang-js\">console.log(`Version: ${process.version}`);\n</code></pre>\n"
            },
            {
              "textRaw": "process.versions",
              "name": "versions",
              "meta": {
                "added": [
                  "v0.2.0"
                ]
              },
              "desc": "<p>A property exposing version strings of Node.js and its dependencies.</p>\n<pre><code class=\"lang-js\">console.log(process.versions);\n</code></pre>\n<p>Will print something like:</p>\n<pre><code class=\"lang-js\">{ http_parser: &#39;2.3.0&#39;,\n  node: &#39;1.1.1&#39;,\n  v8: &#39;4.1.0.14&#39;,\n  uv: &#39;1.3.0&#39;,\n  zlib: &#39;1.2.8&#39;,\n  ares: &#39;1.10.0-DEV&#39;,\n  modules: &#39;43&#39;,\n  icu: &#39;55.1&#39;,\n  openssl: &#39;1.0.1k&#39; }\n</code></pre>\n<!-- [end-include:process.md] -->\n<!-- [start-include:punycode.md] -->\n"
            }
          ]
        }
      ],
      "vars": [
        {
          "textRaw": "\\_\\_dirname",
          "name": "\\_\\_dirname",
          "type": "var",
          "desc": "<ul>\n<li>{String}</li>\n</ul>\n<p>The name of the directory that the currently executing script resides in.</p>\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>\n<pre><code class=\"lang-js\">console.log(__dirname);\n// /Users/mjr\n</code></pre>\n<p><code>__dirname</code> isn&#39;t actually a global but rather local to each module.</p>\n<p>For instance, given two modules: <code>a</code> and <code>b</code>, where <code>b</code> is a dependency of\n<code>a</code> and there is a directory structure of:</p>\n<ul>\n<li><code>/Users/mjr/app/a.js</code></li>\n<li><code>/Users/mjr/app/node_modules/b/b.js</code></li>\n</ul>\n<p>References to <code>__dirname</code> within <code>b.js</code> will return\n<code>/Users/mjr/app/node_modules/b</code> while references to <code>__dirname</code> within <code>a.js</code>\nwill return <code>/Users/mjr/app</code>.</p>\n"
        },
        {
          "textRaw": "\\_\\_filename",
          "name": "\\_\\_filename",
          "type": "var",
          "desc": "<ul>\n<li>{String}</li>\n</ul>\n<p>The filename of the code being executed.  This is the resolved absolute path\nof this code file.  For a main program this is not necessarily the same\nfilename used in the command line.  The value inside a module is the path\nto that module file.</p>\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>\n<pre><code class=\"lang-js\">console.log(__filename);\n// /Users/mjr/example.js\n</code></pre>\n<p><code>__filename</code> isn&#39;t actually a global but rather local to each module.</p>\n"
        },
        {
          "textRaw": "exports",
          "name": "exports",
          "type": "var",
          "desc": "<p>A reference to the <code>module.exports</code> that is shorter to type.\nSee [module system documentation][] for details on when to use <code>exports</code> and\nwhen to use <code>module.exports</code>.</p>\n<p><code>exports</code> isn&#39;t actually a global but rather local to each module.</p>\n<p>See the [module system documentation][] for more information.</p>\n"
        },
        {
          "textRaw": "module",
          "name": "module",
          "type": "var",
          "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>A reference to the current module. In particular\n<code>module.exports</code> is used for defining what a module exports and makes\navailable through <code>require()</code>.</p>\n<p><code>module</code> isn&#39;t actually a global but rather local to each module.</p>\n<p>See the [module system documentation][] for more information.</p>\n"
        },
        {
          "textRaw": "require()",
          "type": "var",
          "name": "require",
          "desc": "<ul>\n<li>{Function}</li>\n</ul>\n<p>To require modules. See the [Modules][] section.  <code>require</code> isn&#39;t actually a\nglobal but rather local to each module.</p>\n",
          "properties": [
            {
              "textRaw": "`cache` {Object} ",
              "type": "Object",
              "name": "cache",
              "desc": "<p>Modules are cached in this object when they are required. By deleting a key\nvalue from this object, the next <code>require</code> will reload the module. Note that\nthis does not apply to [native addons][], for which reloading will result in an\nError.</p>\n"
            },
            {
              "textRaw": "`extensions` {Object} ",
              "type": "Object",
              "name": "extensions",
              "stability": 0,
              "stabilityText": "Deprecated",
              "desc": "<p>Instruct <code>require</code> on how to handle certain file extensions.</p>\n<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:</p>\n<pre><code class=\"lang-js\">require.extensions[&#39;.sjs&#39;] = require.extensions[&#39;.js&#39;];\n</code></pre>\n<p><strong>Deprecated</strong>  In the past, this list has been used to load\nnon-JavaScript modules into Node.js by compiling them on-demand.\nHowever, in practice, there are much better ways to do this, such as\nloading modules via some other Node.js program, or compiling them to\nJavaScript ahead of time.</p>\n<p>Since the Module system is locked, this feature will probably never go\naway.  However, it may have subtle bugs and complexities that are best\nleft untouched.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "require.resolve()",
              "type": "method",
              "name": "resolve",
              "desc": "<p>Use the internal <code>require()</code> machinery to look up the location of a module,\nbut rather than loading the module, just return the resolved filename.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "modules": [
    {
      "textRaw": "Addons",
      "name": "addons",
      "desc": "<p>Node.js Addons are dynamically-linked shared objects, written in C or C++, that\ncan be loaded into Node.js using the [<code>require()</code>][require] function, and used\njust as if they were an ordinary Node.js module. They are used primarily to\nprovide an interface between JavaScript running in Node.js and C/C++ libraries.</p>\n<p>At the moment, the method for implementing Addons is rather complicated,\ninvolving knowledge of several components and APIs :</p>\n<ul>\n<li><p>V8: the C++ library Node.js currently uses to provide the\nJavaScript implementation. V8 provides the mechanisms for creating objects,\ncalling functions, etc. V8&#39;s API is documented mostly in the\n<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node.js source\ntree), which is also available [online][v8-docs].</p>\n</li>\n<li><p>[libuv][]: The C library that implements the Node.js event loop, its worker\nthreads and all of the asynchronous behaviors of the platform. It also\nserves as a cross-platform abstraction library, giving easy, POSIX-like\naccess across all major operating systems to many common system tasks, such\nas interacting with the filesystem, sockets, timers and system events. libuv\nalso provides a pthreads-like threading abstraction that may be used to\npower more sophisticated asynchronous Addons that need to move beyond the\nstandard event loop. Addon authors are encouraged to think about how to\navoid blocking the event loop with I/O or other time-intensive tasks by\noff-loading work via libuv to non-blocking system operations, worker threads\nor a custom use of libuv&#39;s threads.</p>\n</li>\n<li><p>Internal Node.js libraries. Node.js itself exports a number of C/C++ APIs\nthat Addons can use &mdash; the most important of which is the\n<code>node::ObjectWrap</code> class.</p>\n</li>\n<li><p>Node.js includes a number of other statically linked libraries including\nOpenSSL. These other libraries are located in the <code>deps/</code> directory in the\nNode.js source tree. Only the V8 and OpenSSL symbols are purposefully\nre-exported by Node.js and may be used to various extents by Addons.\nSee [Linking to Node.js&#39; own dependencies][] for additional information.</p>\n</li>\n</ul>\n<p>All of the following examples are available for [download][] and may\nbe used as a starting-point for your own Addon.</p>\n",
      "modules": [
        {
          "textRaw": "Hello world",
          "name": "hello_world",
          "desc": "<p>This &quot;Hello world&quot; example is a simple Addon, written in C++, that is the\nequivalent of the following JavaScript code:</p>\n<pre><code class=\"lang-js\">module.exports.hello = () =&gt; &#39;world&#39;;\n</code></pre>\n<p>First, create the file <code>hello.cc</code>:</p>\n<pre><code class=\"lang-cpp\">// hello.cc\n#include &lt;node.h&gt;\n\nnamespace demo {\n\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n  args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;world&quot;));\n}\n\nvoid init(Local&lt;Object&gt; exports) {\n  NODE_SET_METHOD(exports, &quot;hello&quot;, Method);\n}\n\nNODE_MODULE(addon, init)\n\n}  // namespace demo\n</code></pre>\n<p>Note that all Node.js Addons must export an initialization function following\nthe pattern:</p>\n<pre><code class=\"lang-cpp\">void Initialize(Local&lt;Object&gt; exports);\nNODE_MODULE(module_name, Initialize)\n</code></pre>\n<p>There is no semi-colon after <code>NODE_MODULE</code> as it&#39;s not a function (see\n<code>node.h</code>).</p>\n<p>The <code>module_name</code> must match the filename of the final binary (excluding\nthe .node suffix).</p>\n<p>In the <code>hello.cc</code> example, then, the initialization function is <code>init</code> and the\nAddon module name is <code>addon</code>.</p>\n",
          "modules": [
            {
              "textRaw": "Building",
              "name": "building",
              "desc": "<p>Once the source code has been written, it must be compiled into the binary\n<code>addon.node</code> file. To do so, create a file called <code>binding.gyp</code> in the\ntop-level of the project describing the build configuration of your module\nusing a JSON-like format. This file is used by [node-gyp][] -- a tool written\nspecifically to compile Node.js Addons.</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [ &quot;hello.cc&quot; ]\n    }\n  ]\n}\n</code></pre><p><em>Note: A version of the <code>node-gyp</code> utility is bundled and distributed with\nNode.js as part of <code>npm</code>. This version is not made directly available for\ndevelopers to use and is intended only to support the ability to use the\n<code>npm install</code> command to compile and install Addons. Developers who wish to\nuse <code>node-gyp</code> directly can install it using the command\n<code>npm install -g node-gyp</code>. See the <code>node-gyp</code> [installation instructions][] for\nmore information, including platform-specific requirements.</em></p>\n<p>Once the <code>binding.gyp</code> file has been created, use <code>node-gyp configure</code> to\ngenerate the appropriate project build files for the current platform. This\nwill generate either a <code>Makefile</code> (on Unix platforms) or a <code>vcxproj</code> file\n(on Windows) in the <code>build/</code> directory.</p>\n<p>Next, invoke the <code>node-gyp build</code> command to generate the compiled <code>addon.node</code>\nfile. This will be put into the <code>build/Release/</code> directory.</p>\n<p>When using <code>npm install</code> to install a Node.js Addon, npm uses its own bundled\nversion of <code>node-gyp</code> to perform this same set of actions, generating a\ncompiled version of the Addon for the user&#39;s platform on demand.</p>\n<p>Once built, the binary Addon can be used from within Node.js by pointing\n[<code>require()</code>][require] to the built <code>addon.node</code> module:</p>\n<pre><code class=\"lang-js\">// hello.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\nconsole.log(addon.hello()); // &#39;world&#39;\n</code></pre>\n<p>Please see the examples below for further information or\n<a href=\"https://github.com/arturadib/node-qt\">https://github.com/arturadib/node-qt</a> for an example in production.</p>\n<p>Because the exact path to the compiled Addon binary can vary depending on how\nit is compiled (i.e. sometimes it may be in <code>./build/Debug/</code>), Addons can use\nthe [bindings][] package to load the compiled module.</p>\n<p>Note that while the <code>bindings</code> package implementation is more sophisticated\nin how it locates Addon modules, it is essentially using a try-catch pattern\nsimilar to:</p>\n<pre><code class=\"lang-js\">try {\n  return require(&#39;./build/Release/addon.node&#39;);\n} catch (err) {\n  return require(&#39;./build/Debug/addon.node&#39;);\n}\n</code></pre>\n",
              "type": "module",
              "displayName": "Building"
            },
            {
              "textRaw": "Linking to Node.js' own dependencies",
              "name": "linking_to_node.js'_own_dependencies",
              "desc": "<p>Node.js uses a number of statically linked libraries such as V8, libuv and\nOpenSSL. All Addons are required to link to V8 and may link to any of the\nother dependencies as well. Typically, this is as simple as including\nthe appropriate <code>#include &lt;...&gt;</code> statements (e.g. <code>#include &lt;v8.h&gt;</code>) and\n<code>node-gyp</code> will locate the appropriate headers automatically. However, there\nare a few caveats to be aware of:</p>\n<ul>\n<li><p>When <code>node-gyp</code> runs, it will detect the specific release version of Node.js\nand download either the full source tarball or just the headers. If the full\nsource is downloaded, Addons will have complete access to the full set of\nNode.js dependencies. However, if only the Node.js headers are downloaded, then\nonly the symbols exported by Node.js will be available.</p>\n</li>\n<li><p><code>node-gyp</code> can be run using the <code>--nodedir</code> flag pointing at a local Node.js\nsource image. Using this option, the Addon will have access to the full set of\ndependencies.</p>\n</li>\n</ul>\n",
              "type": "module",
              "displayName": "Linking to Node.js' own dependencies"
            },
            {
              "textRaw": "Loading Addons using require()",
              "name": "loading_addons_using_require()",
              "desc": "<p>The filename extension of the compiled Addon binary is <code>.node</code> (as opposed\nto <code>.dll</code> or <code>.so</code>). The [<code>require()</code>][require] function is written to look for\nfiles with the <code>.node</code> file extension and initialize those as dynamically-linked\nlibraries.</p>\n<p>When calling [<code>require()</code>][require], the <code>.node</code> extension can usually be\nomitted and Node.js will still find and initialize the Addon. One caveat,\nhowever, is that Node.js will first attempt to locate and load modules or\nJavaScript files that happen to share the same base name. For instance, if\nthere is a file <code>addon.js</code> in the same directory as the binary <code>addon.node</code>,\nthen [<code>require(&#39;addon&#39;)</code>][require] will give precedence to the <code>addon.js</code> file\nand load it instead.</p>\n",
              "type": "module",
              "displayName": "Loading Addons using require()"
            }
          ],
          "type": "module",
          "displayName": "Hello world"
        },
        {
          "textRaw": "Addon examples",
          "name": "addon_examples",
          "desc": "<p>Following are some example Addons intended to help developers get started. The\nexamples make use of the V8 APIs. Refer to the online [V8 reference][v8-docs]\nfor help with the various V8 calls, and V8&#39;s [Embedder&#39;s Guide][] for an\nexplanation of several concepts used such as handles, scopes, function\ntemplates, etc.</p>\n<p>Each of these examples using the following <code>binding.gyp</code> file:</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [ &quot;addon.cc&quot; ]\n    }\n  ]\n}\n</code></pre><p>In cases where there is more than one <code>.cc</code> file, simply add the additional\nfilename to the <code>sources</code> array. For example:</p>\n<pre><code>&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]\n</code></pre><p>Once the <code>binding.gyp</code> file is ready, the example Addons can be configured and\nbuilt using <code>node-gyp</code>:</p>\n<pre><code>$ node-gyp configure build\n</code></pre>",
          "modules": [
            {
              "textRaw": "Function arguments",
              "name": "function_arguments",
              "desc": "<p>Addons will typically expose objects and functions that can be accessed from\nJavaScript running within Node.js. When functions are invoked from JavaScript,\nthe input arguments and return value must be mapped to and from the C/C++\ncode.</p>\n<p>The following example illustrates how to read function arguments passed from\nJavaScript and how to return a result:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n\nnamespace demo {\n\nusing v8::Exception;\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Number;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\n// This is the implementation of the &quot;add&quot; method\n// Input arguments are passed using the\n// const FunctionCallbackInfo&lt;Value&gt;&amp; args struct\nvoid Add(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  // Check the number of arguments passed.\n  if (args.Length() &lt; 2) {\n    // Throw an Error that is passed back to JavaScript\n    isolate-&gt;ThrowException(Exception::TypeError(\n        String::NewFromUtf8(isolate, &quot;Wrong number of arguments&quot;)));\n    return;\n  }\n\n  // Check the argument types\n  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {\n    isolate-&gt;ThrowException(Exception::TypeError(\n        String::NewFromUtf8(isolate, &quot;Wrong arguments&quot;)));\n    return;\n  }\n\n  // Perform the operation\n  double value = args[0]-&gt;NumberValue() + args[1]-&gt;NumberValue();\n  Local&lt;Number&gt; num = Number::New(isolate, value);\n\n  // Set the return value (using the passed in\n  // FunctionCallbackInfo&lt;Value&gt;&amp;)\n  args.GetReturnValue().Set(num);\n}\n\nvoid Init(Local&lt;Object&gt; exports) {\n  NODE_SET_METHOD(exports, &quot;add&quot;, Add);\n}\n\nNODE_MODULE(addon, Init)\n\n}  // namespace demo\n</code></pre>\n<p>Once compiled, the example Addon can be required and used from within Node.js:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\nconsole.log(&#39;This should be eight:&#39;, addon.add(3, 5));\n</code></pre>\n",
              "type": "module",
              "displayName": "Function arguments"
            },
            {
              "textRaw": "Callbacks",
              "name": "callbacks",
              "desc": "<p>It is common practice within Addons to pass JavaScript functions to a C++\nfunction and execute them from there. The following example illustrates how\nto invoke such callbacks:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n\nnamespace demo {\n\nusing v8::Function;\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Null;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid RunCallback(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);\n  const unsigned argc = 1;\n  Local&lt;Value&gt; argv[argc] = { String::NewFromUtf8(isolate, &quot;hello world&quot;) };\n  cb-&gt;Call(Null(isolate), argc, argv);\n}\n\nvoid Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n  NODE_SET_METHOD(module, &quot;exports&quot;, RunCallback);\n}\n\nNODE_MODULE(addon, Init)\n\n}  // namespace demo\n</code></pre>\n<p>Note that this example uses a two-argument form of <code>Init()</code> that receives\nthe full <code>module</code> object as the second argument. This allows the Addon\nto completely overwrite <code>exports</code> with a single function instead of\nadding the function as a property of <code>exports</code>.</p>\n<p>To test it, run the following JavaScript:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\naddon((msg) =&gt; {\n  console.log(msg); // &#39;hello world&#39;\n});\n</code></pre>\n<p>Note that, in this example, the callback function is invoked synchronously.</p>\n",
              "type": "module",
              "displayName": "Callbacks"
            },
            {
              "textRaw": "Object factory",
              "name": "object_factory",
              "desc": "<p>Addons can create and return new objects from within a C++ function as\nillustrated in the following example. An object is created and returned with a\nproperty <code>msg</code> that echoes the string passed to <code>createObject()</code>:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n\nnamespace demo {\n\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid CreateObject(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  Local&lt;Object&gt; obj = Object::New(isolate);\n  obj-&gt;Set(String::NewFromUtf8(isolate, &quot;msg&quot;), args[0]-&gt;ToString());\n\n  args.GetReturnValue().Set(obj);\n}\n\nvoid Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n  NODE_SET_METHOD(module, &quot;exports&quot;, CreateObject);\n}\n\nNODE_MODULE(addon, Init)\n\n}  // namespace demo\n</code></pre>\n<p>To test it in JavaScript:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\nvar obj1 = addon(&#39;hello&#39;);\nvar obj2 = addon(&#39;world&#39;);\nconsole.log(obj1.msg + &#39; &#39; + obj2.msg); // &#39;hello world&#39;\n</code></pre>\n",
              "type": "module",
              "displayName": "Object factory"
            },
            {
              "textRaw": "Function factory",
              "name": "function_factory",
              "desc": "<p>Another common scenario is creating JavaScript functions that wrap C++\nfunctions and returning those back to JavaScript:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n\nnamespace demo {\n\nusing v8::Function;\nusing v8::FunctionCallbackInfo;\nusing v8::FunctionTemplate;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid MyFunction(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n  args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;hello world&quot;));\n}\n\nvoid CreateFunction(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, MyFunction);\n  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();\n\n  // omit this to make it anonymous\n  fn-&gt;SetName(String::NewFromUtf8(isolate, &quot;theFunction&quot;));\n\n  args.GetReturnValue().Set(fn);\n}\n\nvoid Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n  NODE_SET_METHOD(module, &quot;exports&quot;, CreateFunction);\n}\n\nNODE_MODULE(addon, Init)\n\n}  // namespace demo\n</code></pre>\n<p>To test:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\nvar fn = addon();\nconsole.log(fn()); // &#39;hello world&#39;\n</code></pre>\n",
              "type": "module",
              "displayName": "Function factory"
            },
            {
              "textRaw": "Wrapping C++ objects",
              "name": "wrapping_c++_objects",
              "desc": "<p>It is also possible to wrap C++ objects/classes in a way that allows new\ninstances to be created using the JavaScript <code>new</code> operator:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nnamespace demo {\n\nusing v8::Local;\nusing v8::Object;\n\nvoid InitAll(Local&lt;Object&gt; exports) {\n  MyObject::Init(exports);\n}\n\nNODE_MODULE(addon, InitAll)\n\n}  // namespace demo\n</code></pre>\n<p>Then, in <code>myobject.h</code>, the wrapper class inherits from <code>node::ObjectWrap</code>:</p>\n<pre><code class=\"lang-cpp\">// myobject.h\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n#include &lt;node_object_wrap.h&gt;\n\nnamespace demo {\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init(v8::Local&lt;v8::Object&gt; exports);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n  static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n}  // namespace demo\n\n#endif\n</code></pre>\n<p>In <code>myobject.cc</code>, implement the various methods that are to be exposed.\nBelow, the method <code>plusOne()</code> is exposed by adding it to the constructor&#39;s\nprototype:</p>\n<pre><code class=\"lang-cpp\">// myobject.cc\n#include &quot;myobject.h&quot;\n\nnamespace demo {\n\nusing v8::Context;\nusing v8::Function;\nusing v8::FunctionCallbackInfo;\nusing v8::FunctionTemplate;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Number;\nusing v8::Object;\nusing v8::Persistent;\nusing v8::String;\nusing v8::Value;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Local&lt;Object&gt; exports) {\n  Isolate* isolate = exports-&gt;GetIsolate();\n\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);\n  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n\n  // Prototype\n  NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne);\n\n  constructor.Reset(isolate, tpl-&gt;GetFunction());\n  exports-&gt;Set(String::NewFromUtf8(isolate, &quot;MyObject&quot;),\n               tpl-&gt;GetFunction());\n}\n\nvoid MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    args.GetReturnValue().Set(args.This());\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();\n    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);\n    Local&lt;Object&gt; result =\n        cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();\n    args.GetReturnValue().Set(result);\n  }\n}\n\nvoid MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());\n  obj-&gt;value_ += 1;\n\n  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));\n}\n\n}  // namespace demo\n</code></pre>\n<p>To build this example, the <code>myobject.cc</code> file must be added to the\n<code>binding.gyp</code>:</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [\n        &quot;addon.cc&quot;,\n        &quot;myobject.cc&quot;\n      ]\n    }\n  ]\n}\n</code></pre><p>Test it with:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\nvar obj = new addon.MyObject(10);\nconsole.log(obj.plusOne()); // 11\nconsole.log(obj.plusOne()); // 12\nconsole.log(obj.plusOne()); // 13\n</code></pre>\n",
              "type": "module",
              "displayName": "Wrapping C++ objects"
            },
            {
              "textRaw": "Factory of wrapped objects",
              "name": "factory_of_wrapped_objects",
              "desc": "<p>Alternatively, it is possible to use a factory pattern to avoid explicitly\ncreating object instances using the JavaScript <code>new</code> operator:</p>\n<pre><code class=\"lang-js\">var obj = addon.createObject();\n// instead of:\n// var obj = new addon.Object();\n</code></pre>\n<p>First, the <code>createObject()</code> method is implemented in <code>addon.cc</code>:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nnamespace demo {\n\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid CreateObject(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  MyObject::NewInstance(args);\n}\n\nvoid InitAll(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n  MyObject::Init(exports-&gt;GetIsolate());\n\n  NODE_SET_METHOD(module, &quot;exports&quot;, CreateObject);\n}\n\nNODE_MODULE(addon, InitAll)\n\n}  // namespace demo\n</code></pre>\n<p>In <code>myobject.h</code>, the static method <code>NewInstance()</code> is added to handle\ninstantiating the object. This method takes the place of using <code>new</code> in\nJavaScript:</p>\n<pre><code class=\"lang-cpp\">// myobject.h\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n#include &lt;node_object_wrap.h&gt;\n\nnamespace demo {\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init(v8::Isolate* isolate);\n  static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n  static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n}  // namespace demo\n\n#endif\n</code></pre>\n<p>The implementation in <code>myobject.cc</code> is similar to the previous example:</p>\n<pre><code class=\"lang-cpp\">// myobject.cc\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nnamespace demo {\n\nusing v8::Context;\nusing v8::Function;\nusing v8::FunctionCallbackInfo;\nusing v8::FunctionTemplate;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Number;\nusing v8::Object;\nusing v8::Persistent;\nusing v8::String;\nusing v8::Value;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Isolate* isolate) {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);\n  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n\n  // Prototype\n  NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne);\n\n  constructor.Reset(isolate, tpl-&gt;GetFunction());\n}\n\nvoid MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    args.GetReturnValue().Set(args.This());\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);\n    Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();\n    Local&lt;Object&gt; instance =\n        cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();\n    args.GetReturnValue().Set(instance);\n  }\n}\n\nvoid MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  const unsigned argc = 1;\n  Local&lt;Value&gt; argv[argc] = { args[0] };\n  Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);\n  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();\n  Local&lt;Object&gt; instance =\n      cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();\n\n  args.GetReturnValue().Set(instance);\n}\n\nvoid MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());\n  obj-&gt;value_ += 1;\n\n  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));\n}\n\n}  // namespace demo\n</code></pre>\n<p>Once again, to build this example, the <code>myobject.cc</code> file must be added to the\n<code>binding.gyp</code>:</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [\n        &quot;addon.cc&quot;,\n        &quot;myobject.cc&quot;\n      ]\n    }\n  ]\n}\n</code></pre><p>Test it with:</p>\n<pre><code class=\"lang-js\">// test.js\nconst createObject = require(&#39;./build/Release/addon&#39;);\n\nvar obj = createObject(10);\nconsole.log(obj.plusOne()); // 11\nconsole.log(obj.plusOne()); // 12\nconsole.log(obj.plusOne()); // 13\n\nvar obj2 = createObject(20);\nconsole.log(obj2.plusOne()); // 21\nconsole.log(obj2.plusOne()); // 22\nconsole.log(obj2.plusOne()); // 23\n</code></pre>\n",
              "type": "module",
              "displayName": "Factory of wrapped objects"
            },
            {
              "textRaw": "Passing wrapped objects around",
              "name": "passing_wrapped_objects_around",
              "desc": "<p>In addition to wrapping and returning C++ objects, it is possible to pass\nwrapped objects around by unwrapping them with the Node.js helper function\n<code>node::ObjectWrap::Unwrap</code>. The following examples shows a function <code>add()</code>\nthat can take two <code>MyObject</code> objects as input arguments:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#include &lt;node.h&gt;\n#include &lt;node_object_wrap.h&gt;\n#include &quot;myobject.h&quot;\n\nnamespace demo {\n\nusing v8::FunctionCallbackInfo;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Number;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid CreateObject(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  MyObject::NewInstance(args);\n}\n\nvoid Add(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[0]-&gt;ToObject());\n  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[1]-&gt;ToObject());\n\n  double sum = obj1-&gt;value() + obj2-&gt;value();\n  args.GetReturnValue().Set(Number::New(isolate, sum));\n}\n\nvoid InitAll(Local&lt;Object&gt; exports) {\n  MyObject::Init(exports-&gt;GetIsolate());\n\n  NODE_SET_METHOD(exports, &quot;createObject&quot;, CreateObject);\n  NODE_SET_METHOD(exports, &quot;add&quot;, Add);\n}\n\nNODE_MODULE(addon, InitAll)\n\n}  // namespace demo\n</code></pre>\n<p>In <code>myobject.h</code>, a new public method is added to allow access to private values\nafter unwrapping the object.</p>\n<pre><code class=\"lang-cpp\">// myobject.h\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n#include &lt;node_object_wrap.h&gt;\n\nnamespace demo {\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init(v8::Isolate* isolate);\n  static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n  inline double value() const { return value_; }\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n}  // namespace demo\n\n#endif\n</code></pre>\n<p>The implementation of <code>myobject.cc</code> is similar to before:</p>\n<pre><code class=\"lang-cpp\">// myobject.cc\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nnamespace demo {\n\nusing v8::Context;\nusing v8::Function;\nusing v8::FunctionCallbackInfo;\nusing v8::FunctionTemplate;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\nusing v8::Persistent;\nusing v8::String;\nusing v8::Value;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Isolate* isolate) {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);\n  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n\n  constructor.Reset(isolate, tpl-&gt;GetFunction());\n}\n\nvoid MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    args.GetReturnValue().Set(args.This());\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();\n    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);\n    Local&lt;Object&gt; instance =\n        cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();\n    args.GetReturnValue().Set(instance);\n  }\n}\n\nvoid MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = args.GetIsolate();\n\n  const unsigned argc = 1;\n  Local&lt;Value&gt; argv[argc] = { args[0] };\n  Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);\n  Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();\n  Local&lt;Object&gt; instance =\n      cons-&gt;NewInstance(context, argc, argv).ToLocalChecked();\n\n  args.GetReturnValue().Set(instance);\n}\n\n}  // namespace demo\n</code></pre>\n<p>Test it with:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n\nvar obj1 = addon.createObject(10);\nvar obj2 = addon.createObject(20);\nvar result = addon.add(obj1, obj2);\n\nconsole.log(result); // 30\n</code></pre>\n",
              "type": "module",
              "displayName": "Passing wrapped objects around"
            },
            {
              "textRaw": "AtExit hooks",
              "name": "atexit_hooks",
              "desc": "<p>An &quot;AtExit&quot; hook is a function that is invoked after the Node.js event loop\nhas ended but before the JavaScript VM is terminated and Node.js shuts down.\n&quot;AtExit&quot; hooks are registered using the <code>node::AtExit</code> API.</p>\n",
              "modules": [
                {
                  "textRaw": "void AtExit(callback, args)",
                  "name": "void_atexit(callback,_args)",
                  "desc": "<ul>\n<li><code>callback</code>: <code>void (*)(void*)</code> - A pointer to the function to call at exit.</li>\n<li><code>args</code>: <code>void*</code> - A pointer to pass to the callback at exit.</li>\n</ul>\n<p>Registers exit hooks that run after the event loop has ended but before the VM\nis killed.</p>\n<p>AtExit takes two parameters: a pointer to a callback function to run at exit,\nand a pointer to untyped context data to be passed to that callback.</p>\n<p>Callbacks are run in last-in first-out order.</p>\n<p>The following <code>addon.cc</code> implements AtExit:</p>\n<pre><code class=\"lang-cpp\">// addon.cc\n#undef NDEBUG\n#include &lt;assert.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;node.h&gt;\n\nnamespace demo {\n\nusing node::AtExit;\nusing v8::HandleScope;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Object;\n\nstatic char cookie[] = &quot;yum yum&quot;;\nstatic int at_exit_cb1_called = 0;\nstatic int at_exit_cb2_called = 0;\n\nstatic void at_exit_cb1(void* arg) {\n  Isolate* isolate = static_cast&lt;Isolate*&gt;(arg);\n  HandleScope scope(isolate);\n  Local&lt;Object&gt; obj = Object::New(isolate);\n  assert(!obj.IsEmpty()); // assert VM is still alive\n  assert(obj-&gt;IsObject());\n  at_exit_cb1_called++;\n}\n\nstatic void at_exit_cb2(void* arg) {\n  assert(arg == static_cast&lt;void*&gt;(cookie));\n  at_exit_cb2_called++;\n}\n\nstatic void sanity_check(void*) {\n  assert(at_exit_cb1_called == 1);\n  assert(at_exit_cb2_called == 2);\n}\n\nvoid init(Local&lt;Object&gt; exports) {\n  AtExit(sanity_check);\n  AtExit(at_exit_cb2, cookie);\n  AtExit(at_exit_cb2, cookie);\n  AtExit(at_exit_cb1, exports-&gt;GetIsolate());\n}\n\nNODE_MODULE(addon, init);\n\n}  // namespace demo\n</code></pre>\n<p>Test in JavaScript by running:</p>\n<pre><code class=\"lang-js\">// test.js\nconst addon = require(&#39;./build/Release/addon&#39;);\n</code></pre>\n<!-- [end-include:addons.md] -->\n<!-- [start-include:assert.md] -->\n",
                  "type": "module",
                  "displayName": "void AtExit(callback, args)"
                }
              ],
              "type": "module",
              "displayName": "AtExit hooks"
            }
          ],
          "type": "module",
          "displayName": "Addon examples"
        }
      ],
      "properties": [
        {
          "textRaw": "Native Abstractions for Node.js",
          "name": "js",
          "desc": "<p>Each of the examples illustrated in this document make direct use of the\nNode.js and V8 APIs for implementing Addons. It is important to understand\nthat the V8 API can, and has, changed dramatically from one V8 release to the\nnext (and one major Node.js release to the next). With each change, Addons may\nneed to be updated and recompiled in order to continue functioning. The Node.js\nrelease schedule is designed to minimize the frequency and impact of such\nchanges but there is little that Node.js can do currently to ensure stability\nof the V8 APIs.</p>\n<p>The [Native Abstractions for Node.js][] (or <code>nan</code>) provide a set of tools that\nAddon developers are recommended to use to keep compatibility between past and\nfuture releases of V8 and Node.js. See the <code>nan</code> [examples][] for an\nillustration of how it can be used.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Addons"
    },
    {
      "textRaw": "Assert",
      "name": "assert",
      "stability": 3,
      "stabilityText": "Locked",
      "desc": "<p>The <code>assert</code> module provides a simple set of assertion tests that can be used to\ntest invariants. The module is intended for internal use by Node.js, but can be\nused in application code via <code>require(&#39;assert&#39;)</code>. However, <code>assert</code> is not a\ntesting framework, and is not intended to be used as a general purpose assertion\nlibrary.</p>\n<p>The API for the <code>assert</code> module is [Locked][]. This means that there will be no\nadditions or changes to any of the methods implemented and exposed by\nthe module.</p>\n",
      "methods": [
        {
          "textRaw": "assert(value[, message])",
          "type": "method",
          "name": "assert",
          "meta": {
            "added": [
              "v0.5.9"
            ]
          },
          "desc": "<p>An alias of [<code>assert.ok()</code>][] .</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert(true);  // OK\nassert(1);     // OK\nassert(false);\n  // throws &quot;AssertionError: false == true&quot;\nassert(0);\n  // throws &quot;AssertionError: 0 == true&quot;\nassert(false, &#39;it\\&#39;s false&#39;);\n  // throws &quot;AssertionError: it&#39;s false&quot;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.deepEqual(actual, expected[, message])",
          "type": "method",
          "name": "deepEqual",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests for deep equality between the <code>actual</code> and <code>expected</code> parameters.\nPrimitive values are compared with the equal comparison operator ( <code>==</code> ).</p>\n<p>Only enumerable &quot;own&quot; properties are considered. The <code>deepEqual()</code>\nimplementation does not test object prototypes, attached symbols, or\nnon-enumerable properties. This can lead to some potentially surprising\nresults. For example, the following example does not throw an <code>AssertionError</code>\nbecause the properties on the [<code>Error</code>][] object are non-enumerable:</p>\n<pre><code class=\"lang-js\">// WARNING: This does not throw an AssertionError!\nassert.deepEqual(Error(&#39;a&#39;), Error(&#39;b&#39;));\n</code></pre>\n<p>&quot;Deep&quot; equality means that the enumerable &quot;own&quot; properties of child objects\nare evaluated also:</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nconst obj1 = {\n  a : {\n    b : 1\n  }\n};\nconst obj2 = {\n  a : {\n    b : 2\n  }\n};\nconst obj3 = {\n  a : {\n    b : 1\n  }\n}\nconst obj4 = Object.create(obj1);\n\nassert.deepEqual(obj1, obj1);\n  // OK, object is equal to itself\n\nassert.deepEqual(obj1, obj2);\n  // AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }\n  // values of b are different\n\nassert.deepEqual(obj1, obj3);\n  // OK, objects are equal\n\nassert.deepEqual(obj1, obj4);\n  // AssertionError: { a: { b: 1 } } deepEqual {}\n  // Prototypes are ignored\n</code></pre>\n<p>If the values are not equal, an <code>AssertionError</code> is thrown with a <code>message</code>\nproperty set equal to the value of the <code>message</code> parameter. If the <code>message</code>\nparameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.deepStrictEqual(actual, expected[, message])",
          "type": "method",
          "name": "deepStrictEqual",
          "meta": {
            "added": [
              "v1.2.0"
            ]
          },
          "desc": "<p>Generally identical to <code>assert.deepEqual()</code> with two exceptions. First,\nprimitive values are compared using the strict equality operator ( <code>===</code> ).\nSecond, object comparisons include a strict equality check of their prototypes.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.deepEqual({a:1}, {a:&#39;1&#39;});\n  // OK, because 1 == &#39;1&#39;\n\nassert.deepStrictEqual({a:1}, {a:&#39;1&#39;});\n  // AssertionError: { a: 1 } deepStrictEqual { a: &#39;1&#39; }\n  // because 1 !== &#39;1&#39; using strict equality\n</code></pre>\n<p>If the values are not equal, an <code>AssertionError</code> is thrown with a <code>message</code>\nproperty set equal to the value of the <code>message</code> parameter. If the <code>message</code>\nparameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.doesNotThrow(block[, error][, message])",
          "type": "method",
          "name": "doesNotThrow",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Asserts that the function <code>block</code> does not throw an error. See\n[<code>assert.throws()</code>][] for more details.</p>\n<p>When <code>assert.doesNotThrow()</code> is called, it will immediately call the <code>block</code>\nfunction.</p>\n<p>If an error is thrown and it is the same type as that specified by the <code>error</code>\nparameter, then an <code>AssertionError</code> is thrown. If the error is of a different\ntype, or if the <code>error</code> parameter is undefined, the error is propagated back\nto the caller.</p>\n<p>The following, for instance, will throw the [<code>TypeError</code>][] because there is no\nmatching error type in the assertion:</p>\n<pre><code class=\"lang-js\">assert.doesNotThrow(\n  () =&gt; {\n    throw new TypeError(&#39;Wrong value&#39;);\n  },\n  SyntaxError\n);\n</code></pre>\n<p>However, the following will result in an <code>AssertionError</code> with the message\n&#39;Got unwanted exception (TypeError)..&#39;:</p>\n<pre><code class=\"lang-js\">assert.doesNotThrow(\n  () =&gt; {\n    throw new TypeError(&#39;Wrong value&#39;);\n  },\n  TypeError\n);\n</code></pre>\n<p>If an <code>AssertionError</code> is thrown and a value is provided for the <code>message</code>\nparameter, the value of <code>message</code> will be appended to the <code>AssertionError</code>\nmessage:</p>\n<pre><code class=\"lang-js\">assert.doesNotThrow(\n  () =&gt; {\n    throw new TypeError(&#39;Wrong value&#39;);\n  },\n  TypeError,\n  &#39;Whoops&#39;\n);\n// Throws: AssertionError: Got unwanted exception (TypeError). Whoops\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "block"
                },
                {
                  "name": "error",
                  "optional": true
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.equal(actual, expected[, message])",
          "type": "method",
          "name": "equal",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests shallow, coercive equality between the <code>actual</code> and <code>expected</code> parameters\nusing the equal comparison operator ( <code>==</code> ).</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.equal(1, 1);\n  // OK, 1 == 1\nassert.equal(1, &#39;1&#39;);\n  // OK, 1 == &#39;1&#39;\n\nassert.equal(1, 2);\n  // AssertionError: 1 == 2\nassert.equal({a: {b: 1}}, {a: {b: 1}});\n  //AssertionError: { a: { b: 1 } } == { a: { b: 1 } }\n</code></pre>\n<p>If the values are not equal, an <code>AssertionError</code> is thrown with a <code>message</code>\nproperty set equal to the value of the <code>message</code> parameter. If the <code>message</code>\nparameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.fail(actual, expected, message, operator)",
          "type": "method",
          "name": "fail",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Throws an <code>AssertionError</code>. If <code>message</code> is falsy, the error message is set as\nthe values of <code>actual</code> and <code>expected</code> separated by the provided <code>operator</code>.\nOtherwise, the error message is the value of <code>message</code>.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.fail(1, 2, undefined, &#39;&gt;&#39;);\n  // AssertionError: 1 &gt; 2\n\nassert.fail(1, 2, &#39;whoops&#39;, &#39;&gt;&#39;);\n  // AssertionError: whoops\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message"
                },
                {
                  "name": "operator"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.ifError(value)",
          "type": "method",
          "name": "ifError",
          "meta": {
            "added": [
              "v0.1.97"
            ]
          },
          "desc": "<p>Throws <code>value</code> if <code>value</code> is truthy. This is useful when testing the <code>error</code>\nargument in callbacks.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.ifError(0); // OK\nassert.ifError(1); // Throws 1\nassert.ifError(&#39;error&#39;) // Throws &#39;error&#39;\nassert.ifError(new Error()); // Throws Error\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notDeepEqual(actual, expected[, message])",
          "type": "method",
          "name": "notDeepEqual",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests for any deep inequality. Opposite of [<code>assert.deepEqual()</code>][].</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nconst obj1 = {\n  a : {\n    b : 1\n  }\n};\nconst obj2 = {\n  a : {\n    b : 2\n  }\n};\nconst obj3 = {\n  a : {\n    b : 1\n  }\n}\nconst obj4 = Object.create(obj1);\n\nassert.notDeepEqual(obj1, obj1);\n  // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }\n\nassert.notDeepEqual(obj1, obj2);\n  // OK, obj1 and obj2 are not deeply equal\n\nassert.notDeepEqual(obj1, obj3);\n  // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }\n\nassert.notDeepEqual(obj1, obj4);\n  // OK, obj1 and obj2 are not deeply equal\n</code></pre>\n<p>If the values are deeply equal, an <code>AssertionError</code> is thrown with a <code>message</code>\nproperty set equal to the value of the <code>message</code> parameter. If the <code>message</code>\nparameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notDeepStrictEqual(actual, expected[, message])",
          "type": "method",
          "name": "notDeepStrictEqual",
          "meta": {
            "added": [
              "v1.2.0"
            ]
          },
          "desc": "<p>Tests for deep strict inequality. Opposite of [<code>assert.deepStrictEqual()</code>][].</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.notDeepEqual({a:1}, {a:&#39;1&#39;});\n  // AssertionError: { a: 1 } notDeepEqual { a: &#39;1&#39; }\n\nassert.notDeepStrictEqual({a:1}, {a:&#39;1&#39;});\n  // OK\n</code></pre>\n<p>If the values are deeply and strictly equal, an <code>AssertionError</code> is thrown\nwith a <code>message</code> property set equal to the value of the <code>message</code> parameter. If\nthe <code>message</code> parameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notEqual(actual, expected[, message])",
          "type": "method",
          "name": "notEqual",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests shallow, coercive inequality with the not equal comparison operator\n( <code>!=</code> ).</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.notEqual(1, 2);\n  // OK\n\nassert.notEqual(1, 1);\n  // AssertionError: 1 != 1\n\nassert.notEqual(1, &#39;1&#39;);\n  // AssertionError: 1 != &#39;1&#39;\n</code></pre>\n<p>If the values are equal, an <code>AssertionError</code> is thrown with a <code>message</code>\nproperty set equal to the value of the <code>message</code> parameter. If the <code>message</code>\nparameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notStrictEqual(actual, expected[, message])",
          "type": "method",
          "name": "notStrictEqual",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests strict inequality as determined by the strict not equal operator\n( <code>!==</code> ).</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.notStrictEqual(1, 2);\n  // OK\n\nassert.notStrictEqual(1, 1);\n  // AssertionError: 1 != 1\n\nassert.notStrictEqual(1, &#39;1&#39;);\n  // OK\n</code></pre>\n<p>If the values are strictly equal, an <code>AssertionError</code> is thrown with a\n<code>message</code> property set equal to the value of the <code>message</code> parameter. If the\n<code>message</code> parameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.ok(value[, message])",
          "type": "method",
          "name": "ok",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests if <code>value</code> is truthy. It is equivalent to\n<code>assert.equal(!!value, true, message)</code>.</p>\n<p>If <code>value</code> is not truthy, an <code>AssertionError</code> is thrown with a <code>message</code>\nproperty set equal to the value of the <code>message</code> parameter. If the <code>message</code>\nparameter is <code>undefined</code>, a default error message is assigned.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.ok(true);  // OK\nassert.ok(1);     // OK\nassert.ok(false);\n  // throws &quot;AssertionError: false == true&quot;\nassert.ok(0);\n  // throws &quot;AssertionError: 0 == true&quot;\nassert.ok(false, &#39;it\\&#39;s false&#39;);\n  // throws &quot;AssertionError: it&#39;s false&quot;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.strictEqual(actual, expected[, message])",
          "type": "method",
          "name": "strictEqual",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Tests strict equality as determined by the strict equality operator ( <code>===</code> ).</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\n\nassert.strictEqual(1, 2);\n  // AssertionError: 1 === 2\n\nassert.strictEqual(1, 1);\n  // OK\n\nassert.strictEqual(1, &#39;1&#39;);\n  // AssertionError: 1 === &#39;1&#39;\n</code></pre>\n<p>If the values are not strictly equal, an <code>AssertionError</code> is thrown with a\n<code>message</code> property set equal to the value of the <code>message</code> parameter. If the\n<code>message</code> parameter is undefined, a default error message is assigned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.throws(block[, error][, message])",
          "type": "method",
          "name": "throws",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Expects the function <code>block</code> to throw an error.</p>\n<p>If specified, <code>error</code> can be a constructor, [<code>RegExp</code>][], or validation\nfunction.</p>\n<p>If specified, <code>message</code> will be the message provided by the <code>AssertionError</code> if\nthe block fails to throw.</p>\n<p>Validate instanceof using constructor:</p>\n<pre><code class=\"lang-js\">assert.throws(\n  () =&gt; {\n    throw new Error(&#39;Wrong value&#39;);\n  },\n  Error\n);\n</code></pre>\n<p>Validate error message using [<code>RegExp</code>][]:</p>\n<pre><code class=\"lang-js\">assert.throws(\n  () =&gt; {\n    throw new Error(&#39;Wrong value&#39;);\n  },\n  /value/\n);\n</code></pre>\n<p>Custom error validation:</p>\n<pre><code class=\"lang-js\">assert.throws(\n  () =&gt; {\n    throw new Error(&#39;Wrong value&#39;);\n  },\n  function(err) {\n    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {\n      return true;\n    }\n  },\n  &#39;unexpected error&#39;\n);\n</code></pre>\n<p>Note that <code>error</code> can not be a string. If a string is provided as the second\nargument, then <code>error</code> is assumed to be omitted and the string will be used for\n<code>message</code> instead. This can lead to easy-to-miss mistakes:</p>\n<pre><code class=\"lang-js\">// THIS IS A MISTAKE! DO NOT DO THIS!\nassert.throws(myFunction, &#39;missing foo&#39;, &#39;did not throw with expected message&#39;);\n\n// Do this instead.\nassert.throws(myFunction, /missing foo/, &#39;did not throw with expected message&#39;);\n</code></pre>\n<!-- [end-include:assert.md] -->\n<!-- [start-include:buffer.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "block"
                },
                {
                  "name": "error",
                  "optional": true
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Assert"
    },
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Prior to the introduction of <code>TypedArray</code> in ECMAScript 2015 (ES6), the\nJavaScript language had no mechanism for reading or manipulating streams\nof binary data. The <code>Buffer</code> class was introduced as part of the Node.js\nAPI to make it possible to interact with octet streams in the context of things\nlike TCP streams and file system operations.</p>\n<p>Now that <code>TypedArray</code> has been added in ES6, the <code>Buffer</code> class implements the\n<code>Uint8Array</code> API in a manner that is more optimized and suitable for Node.js&#39;\nuse cases.</p>\n<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but\ncorrespond to fixed-sized, raw memory allocations outside the V8 heap.\nThe size of the <code>Buffer</code> is established when it is created and cannot be\nresized.</p>\n<p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one\nwould need to ever use <code>require(&#39;buffer&#39;).Buffer</code>.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(10);\n  // creates a buffer of length 10\n  // This is the same as Buffer.allocUnsafe(10), and the returned\n  // Buffer instance might contain old data that needs to be\n  // overwritten using either fill() or write().\n\nconst buf2 = new Buffer([1,2,3]);\n  // creates a buffer containing [01, 02, 03]\n  // This is the same as Buffer.from([1,2,3]).\n\nconst buf3 = new Buffer(&#39;test&#39;);\n  // creates a buffer containing ASCII bytes [74, 65, 73, 74]\n  // This is the same as Buffer.from(&#39;test&#39;).\n\nconst buf4 = new Buffer(&#39;tÃ©st&#39;, &#39;utf8&#39;);\n  // creates a buffer containing UTF8 bytes [74, c3, a9, 73, 74]\n  // This is the same as Buffer.from(&#39;tÃ©st&#39;, &#39;utf8&#39;).\n\nconst buf5 = Buffer.alloc(10);\n  // Creates a zero-filled Buffer of length 10.\n\nconst buf6 = Buffer.alloc(10, 1);\n  // Creates a Buffer of length 10, filled with 0x01.\n\nconst buf7 = Buffer.allocUnsafe(10);\n  // Creates an uninitialized buffer of length 10.\n  // This is faster than calling Buffer.alloc() but the returned\n  // Buffer instance might contain old data that needs to be\n  // overwritten using either fill() or write().\n\nconst buf8 = Buffer.from([1,2,3]);\n  // Creates a Buffer containing [01, 02, 03].\n\nconst buf9 = Buffer.from(&#39;test&#39;);\n  // Creates a Buffer containing ASCII bytes [74, 65, 73, 74].\n\nconst buf8 = Buffer.from(&#39;tÃ©st&#39;, &#39;utf8&#39;);\n  // Creates a Buffer containing UTF8 bytes [74, c3, a9, 73, 74].\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`",
          "name": "`buffer.from()`,_`buffer.alloc()`,_and_`buffer.allocunsafe()`",
          "desc": "<p>Historically, <code>Buffer</code> instances have been created using the <code>Buffer</code>\nconstructor function, which allocates the returned <code>Buffer</code>\ndifferently based on what arguments are provided:</p>\n<ul>\n<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>),\nallocates a new <code>Buffer</code> object of the specified size. The memory allocated\nfor such <code>Buffer</code> instances is <em>not</em> initialized and <em>can contain sensitive\ndata</em>. Such <code>Buffer</code> objects <em>must</em> be initialized <em>manually</em> by using either\n[<code>buf.fill(0)</code>][] or by writing to the <code>Buffer</code> completely. While this\nbehavior is <em>intentional</em> to improve performance, development experience has\ndemonstrated that a more explicit distinction is required between creating a\nfast-but-uninitialized <code>Buffer</code> versus creating a slower-but-safer <code>Buffer</code>.</li>\n<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the\npassed object&#39;s data into the <code>Buffer</code>.</li>\n<li>Passing an <code>ArrayBuffer</code> returns a <code>Buffer</code> that shares allocated memory with\nthe given <code>ArrayBuffer</code>.</li>\n</ul>\n<p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type\nof value passed as the first argument, applications that do not properly\nvalidate the input arguments passed to <code>new Buffer()</code>, or that fail to\nappropriately initialize newly allocated <code>Buffer</code> content, can inadvertently\nintroduce security and reliability issues into their code.</p>\n<p>To make the creation of <code>Buffer</code> objects more reliable and less error prone,\nnew <code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code> methods have\nbeen introduced as an alternative means of creating <code>Buffer</code> instances.</p>\n<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors\nto one of these new APIs.</em></p>\n<ul>\n<li>[<code>Buffer.from(array)</code>][buffer_from_array] returns a new <code>Buffer</code> containing\na <em>copy</em> of the provided octets.</li>\n<li>[<code>Buffer.from(arrayBuffer)</code>][buffer_from_arraybuf] returns a new <code>Buffer</code>\nthat <em>shares</em> the same allocated memory as the given <code>ArrayBuffer</code>.</li>\n<li>[<code>Buffer.from(buffer)</code>][buffer_from_buffer] returns a new <code>Buffer</code>\ncontaining a <em>copy</em> of the contents of the given <code>Buffer</code>.</li>\n<li>[<code>Buffer.from(str[, encoding])</code>][buffer_from_string] returns a new <code>Buffer</code>\ncontaining a <em>copy</em> of the provided string.</li>\n<li>[<code>Buffer.alloc(size[, fill[, encoding]])</code>][buffer_alloc] returns a &quot;filled&quot;\n<code>Buffer</code> instance of the specified size. This method can be significantly\nslower than [<code>Buffer.allocUnsafe(size)</code>][buffer_allocunsafe] but ensures\nthat newly created <code>Buffer</code> instances never contain old and potentially\nsensitive data.</li>\n<li>[<code>Buffer.allocUnsafe(size)</code>][buffer_allocunsafe] and\n[<code>Buffer.allocUnsafeSlow(size)</code>][buffer_allocunsafeslow] each return a\nnew <code>Buffer</code> of the specified <code>size</code> whose content <em>must</em> be initialized\nusing either [<code>buf.fill(0)</code>][] or written to completely.</li>\n</ul>\n<p><code>Buffer</code> instances returned by <code>Buffer.allocUnsafe(size)</code> <em>may</em> be allocated\noff a shared internal memory pool if <code>size</code> is less than or equal to half\n<code>Buffer.poolSize</code>. Instances returned by <code>Buffer.allocUnsafeSlow(size)</code> <em>never</em>\nuse the shared internal memory pool.</p>\n",
          "modules": [
            {
              "textRaw": "What makes `Buffer.allocUnsafe(size)` and `Buffer.allocUnsafeSlow(size)` \"unsafe\"?",
              "name": "what_makes_`buffer.allocunsafe(size)`_and_`buffer.allocunsafeslow(size)`_\"unsafe\"?",
              "desc": "<p>When calling <code>Buffer.allocUnsafe()</code> (and <code>Buffer.allocUnsafeSlow()</code>), the\nsegment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While\nthis design makes the allocation of memory quite fast, the allocated segment of\nmemory might contain old data that is potentially sensitive. Using a <code>Buffer</code>\ncreated by <code>Buffer.allocUnsafe()</code> without <em>completely</em> overwriting the memory\ncan allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>\n<p>While there are clear performance advantages to using <code>Buffer.allocUnsafe()</code>,\nextra care <em>must</em> be taken in order to avoid introducing security\nvulnerabilities into an application.</p>\n",
              "type": "module",
              "displayName": "What makes `Buffer.allocUnsafe(size)` and `Buffer.allocUnsafeSlow(size)` \"unsafe\"?"
            }
          ],
          "type": "module",
          "displayName": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`"
        },
        {
          "textRaw": "Buffers and Character Encodings",
          "name": "buffers_and_character_encodings",
          "desc": "<p>Buffers are commonly used to represent sequences of encoded characters\nsuch as UTF8, UCS2, Base64 or even Hex-encoded data. It is possible to\nconvert back and forth between Buffers and ordinary JavaScript string objects\nby using an explicit encoding method.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;hello world&#39;, &#39;ascii&#39;);\nconsole.log(buf.toString(&#39;hex&#39;));\n  // prints: 68656c6c6f20776f726c64\nconsole.log(buf.toString(&#39;base64&#39;));\n  // prints: aGVsbG8gd29ybGQ=\n</code></pre>\n<p>The character encodings currently supported by Node.js include:</p>\n<ul>\n<li><p><code>&#39;ascii&#39;</code> - for 7-bit ASCII data only.  This encoding method is very fast and\nwill strip the high bit if set.</p>\n</li>\n<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other\ndocument formats use UTF-8.</p>\n</li>\n<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.\nSurrogate pairs (U+10000 to U+10FFFF) are supported.</p>\n</li>\n<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>\n</li>\n<li><p><code>&#39;base64&#39;</code> - Base64 string encoding. When creating a buffer from a string,\nthis encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as\nspecified in [RFC 4648, Section 5].</p>\n</li>\n<li><p><code>&#39;binary&#39;</code> - A way of encoding the buffer into a one-byte (<code>latin-1</code>)\nencoded string. The string <code>&#39;latin-1&#39;</code> is not supported. Instead, pass\n<code>&#39;binary&#39;</code> to use <code>&#39;latin-1&#39;</code> encoding.</p>\n</li>\n<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>\n</li>\n</ul>\n",
          "type": "module",
          "displayName": "Buffers and Character Encodings"
        },
        {
          "textRaw": "Buffers and TypedArray",
          "name": "buffers_and_typedarray",
          "desc": "<p>Buffers are also <code>Uint8Array</code> TypedArray instances. However, there are subtle\nincompatibilities with the TypedArray specification in ECMAScript 2015. For\ninstance, while <code>ArrayBuffer#slice()</code> creates a copy of the slice,\nthe implementation of [<code>Buffer#slice()</code>][<code>buf.slice()</code>] creates a view over the\nexisting Buffer without copying, making <code>Buffer#slice()</code> far more efficient.</p>\n<p>It is also possible to create new TypedArray instances from a <code>Buffer</code> with the\nfollowing caveats:</p>\n<ol>\n<li><p>The Buffer instances&#39;s memory is copied to the TypedArray, not shared.</p>\n</li>\n<li><p>The Buffer&#39;s memory is interpreted as an array of distinct elements, and not\nas a byte array of the target type. That is,\n<code>new Uint32Array(new Buffer([1,2,3,4]))</code> creates a 4-element <code>Uint32Array</code>\nwith elements <code>[1,2,3,4]</code>, not a <code>Uint32Array</code> with a single element\n<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>\n</li>\n</ol>\n<p>It is possible to create a new Buffer that shares the same allocated memory as\na TypedArray instance by using the TypeArray objects <code>.buffer</code> property:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf1 = new Buffer(arr); // copies the buffer\nconst buf2 = new Buffer(arr.buffer); // shares the memory with arr;\n\nconsole.log(buf1);\n  // Prints: &lt;Buffer 88 a0&gt;, copied buffer has only two elements\nconsole.log(buf2);\n  // Prints: &lt;Buffer 88 13 a0 0f&gt;\n\narr[1] = 6000;\nconsole.log(buf1);\n  // Prints: &lt;Buffer 88 a0&gt;\nconsole.log(buf2);\n  // Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n<p>Note that when creating a Buffer using the TypeArray&#39;s <code>.buffer</code>, it is not\ncurrently possible to use only a portion of the underlying <code>ArrayBuffer</code>. To\ncreate a Buffer that uses only a part of the <code>ArrayBuffer</code>, use the\n[<code>buf.slice()</code>][] function after the Buffer is created:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(20);\nconst buf = new Buffer(arr.buffer).slice(0, 16);\nconsole.log(buf.length);\n  // Prints: 16\n</code></pre>\n<p>The <code>Buffer.from()</code> and [<code>TypedArray.from()</code>][] (e.g.<code>Uint8Array.from()</code>) have\ndifferent signatures and implementations. Specifically, the TypedArray variants\naccept a second argument that is a mapping function that is invoked on every\nelement of the typed array:</p>\n<ul>\n<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>\n</ul>\n<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping\nfunction:</p>\n<ul>\n<li>[<code>Buffer.from(array)</code>][buffer_from_array]</li>\n<li>[<code>Buffer.from(buffer)</code>][buffer_from_buffer]</li>\n<li>[<code>Buffer.from(arrayBuffer)</code>][buffer_from_arraybuf]</li>\n<li>[<code>Buffer.from(str[, encoding])</code>][buffer_from_string]</li>\n</ul>\n",
          "type": "module",
          "displayName": "Buffers and TypedArray"
        },
        {
          "textRaw": "Buffers and ES6 iteration",
          "name": "buffers_and_es6_iteration",
          "desc": "<p>Buffers can be iterated over using the ECMAScript 2015 (ES6) <code>for..of</code> syntax:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1, 2, 3]);\n\nfor (var b of buf)\n  console.log(b)\n\n// Prints:\n//   1\n//   2\n//   3\n</code></pre>\n<p>Additionally, the [<code>buf.values()</code>][], [<code>buf.keys()</code>][], and\n[<code>buf.entries()</code>][] methods can be used to create iterators.</p>\n",
          "type": "module",
          "displayName": "Buffers and ES6 iteration"
        },
        {
          "textRaw": "The `--zero-fill-buffers` command line option",
          "name": "the_`--zero-fill-buffers`_command_line_option",
          "desc": "<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to\nforce all newly allocated <code>Buffer</code> and <code>SlowBuffer</code> instances created using\neither <code>new Buffer(size)</code> and <code>new SlowBuffer(size)</code> to be <em>automatically\nzero-filled</em> upon creation. Use of this flag <em>changes the default behavior</em> of\nthese methods and <em>can have a significant impact</em> on performance. Use of the\n<code>--zero-fill-buffers</code> option is recommended only when absolutely necessary to\nenforce that newly allocated <code>Buffer</code> instances cannot contain potentially\nsensitive data.</p>\n<pre><code>$ node --zero-fill-buffers\n&gt; Buffer(5);\n&lt;Buffer 00 00 00 00 00&gt;\n</code></pre>",
          "type": "module",
          "displayName": "The `--zero-fill-buffers` command line option"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The Buffer class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.</p>\n",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.alloc(size[, fill[, encoding]])",
              "type": "classMethod",
              "name": "alloc",
              "meta": {
                "added": [
                  "v4.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Number} ",
                      "name": "size",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`fill` {Value} Default: `undefined` ",
                      "name": "fill",
                      "type": "Value",
                      "desc": "Default: `undefined`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} Default: `utf8` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "Default: `utf8`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "fill",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the\n<code>Buffer</code> will be <em>zero-filled</em>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5);\nconsole.log(buf);\n  // &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n<p>The <code>size</code> must be less than or equal to the value of\n<code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is\n<code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is thrown. If a <code>size</code> less than 0\nis specified, a zero-length <code>Buffer</code> will be created.</p>\n<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling\n<code>buf.fill(fill)</code>. See [<code>buf.fill()</code>][] for more information.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5, &#39;a&#39;);\nconsole.log(buf);\n  // &lt;Buffer 61 61 61 61 61&gt;\n</code></pre>\n<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be\ninitialized by calling <code>buf.fill(fill, encoding)</code>. For example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);\nconsole.log(buf);\n  // &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;\n</code></pre>\n<p>Calling <code>Buffer.alloc(size)</code> can be significantly slower than the alternative\n<code>Buffer.allocUnsafe(size)</code> but ensures that the newly created <code>Buffer</code> instance\ncontents will <em>never contain sensitive data</em>.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafe(size)",
              "type": "classMethod",
              "name": "allocUnsafe",
              "meta": {
                "added": [
                  "v4.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Number} ",
                      "name": "size",
                      "type": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <em>non-zero-filled</em> <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must\nbe less than or equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit\narchitectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is\nthrown. If a <code>size</code> less than 0 is specified, a zero-length <code>Buffer</code> will be\ncreated.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use [<code>buf.fill(0)</code>][] to initialize such\n<code>Buffer</code> instances to zeroes.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(5);\nconsole.log(buf);\n  // &lt;Buffer 78 e0 82 02 01&gt;\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of\nsize <code>Buffer.poolSize</code> that is used as a pool for the fast allocation of new\n<code>Buffer</code> instances created using <code>Buffer.allocUnsafe(size)</code> (and the\n<code>new Buffer(size)</code> constructor) only when <code>size</code> is less than or equal to\n<code>Buffer.poolSize &gt;&gt; 1</code> (floor of <code>Buffer.poolSize</code> divided by two). The default\nvalue of <code>Buffer.poolSize</code> is <code>8192</code> but can be modified.</p>\n<p>Use of this pre-allocated internal memory pool is a key difference between\ncalling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.\nSpecifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal Buffer\npool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal\nBuffer pool if <code>size</code> is less than or equal to half <code>Buffer.poolSize</code>. The\ndifference is subtle but can be important when an application requires the\nadditional performance that <code>Buffer.allocUnsafe(size)</code> provides.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafeSlow(size)",
              "type": "classMethod",
              "name": "allocUnsafeSlow",
              "meta": {
                "added": [
                  "v4.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Number} ",
                      "name": "size",
                      "type": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <em>non-zero-filled</em> and non-pooled <code>Buffer</code> of <code>size</code> bytes.  The\n<code>size</code> must be less than or equal to the value of\n<code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is\n<code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is thrown. If a <code>size</code> less than 0\nis specified, a zero-length <code>Buffer</code> will be created.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use [<code>buf.fill(0)</code>][] to initialize such\n<code>Buffer</code> instances to zeroes.</p>\n<p>When using <code>Buffer.allocUnsafe()</code> to allocate new <code>Buffer</code> instances,\nallocations under 4KB are, by default, sliced from a single pre-allocated\n<code>Buffer</code>. This allows applications to avoid the garbage collection overhead of\ncreating many individually allocated Buffers. This approach improves both\nperformance and memory usage by eliminating the need to track and cleanup as\nmany <code>Persistent</code> objects.</p>\n<p>However, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled Buffer instance using <code>Buffer.allocUnsafeSlow()</code> then\ncopy out the relevant bits.</p>\n<pre><code class=\"lang-js\">// need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n  // allocate for retained data\n  const sb = Buffer.allocUnsafeSlow(10);\n  // copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort <em>after</em>\na developer has observed undue memory retention in their applications.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string[, encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`string` {String} ",
                      "name": "string",
                      "type": "String"
                    },
                    {
                      "textRaw": "`encoding` {String} Default: `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "Default: `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns the actual byte length of a string. This is not the same as\n[<code>String.prototype.length</code>][] since that returns the number of <em>characters</em> in\na string.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const str = &#39;\\u00bd + \\u00bc = \\u00be&#39;;\n\nconsole.log(`${str}: ${str.length} characters, ` +\n            `${Buffer.byteLength(str, &#39;utf8&#39;)} bytes`);\n\n// Â½ + Â¼ = Â¾: 9 characters, 12 bytes\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.compare(buf1, buf2)",
              "type": "classMethod",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer} ",
                      "name": "buf1",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`buf2` {Buffer} ",
                      "name": "buf2",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf1"
                    },
                    {
                      "name": "buf2"
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of\nBuffers. This is equivalent is calling [<code>buf1.compare(buf2)</code>][].</p>\n<pre><code class=\"lang-js\">const arr = [Buffer(&#39;1234&#39;), Buffer(&#39;0123&#39;)];\narr.sort(Buffer.compare);\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list[, totalLength])",
              "type": "classMethod",
              "name": "concat",
              "meta": {
                "added": [
                  "v0.7.11"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`list` {Array} List of Buffer objects to concat ",
                      "name": "list",
                      "type": "Array",
                      "desc": "List of Buffer objects to concat"
                    },
                    {
                      "textRaw": "`totalLength` {Number} Total length of the Buffers in the list when concatenated ",
                      "name": "totalLength",
                      "type": "Number",
                      "desc": "Total length of the Buffers in the list when concatenated",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "list"
                    },
                    {
                      "name": "totalLength",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new Buffer which is the result of concatenating all the Buffers in\nthe <code>list</code> together.</p>\n<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length\nBuffer is returned.</p>\n<p>If <code>totalLength</code> is not provided, it is calculated from the Buffers in the\n<code>list</code>. This, however, adds an additional loop to the function, so it is faster\nto provide the length explicitly.</p>\n<p>Example: build a single Buffer from a list of three Buffers:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(10).fill(0);\nconst buf2 = new Buffer(14).fill(0);\nconst buf3 = new Buffer(18).fill(0);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\nconsole.log(bufA);\nconsole.log(bufA.length);\n\n// 42\n// &lt;Buffer 00 00 00 00 ...&gt;\n// 42\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(array)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v3.0.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`array` {Array} ",
                      "name": "array",
                      "type": "Array"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "array"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);\n  // creates a new Buffer containing ASCII bytes\n  // [&#39;b&#39;,&#39;u&#39;,&#39;f&#39;,&#39;f&#39;,&#39;e&#39;,&#39;r&#39;]\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(arrayBuffer)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v4.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`arrayBuffer` {ArrayBuffer} The `.buffer` property of a `TypedArray` or a `new ArrayBuffer()` ",
                      "name": "arrayBuffer",
                      "type": "ArrayBuffer",
                      "desc": "The `.buffer` property of a `TypedArray` or a `new ArrayBuffer()`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "arrayBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\nTypedArray.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = Buffer.from(arr.buffer); // shares the memory with arr;\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 88 13 a0 0f&gt;\n\n// changing the TypedArray changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <code>ArrayBuffer</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(buffer)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v3.0.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buffer` {Buffer} ",
                      "name": "buffer",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;buffer&#39;);\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n  // &#39;auffer&#39;\nconsole.log(buf2.toString());\n  // &#39;buffer&#39; (copy is not changed)\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(str[, encoding])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v4.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`str` {String} String to encode. ",
                      "name": "str",
                      "type": "String",
                      "desc": "String to encode."
                    },
                    {
                      "textRaw": "`encoding` {String} Encoding to use, Default: `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "Encoding to use, Default: `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "str"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>str</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding.\nIf not provided, <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;this is a tÃ©st&#39;);\nconsole.log(buf1.toString());\n  // prints: this is a tÃ©st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n  // prints: this is a tC)st\n\nconst buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\nconsole.log(buf2.toString());\n  // prints: this is a tÃ©st\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` {Object} ",
                      "name": "obj",
                      "type": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns &#39;true&#39; if <code>obj</code> is a Buffer.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {String} The encoding string to test ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The encoding string to test"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false\notherwise.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "meta": {
                "type": "property",
                "name": [
                  "index"
                ]
              },
              "desc": "<p>The index operator <code>[index]</code> can be used to get and set the octet at position\n<code>index</code> in the Buffer. The values refer to individual bytes, so the legal value\nrange is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>\n<p>Example: copy an ASCII string into a Buffer, one byte at a time:</p>\n<pre><code class=\"lang-js\">const str = &quot;Node.js&quot;;\nconst buf = new Buffer(str.length);\n\nfor (var i = 0; i &lt; str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString(&#39;ascii&#39;));\n  // Prints: Node.js\n</code></pre>\n"
            },
            {
              "textRaw": "`length` {Number} ",
              "type": "Number",
              "name": "length",
              "desc": "<p>Returns the amount of memory allocated for the Buffer in number of bytes. Note\nthat this does not necessarily reflect the amount of usable data within the\nBuffer. For instance, in the example below, a Buffer with 1234 bytes is\nallocated, but only 11 ASCII bytes are written.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(1234);\n\nconsole.log(buf.length);\n  // Prints: 1234\n\nbuf.write(&#39;some string&#39;, 0, &#39;ascii&#39;);\nconsole.log(buf.length);\n  // Prints: 1234\n</code></pre>\n<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>\ncan result in undefined and inconsistent behavior. Applications that wish to\nmodify the length of a Buffer should therefore treat <code>length</code> as read-only and\nuse [<code>buf.slice()</code>][] to create a new Buffer.</p>\n<pre><code class=\"lang-js\">var buf = new Buffer(10);\nbuf.write(&#39;abcdefghj&#39;, 0, &#39;ascii&#39;);\nconsole.log(buf.length);\n  // Prints: 10\nbuf = buf.slice(0,5);\nconsole.log(buf.length);\n  // Prints: 5\n</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "buf.compare(otherBuffer)",
              "type": "method",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} ",
                      "name": "otherBuffer",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Compares two Buffer instances and returns a number indicating whether <code>buf</code>\ncomes before, after, or is the same as the <code>otherBuffer</code> in sort order.\nComparison is based on the actual sequence of bytes in each Buffer.</p>\n<ul>\n<li><code>0</code> is returned if <code>otherBuffer</code> is the same as <code>buf</code></li>\n<li><code>1</code> is returned if <code>otherBuffer</code> should come <em>before</em> <code>buf</code> when sorted.</li>\n<li><code>-1</code> is returned if <code>otherBuffer</code> should come <em>after</em> <code>buf</code> when sorted.</li>\n</ul>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;ABC&#39;);\nconst buf2 = new Buffer(&#39;BCD&#39;);\nconst buf3 = new Buffer(&#39;ABCD&#39;);\n\nconsole.log(buf1.compare(buf1));\n  // Prints: 0\nconsole.log(buf1.compare(buf2));\n  // Prints: -1\nconsole.log(buf1.compare(buf3));\n  // Prints: 1\nconsole.log(buf2.compare(buf1));\n  // Prints: 1\nconsole.log(buf2.compare(buf3));\n  // Prints: 1\n\n[buf1, buf2, buf3].sort(Buffer.compare);\n  // produces sort order [buf1, buf3, buf2]\n</code></pre>\n"
            },
            {
              "textRaw": "buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])",
              "type": "method",
              "name": "copy",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The number of bytes copied. ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The number of bytes copied."
                  },
                  "params": [
                    {
                      "textRaw": "`targetBuffer` {Buffer} Buffer to copy into ",
                      "name": "targetBuffer",
                      "type": "Buffer",
                      "desc": "Buffer to copy into"
                    },
                    {
                      "textRaw": "`targetStart` {Number} Default: 0 ",
                      "name": "targetStart",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {Number} Default: 0 ",
                      "name": "sourceStart",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {Number} Default: `buffer.length` ",
                      "name": "sourceEnd",
                      "type": "Number",
                      "desc": "Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "targetBuffer"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Copies data from a region of this Buffer to a region in the target Buffer even\nif the target memory region overlaps with the source.</p>\n<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19\ninto <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(26);\nconst buf2 = new Buffer(26).fill(&#39;!&#39;);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n}\n\nbuf1.copy(buf2, 8, 16, 20);\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, 25));\n  // Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n</code></pre>\n<p>Example: Build a single Buffer, then copy data from one region to an overlapping\nregion in the same Buffer</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97; // 97 is ASCII a\n}\n\nbuf.copy(buf, 0, 4, 10);\nconsole.log(buf.toString());\n\n// efghijghijklmnopqrstuvwxyz\n</code></pre>\n"
            },
            {
              "textRaw": "buf.entries()",
              "type": "method",
              "name": "entries",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an [iterator][] of <code>[index, byte]</code> pairs from the Buffer\ncontents.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;buffer&#39;);\nfor (var pair of buf.entries()) {\n  console.log(pair);\n}\n// prints:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\n</code></pre>\n"
            },
            {
              "textRaw": "buf.equals(otherBuffer)",
              "type": "method",
              "name": "equals",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} ",
                      "name": "otherBuffer",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a boolean indicating whether <code>this</code> and <code>otherBuffer</code> have exactly the\nsame bytes.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;ABC&#39;);\nconst buf2 = new Buffer(&#39;414243&#39;, &#39;hex&#39;);\nconst buf3 = new Buffer(&#39;ABCD&#39;);\n\nconsole.log(buf1.equals(buf2));\n  // Prints: true\nconsole.log(buf1.equals(buf3));\n  // Prints: false\n</code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value[, offset[, end]])",
              "type": "method",
              "name": "fill",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {String|Number} ",
                      "name": "value",
                      "type": "String|Number"
                    },
                    {
                      "textRaw": "`offset` {Number} Default: 0 ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Number} Default: `buffer.length` ",
                      "name": "end",
                      "type": "Number",
                      "desc": "Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Fills the Buffer with the specified value. If the <code>offset</code> and <code>end</code> are not\ngiven it will fill the entire Buffer. The method returns a reference to the\nBuffer so calls can be chained.</p>\n<pre><code class=\"lang-js\">const b = new Buffer(50).fill(&#39;h&#39;);\nconsole.log(b.toString());\n  // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n</code></pre>\n"
            },
            {
              "textRaw": "buf.indexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "indexOf",
              "meta": {
                "added": [
                  "v1.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {String|Buffer|Number} ",
                      "name": "value",
                      "type": "String|Buffer|Number"
                    },
                    {
                      "textRaw": "`byteOffset` {Number} Default: 0 ",
                      "name": "byteOffset",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} Default: `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "Default: `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Operates similar to [<code>Array#indexOf()</code>][] in that it returns either the\nstarting index position of <code>value</code> in Buffer or <code>-1</code> if the Buffer does not\ncontain <code>value</code>. The <code>value</code> can be a String, Buffer or Number. Strings are by\ndefault interpreted as UTF8. Buffers will use the entire Buffer (to compare a\npartial Buffer use [<code>buf.slice()</code>][]).  Numbers can range from 0 to 255.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;this is a buffer&#39;);\n\nbuf.indexOf(&#39;this&#39;);\n  // returns 0\nbuf.indexOf(&#39;is&#39;);\n  // returns 2\nbuf.indexOf(new Buffer(&#39;a buffer&#39;));\n  // returns 8\nbuf.indexOf(97); // ascii for &#39;a&#39;\n  // returns 8\nbuf.indexOf(new Buffer(&#39;a buffer example&#39;));\n  // returns -1\nbuf.indexOf(new Buffer(&#39;a buffer example&#39;).slice(0,8));\n  // returns 8\n\nconst utf16Buffer = new Buffer(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;ucs2&#39;);\n\nutf16Buffer.indexOf(&#39;\\u03a3&#39;,  0, &#39;ucs2&#39;);\n  // returns 4\nutf16Buffer.indexOf(&#39;\\u03a3&#39;, -4, &#39;ucs2&#39;);\n  // returns 6\n</code></pre>\n"
            },
            {
              "textRaw": "buf.keys()",
              "type": "method",
              "name": "keys",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an [iterator][] of Buffer keys (indices).</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;buffer&#39;);\nfor (var key of buf.keys()) {\n  console.log(key);\n}\n// prints:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from the Buffer at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,2,3,4,5,6,7,8]);\n\nbuf.readDoubleBE();\n  // Returns: 8.20788039913184e-304\nbuf.readDoubleLE();\n  // Returns: 5.447603722011605e-270\nbuf.readDoubleLE(1);\n  // throws RangeError: Index out of range\n\nbuf.readDoubleLE(1, true); // Warning: reads passed end of buffer!\n  // Segmentation fault! don&#39;t do this!\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from the Buffer at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,2,3,4,5,6,7,8]);\n\nbuf.readDoubleBE();\n  // Returns: 8.20788039913184e-304\nbuf.readDoubleLE();\n  // Returns: 5.447603722011605e-270\nbuf.readDoubleLE(1);\n  // throws RangeError: Index out of range\n\nbuf.readDoubleLE(1, true); // Warning: reads passed end of buffer!\n  // Segmentation fault! don&#39;t do this!\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from the Buffer at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,2,3,4]);\n\nbuf.readFloatBE();\n  // Returns: 2.387939260590663e-38\nbuf.readFloatLE();\n  // Returns: 1.539989614439558e-36\nbuf.readFloatLE(1);\n  // throws RangeError: Index out of range\n\nbuf.readFloatLE(1, true); // Warning: reads passed end of buffer!\n  // Segmentation fault! don&#39;t do this!\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from the Buffer at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,2,3,4]);\n\nbuf.readFloatBE();\n  // Returns: 2.387939260590663e-38\nbuf.readFloatLE();\n  // Returns: 1.539989614439558e-36\nbuf.readFloatLE(1);\n  // throws RangeError: Index out of range\n\nbuf.readFloatLE(1, true); // Warning: reads passed end of buffer!\n  // Segmentation fault! don&#39;t do this!\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset[, noAssert])",
              "type": "method",
              "name": "readInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8-bit integer from the Buffer at the specified <code>offset</code>.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,-2,3,4]);\n\nbuf.readInt8(0);\n  // returns 1\nbuf.readInt8(1);\n  // returns -2\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from the Buffer at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,-2,3,4]);\n\nbuf.readInt16BE();\n  // returns 510\nbuf.readInt16LE(1);\n  // returns 1022\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from the Buffer at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,-2,3,4]);\n\nbuf.readInt16BE();\n  // returns 510\nbuf.readInt16LE(1);\n  // returns 1022\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from the Buffer at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,-2,3,4]);\n\nbuf.readInt32BE();\n  // returns 33424132\nbuf.readInt32LE();\n  // returns 67370497\nbuf.readInt32LE(1);\n  // throws RangeError: Index out of range\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from the Buffer at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,-2,3,4]);\n\nbuf.readInt32BE();\n  // returns 33424132\nbuf.readInt32LE();\n  // returns 67370497\nbuf.readInt32LE(1);\n  // throws RangeError: Index out of range\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntBE",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code>\nand interprets the result as a two&#39;s complement signed value. Supports up to 48\nbits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(6);\nbuf.writeUInt16LE(0x90ab, 0);\nbuf.writeUInt32LE(0x12345678, 2);\nbuf.readIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)\n// Returns: &#39;1234567890ab&#39;\n\nbuf.readIntBE(0, 6).toString(16);\n// Returns: -546f87a9cbee\n</code></pre>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n"
            },
            {
              "textRaw": "buf.readIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntLE",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code>\nand interprets the result as a two&#39;s complement signed value. Supports up to 48\nbits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(6);\nbuf.writeUInt16LE(0x90ab, 0);\nbuf.writeUInt32LE(0x12345678, 2);\nbuf.readIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)\n// Returns: &#39;1234567890ab&#39;\n\nbuf.readIntBE(0, 6).toString(16);\n// Returns: -546f87a9cbee\n</code></pre>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset[, noAssert])",
              "type": "method",
              "name": "readUInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8-bit integer from the Buffer at the specified <code>offset</code>.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([1,-2,3,4]);\n\nbuf.readUInt8(0);\n  // returns 1\nbuf.readUInt8(1);\n  // returns 254\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from the Buffer at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian,\n<code>readUInt16LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([0x3, 0x4, 0x23, 0x42]);\n\nbuf.readUInt16BE(0);\n  // Returns: 0x0304\nbuf.readUInt16LE(0);\n  // Returns: 0x0403\nbuf.readUInt16BE(1);\n  // Returns: 0x0423\nbuf.readUInt16LE(1);\n  // Returns: 0x2304\nbuf.readUInt16BE(2);\n  // Returns: 0x2342\nbuf.readUInt16LE(2);\n  // Returns: 0x4223\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from the Buffer at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian,\n<code>readUInt16LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([0x3, 0x4, 0x23, 0x42]);\n\nbuf.readUInt16BE(0);\n  // Returns: 0x0304\nbuf.readUInt16LE(0);\n  // Returns: 0x0403\nbuf.readUInt16BE(1);\n  // Returns: 0x0423\nbuf.readUInt16LE(1);\n  // Returns: 0x2304\nbuf.readUInt16BE(2);\n  // Returns: 0x2342\nbuf.readUInt16LE(2);\n  // Returns: 0x4223\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from the Buffer at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([0x3, 0x4, 0x23, 0x42]);\n\nbuf.readUInt32BE(0);\n  // Returns: 0x03042342\nconsole.log(buf.readUInt32LE(0));\n  // Returns: 0x42230403\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from the Buffer at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([0x3, 0x4, 0x23, 0x42]);\n\nbuf.readUInt32BE(0);\n  // Returns: 0x03042342\nconsole.log(buf.readUInt32LE(0));\n  // Returns: 0x42230403\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readUIntBE",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(6);\nbuf.writeUInt16LE(0x90ab, 0);\nbuf.writeUInt32LE(0x12345678, 2);\nbuf.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)\n// Returns: &#39;1234567890ab&#39;\n\nbuf.readUIntBE(0, 6).toString(16);\n// Returns: ab9078563412\n</code></pre>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n"
            },
            {
              "textRaw": "buf.readUIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readUIntLE",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(6);\nbuf.writeUInt16LE(0x90ab, 0);\nbuf.writeUInt32LE(0x12345678, 2);\nbuf.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)\n// Returns: &#39;1234567890ab&#39;\n\nbuf.readUIntBE(0, 6).toString(16);\n// Returns: ab9078563412\n</code></pre>\n<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the\n<code>offset</code> to be beyond the end of the Buffer.</p>\n"
            },
            {
              "textRaw": "buf.slice([start[, end]])",
              "type": "method",
              "name": "slice",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`start` {Number} Default: 0 ",
                      "name": "start",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Number} Default: `buffer.length` ",
                      "name": "end",
                      "type": "Number",
                      "desc": "Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new Buffer that references the same memory as the original, but\noffset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n<p><strong>Note that modifying the new Buffer slice will modify the memory in the\noriginal Buffer because the allocated memory of the two objects overlap.</strong></p>\n<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one\nbyte from the original Buffer.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n}\n\nconst buf2 = buf1.slice(0, 3);\nbuf2.toString(&#39;ascii&#39;, 0, buf2.length);\n  // Returns: &#39;abc&#39;\nbuf1[0] = 33;\nbuf2.toString(&#39;ascii&#39;, 0, buf2.length);\n  // Returns : &#39;!bc&#39;\n</code></pre>\n<p>Specifying negative indexes causes the slice to be generated relative to the\nend of the Buffer rather than the beginning.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;buffer&#39;);\n\nbuf.slice(-6, -1).toString();\n  // Returns &#39;buffe&#39;, equivalent to buf.slice(0, 5)\nbuf.slice(-6, -2).toString();\n  // Returns &#39;buff&#39;, equivalent to buf.slice(0, 4)\nbuf.slice(-5, -2).toString();\n  // Returns &#39;uff&#39;, equivalent to buf.slice(1, 4)\n</code></pre>\n"
            },
            {
              "textRaw": "buf.toString([encoding[, start[, end]]])",
              "type": "method",
              "name": "toString",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {String} ",
                    "name": "return",
                    "type": "String"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {String} Default: `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "Default: `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` {Number} Default: 0 ",
                      "name": "start",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Number} Default: `buffer.length` ",
                      "name": "end",
                      "type": "Number",
                      "desc": "Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes and returns a string from the Buffer data using the specified\ncharacter set <code>encoding</code>.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(26);\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97; // 97 is ASCII a\n}\nbuf.toString(&#39;ascii&#39;);\n  // Returns: &#39;abcdefghijklmnopqrstuvwxyz&#39;\nbuf.toString(&#39;ascii&#39;,0,5);\n  // Returns: &#39;abcde&#39;\nbuf.toString(&#39;utf8&#39;,0,5);\n  // Returns: &#39;abcde&#39;\nbuf.toString(undefined,0,5);\n  // Returns: &#39;abcde&#39;, encoding defaults to &#39;utf8&#39;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "meta": {
                "added": [
                  "v0.9.2"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Object} ",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Returns a JSON representation of the Buffer instance.  [<code>JSON.stringify()</code>][]\nimplicitly calls this function when stringifying a Buffer instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;test&#39;);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: &#39;{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[116,101,115,116]}&#39;\n\nconst copy = JSON.parse(json, (key, value) =&gt; {\n    return value &amp;&amp; value.type === &#39;Buffer&#39;\n      ? new Buffer(value.data)\n      : value;\n  });\n\nconsole.log(copy.toString());\n// Prints: &#39;test&#39;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.values()",
              "type": "method",
              "name": "values",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an [iterator][] for Buffer values (bytes). This function is\ncalled automatically when the Buffer is used in a <code>for..of</code> statement.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(&#39;buffer&#39;);\nfor (var value of buf.values()) {\n  console.log(value);\n}\n// prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n\nfor (var value of buf) {\n  console.log(value);\n}\n// prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n</code></pre>\n"
            },
            {
              "textRaw": "buf.write(string[, offset[, length]][, encoding])",
              "type": "method",
              "name": "write",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} Numbers of bytes written ",
                    "name": "return",
                    "type": "Number",
                    "desc": "Numbers of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`string` {String} Bytes to be written to buffer ",
                      "name": "string",
                      "type": "String",
                      "desc": "Bytes to be written to buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} Default: 0 ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {Number} Default: `buffer.length - offset` ",
                      "name": "length",
                      "type": "Number",
                      "desc": "Default: `buffer.length - offset`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} Default: `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "Default: `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>string</code> to the Buffer at <code>offset</code> using the given <code>encoding</code>.\nThe <code>length</code> parameter is the number of bytes to write. If the Buffer did not\ncontain enough space to fit the entire string, only a partial amount of the\nstring will be written however, it will not write only partially encoded\ncharacters.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(256);\nconst len = buf.write(&#39;\\u00bd + \\u00bc = \\u00be&#39;, 0);\nconsole.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);\n  // Prints: 12 bytes: Â½ + Â¼ = Â¾\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). The <code>value</code> argument <em>should</em> be a valid 64-bit double. Behavior is\nnot defined when <code>value</code> is anything other than a 64-bit double.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). The <code>value</code> argument <em>should</em> be a valid 64-bit double. Behavior is\nnot defined when <code>value</code> is anything other than a 64-bit double.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). Behavior is not defined when <code>value</code> is anything other than a 32-bit\nfloat.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 4f 4a fe bb&gt;\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer bb fe 4a 4f&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). Behavior is not defined when <code>value</code> is anything other than a 32-bit\nfloat.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 4f 4a fe bb&gt;\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer bb fe 4a 4f&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code>. The <code>value</code> should be a\nvalid signed 8-bit integer.  Behavior is not defined when <code>value</code> is anything\nother than a signed 8-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(2);\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\nconsole.log(buf);\n  // Prints: &lt;Buffer 02 fe&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). The <code>value</code> should be a valid signed 16-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeInt16BE(0x0102,0);\nbuf.writeInt16LE(0x0304,2);\nconsole.log(buf);\n  // Prints: &lt;Buffer 01 02 04 03&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). The <code>value</code> should be a valid signed 16-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeInt16BE(0x0102,0);\nbuf.writeInt16LE(0x0304,2);\nconsole.log(buf);\n  // Prints: &lt;Buffer 01 02 04 03&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). The <code>value</code> should be a valid signed 32-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(8);\nbuf.writeInt32BE(0x01020304,0);\nbuf.writeInt32LE(0x05060708,4);\nconsole.log(buf);\n  // Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). The <code>value</code> should be a valid signed 32-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(8);\nbuf.writeInt32BE(0x01020304,0);\nbuf.writeInt32LE(0x05060708,4);\nconsole.log(buf);\n  // Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntBE",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>.\nSupports up to 48 bits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(6);\nbuf1.writeUIntBE(0x1234567890ab, 0, 6);\nconsole.log(buf1);\n  // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n\nconst buf2 = new Buffer(6);\nbuf2.writeUIntLE(0x1234567890ab, 0, 6);\nconsole.log(buf2);\n  // Prints: &lt;Buffer ab 90 78 56 34 12&gt;\n</code></pre>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Behavior is not defined when <code>value</code> is anything other than an integer.</p>\n"
            },
            {
              "textRaw": "buf.writeIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntLE",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>.\nSupports up to 48 bits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(6);\nbuf1.writeUIntBE(0x1234567890ab, 0, 6);\nconsole.log(buf1);\n  // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n\nconst buf2 = new Buffer(6);\nbuf2.writeUIntLE(0x1234567890ab, 0, 6);\nconsole.log(buf2);\n  // Prints: &lt;Buffer ab 90 78 56 34 12&gt;\n</code></pre>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Behavior is not defined when <code>value</code> is anything other than an integer.</p>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code>. The <code>value</code> should be a\nvalid unsigned 8-bit integer.  Behavior is not defined when <code>value</code> is anything\nother than an unsigned 8-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 03 04 23 42&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). The <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer de ad be ef&gt;\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer ad de ef be&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). The <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer de ad be ef&gt;\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer ad de ef be&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). The <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer fe ed fa ce&gt;\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer ce fa ed fe&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). The <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nnot defined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer fe ed fa ce&gt;\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n  // Prints: &lt;Buffer ce fa ed fe&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeUIntBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>.\nSupports up to 48 bits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(6);\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\nconsole.log(buf);\n  // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n</code></pre>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Behavior is not defined when <code>value</code> is anything other than an unsigned integer.</p>\n"
            },
            {
              "textRaw": "buf.writeUIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeUIntLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} The offset plus the number of written bytes ",
                    "name": "return",
                    "type": "Number",
                    "desc": "The offset plus the number of written bytes"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to Buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to Buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>.\nSupports up to 48 bits of accuracy. For example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(6);\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\nconsole.log(buf);\n  // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n</code></pre>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the Buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness.</p>\n<p>Behavior is not defined when <code>value</code> is anything other than an unsigned integer.</p>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`array` {Array} ",
                  "name": "array",
                  "type": "Array"
                }
              ],
              "desc": "<p>Allocates a new Buffer using an <code>array</code> of octets.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([0x62,0x75,0x66,0x66,0x65,0x72]);\n  // creates a new Buffer containing ASCII bytes\n  // [&#39;b&#39;,&#39;u&#39;,&#39;f&#39;,&#39;f&#39;,&#39;e&#39;,&#39;r&#39;]\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<p>Allocates a new Buffer using an <code>array</code> of octets.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer([0x62,0x75,0x66,0x66,0x65,0x72]);\n  // creates a new Buffer containing ASCII bytes\n  // [&#39;b&#39;,&#39;u&#39;,&#39;f&#39;,&#39;f&#39;,&#39;e&#39;,&#39;r&#39;]\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer} ",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n  // &#39;auffer&#39;\nconsole.log(buf2.toString());\n  // &#39;buffer&#39; (copy is not changed)\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "buffer"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n  // &#39;auffer&#39;\nconsole.log(buf2.toString());\n  // &#39;buffer&#39; (copy is not changed)\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`arrayBuffer` - The `.buffer` property of a `TypedArray` or a `new ArrayBuffer()` ",
                  "name": "arrayBuffer",
                  "desc": "The `.buffer` property of a `TypedArray` or a `new ArrayBuffer()`"
                }
              ],
              "desc": "<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance,\nthe newly created Buffer will share the same allocated memory as the\nTypedArray.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = new Buffer(arr.buffer); // shares the memory with arr;\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 88 13 a0 0f&gt;\n\n// changing the TypdArray changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "arrayBuffer"
                }
              ],
              "desc": "<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance,\nthe newly created Buffer will share the same allocated memory as the\nTypedArray.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = new Buffer(arr.buffer); // shares the memory with arr;\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 88 13 a0 0f&gt;\n\n// changing the TypdArray changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n  // Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`size` {Number} ",
                  "name": "size",
                  "type": "Number"
                }
              ],
              "desc": "<p>Allocates a new Buffer of <code>size</code> bytes.  The <code>size</code> must be less than\nor equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit\narchitectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is\nthrown. If a <code>size</code> less than 0 is specified, a zero-length Buffer will be\ncreated.</p>\n<p>Unlike <code>ArrayBuffers</code>, the underlying memory for Buffer instances created in\nthis way is not initialized. The contents of a newly created <code>Buffer</code> are\nunknown and could contain sensitive data. Use [<code>buf.fill(0)</code>][] to initialize a\nBuffer to zeroes.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(5);\nconsole.log(buf);\n  // &lt;Buffer 78 e0 82 02 01&gt;\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Allocates a new Buffer of <code>size</code> bytes.  The <code>size</code> must be less than\nor equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit\narchitectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is\nthrown. If a <code>size</code> less than 0 is specified, a zero-length Buffer will be\ncreated.</p>\n<p>Unlike <code>ArrayBuffers</code>, the underlying memory for Buffer instances created in\nthis way is not initialized. The contents of a newly created <code>Buffer</code> are\nunknown and could contain sensitive data. Use [<code>buf.fill(0)</code>][] to initialize a\nBuffer to zeroes.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(5);\nconsole.log(buf);\n  // &lt;Buffer 78 e0 82 02 01&gt;\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`str` {String} String to encode. ",
                  "name": "str",
                  "type": "String",
                  "desc": "String to encode."
                },
                {
                  "textRaw": "`encoding` {String} Default: `'utf8'` ",
                  "name": "encoding",
                  "type": "String",
                  "desc": "Default: `'utf8'`",
                  "optional": true
                }
              ],
              "desc": "<p>Creates a new Buffer containing the given JavaScript string <code>str</code>. If\nprovided, the <code>encoding</code> parameter identifies the strings character encoding.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tÃ©st&#39;);\nconsole.log(buf1.toString());\n  // prints: this is a tÃ©st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n  // prints: this is a tC)st\n\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\nconsole.log(buf2.toString());\n  // prints: this is a tÃ©st\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<p>Creates a new Buffer containing the given JavaScript string <code>str</code>. If\nprovided, the <code>encoding</code> parameter identifies the strings character encoding.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tÃ©st&#39;);\nconsole.log(buf1.toString());\n  // prints: this is a tÃ©st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n  // prints: this is a tC)st\n\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\nconsole.log(buf2.toString());\n  // prints: this is a tÃ©st\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "desc": "<p>Returns an un-pooled <code>Buffer</code>.</p>\n<p>In order to avoid the garbage collection overhead of creating many individually\nallocated Buffers, by default allocations under 4KB are sliced from a single\nlarger allocated object. This approach improves both performance and memory\nusage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>\n<p>In the case where a developer may need to retain a small chunk of memory from a\npool for an indeterminate amount of time, it may be appropriate to create an\nun-pooled Buffer instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>\n<pre><code class=\"lang-js\">// need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  var data = socket.read();\n  // allocate for retained data\n  var sb = new SlowBuffer(10);\n  // copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer\nhas observed undue memory retention in their applications.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` Number ",
                  "name": "size",
                  "desc": "Number"
                }
              ],
              "desc": "<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than\nor equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit\narchitectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is\nthrown. If a <code>size</code> less than 0 is specified, a zero-length <code>SlowBuffer</code> will be\ncreated.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and could contain\nsensitive data. Use [<code>buf.fill(0)</code>][] to initialize a <code>SlowBuffer</code> to zeroes.</p>\n<pre><code class=\"lang-js\">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;\nconst buf = new SlowBuffer(5);\nconsole.log(buf);\n  // &lt;Buffer 78 e0 82 02 01&gt;\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n<!-- [end-include:buffer.md] -->\n<!-- [start-include:child_process.md] -->\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than\nor equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit\narchitectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a [<code>RangeError</code>][] is\nthrown. If a <code>size</code> less than 0 is specified, a zero-length <code>SlowBuffer</code> will be\ncreated.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and could contain\nsensitive data. Use [<code>buf.fill(0)</code>][] to initialize a <code>SlowBuffer</code> to zeroes.</p>\n<pre><code class=\"lang-js\">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;\nconst buf = new SlowBuffer(5);\nconsole.log(buf);\n  // &lt;Buffer 78 e0 82 02 01&gt;\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n<!-- [end-include:buffer.md] -->\n<!-- [start-include:child_process.md] -->\n"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` {Number} Default: 50 ",
          "type": "Number",
          "name": "INSPECT_MAX_BYTES",
          "desc": "<p>Returns the maximum number of bytes that will be returned when\n<code>buffer.inspect()</code> is called. This can be overridden by user modules. See\n[<code>util.inspect()</code>][] for more details on <code>buffer.inspect()</code> behavior.</p>\n<p>Note that this is a property on the <code>buffer</code> module as returned by\n<code>require(&#39;buffer&#39;)</code>, not on the Buffer global or a Buffer instance.</p>\n",
          "shortDesc": "Default: 50"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    },
    {
      "textRaw": "Child Process",
      "name": "child_process",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>child_process</code> module provides the ability to spawn child processes in\na manner that is similar, but not identical, to [<code>popen(3)</code>][]. This capability\nis primarily provided by the <code>child_process.spawn()</code> function:</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);\n\nls.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stderr: ${data}`);\n});\n\nls.on(&#39;close&#39;, (code) =&gt; {\n  console.log(`child process exited with code ${code}`);\n});\n</code></pre>\n<p>By default, pipes for <code>stdin</code>, <code>stdout</code> and <code>stderr</code> are established between\nthe parent Node.js process and the spawned child. It is possible to stream data\nthrough these pipes in a non-blocking way. <em>Note, however, that some programs\nuse line-buffered I/O internally. While that does not affect Node.js, it can\nmean that data sent to the child process may not be immediately consumed.</em></p>\n<p>The <code>child_process.spawn()</code> method spawns the child process asynchronously,\nwithout blocking the Node.js event loop. The <code>child_process.spawnSync()</code>\nfunction provides equivalent functionality in a synchronous manner that blocks\nthe event loop until the spawned process either exits or is terminated.</p>\n<p>For convenience, the <code>child_process</code> module provides a handful of synchronous\nand asynchronous alternatives to [<code>child_process.spawn()</code>][] and\n[<code>child_process.spawnSync()</code>][].  <em>Note that each of these alternatives are\nimplemented on top of <code>child_process.spawn()</code> or <code>child_process.spawnSync()</code>.</em></p>\n<ul>\n<li><code>child_process.exec()</code>: spawns a shell and runs a command within that shell,\npassing the <code>stdout</code> and <code>stderr</code> to a callback function when complete.</li>\n<li><code>child_process.execFile()</code>: similar to <code>child_process.exec()</code> except that\nit spawns the command directly without first spawning a shell.</li>\n<li><code>child_process.fork()</code>: spawns a new Node.js process and invokes a\nspecified module with an IPC communication channel established that allows\nsending messages between parent and child.</li>\n<li><code>child_process.execSync()</code>: a synchronous version of\n<code>child_process.exec()</code> that <em>will</em> block the Node.js event loop.</li>\n<li><code>child_process.execFileSync()</code>: a synchronous version of\n<code>child_process.execFile()</code> that <em>will</em> block the Node.js event loop.</li>\n</ul>\n<p>For certain use cases, such as automating shell scripts, the\n[synchronous counterparts][] may be more convenient. In many cases, however,\nthe synchronous methods can have significant impact on performance due to\nstalling the event loop while spawned processes complete.</p>\n",
      "modules": [
        {
          "textRaw": "Asynchronous Process Creation",
          "name": "asynchronous_process_creation",
          "desc": "<p>The <code>child_process.spawn()</code>, <code>child_process.fork()</code>, <code>child_process.exec()</code>,\nand <code>child_process.execFile()</code> methods all follow the idiomatic asynchronous\nprogramming pattern typical of other Node.js APIs.</p>\n<p>Each of the methods returns a [<code>ChildProcess</code>][] instance. These objects\nimplement the Node.js [<code>EventEmitter</code>][] API, allowing the parent process to\nregister listener functions that are called when certain events occur during\nthe life cycle of the child process.</p>\n<p>The <code>child_process.exec()</code> and <code>child_process.execFile()</code> methods additionally\nallow for an optional <code>callback</code> function to be specified that is invoked\nwhen the child process terminates.</p>\n",
          "modules": [
            {
              "textRaw": "Spawning `.bat` and `.cmd` files on Windows",
              "name": "spawning_`.bat`_and_`.cmd`_files_on_windows",
              "desc": "<p>The importance of the distinction between <code>child_process.exec()</code> and\n<code>child_process.execFile()</code> can vary based on platform. On Unix-type operating\nsystems (Unix, Linux, OSX) <code>child_process.execFile()</code> can be more efficient\nbecause it does not spawn a shell. On Windows, however, <code>.bat</code> and <code>.cmd</code>\nfiles are not executable on their own without a terminal and therefore cannot\nbe launched using <code>child_process.execFile()</code> (or even <code>child_process.spawn()</code>).\nWhen running on Windows, <code>.bat</code> and <code>.cmd</code> files can only be invoked using\neither <code>child_process.exec()</code> or by spawning <code>cmd.exe</code> and passing the <code>.bat</code>\nor <code>.cmd</code> file as an argument (which is what <code>child_process.exec()</code> does).</p>\n<pre><code class=\"lang-js\">// On Windows Only ...\nconst spawn = require(&#39;child_process&#39;).spawn;\nconst bat = spawn(&#39;cmd.exe&#39;, [&#39;/c&#39;, &#39;my.bat&#39;]);\n\nbat.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\n\nbat.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\n\nbat.on(&#39;exit&#39;, (code) =&gt; {\n  console.log(`Child exited with code ${code}`);\n});\n\n// OR...\nconst exec = require(&#39;child_process&#39;).exec;\nexec(&#39;my.bat&#39;, (err, stdout, stderr) =&gt; {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(stdout);\n});\n</code></pre>\n",
              "type": "module",
              "displayName": "Spawning `.bat` and `.cmd` files on Windows"
            }
          ],
          "methods": [
            {
              "textRaw": "child_process.exec(command[, options][, callback])",
              "type": "method",
              "name": "exec",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {ChildProcess} ",
                    "name": "return",
                    "type": "ChildProcess"
                  },
                  "params": [
                    {
                      "textRaw": "`command` {String} The command to run, with space-separated arguments ",
                      "name": "command",
                      "type": "String",
                      "desc": "The command to run, with space-separated arguments"
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`encoding` {String} (Default: 'utf8') ",
                          "name": "encoding",
                          "default": "utf8",
                          "type": "String"
                        },
                        {
                          "textRaw": "`shell` {String} Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows,  The shell should  understand the `-c` switch on UNIX or `/s /c` on Windows. On Windows,  command line parsing should be compatible with `cmd.exe`.) ",
                          "name": "shell",
                          "type": "String",
                          "desc": "Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows,  The shell should  understand the `-c` switch on UNIX or `/s /c` on Windows. On Windows,  command line parsing should be compatible with `cmd.exe`.)"
                        },
                        {
                          "textRaw": "`timeout` {Number} (Default: 0) ",
                          "name": "timeout",
                          "default": "0",
                          "type": "Number"
                        },
                        {
                          "textRaw": "`maxBuffer` {Number} largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed (Default: `200*1024`) ",
                          "name": "maxBuffer",
                          "default": "200*1024",
                          "type": "Number",
                          "desc": "largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed"
                        },
                        {
                          "textRaw": "`killSignal` {String} (Default: 'SIGTERM') ",
                          "name": "killSignal",
                          "default": "SIGTERM",
                          "type": "String"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} called with the output when process terminates ",
                      "options": [
                        {
                          "textRaw": "`error` {Error} ",
                          "name": "error",
                          "type": "Error"
                        },
                        {
                          "textRaw": "`stdout` {String|Buffer} ",
                          "name": "stdout",
                          "type": "String|Buffer"
                        },
                        {
                          "textRaw": "`stderr` {String|Buffer} ",
                          "name": "stderr",
                          "type": "String|Buffer"
                        }
                      ],
                      "name": "callback",
                      "type": "Function",
                      "desc": "called with the output when process terminates",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Spawns a shell then executes the <code>command</code> within that shell, buffering any\ngenerated output.</p>\n<pre><code class=\"lang-js\">const exec = require(&#39;child_process&#39;).exec;\nexec(&#39;cat *.js bad_file | wc -l&#39;, (error, stdout, stderr) =&gt; {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n});\n</code></pre>\n<p>If a <code>callback</code> function is provided, it is called with the arguments\n<code>(error, stdout, stderr)</code>. On success, <code>error</code> will be <code>null</code>.  On error,\n<code>error</code> will be an instance of [<code>Error</code>][]. The <code>error.code</code> property will be\nthe exit code of the child process while <code>error.signal</code> will be set to the\nsignal that terminated the process. Any exit code other than <code>0</code> is considered\nto be an error.</p>\n<p>The <code>stdout</code> and <code>stderr</code> arguments passed to the callback will contain the\nstdout and stderr output of the child process. By default, Node.js will decode\nthe output as UTF-8 and pass strings to the callback. The <code>encoding</code> option\ncan be used to specify the character encoding used to decode the stdout and\nstderr output. If <code>encoding</code> is <code>&#39;buffer&#39;</code>, or an unrecognized character\nencoding, <code>Buffer</code> objects will be passed to the callback instead.</p>\n<p>The <code>options</code> argument may be passed as the second argument to customize how\nthe process is spawned. The default options are:</p>\n<pre><code class=\"lang-js\">{\n  encoding: &#39;utf8&#39;,\n  timeout: 0,\n  maxBuffer: 200*1024,\n  killSignal: &#39;SIGTERM&#39;,\n  cwd: null,\n  env: null\n}\n</code></pre>\n<p>If <code>timeout</code> is greater than <code>0</code>, the parent will send the the signal\nidentified by the <code>killSignal</code> property (the default is <code>&#39;SIGTERM&#39;</code>) if the\nchild runs longer than <code>timeout</code> milliseconds.</p>\n<p>The <code>maxBuffer</code> option specifies the largest amount of data (in bytes) allowed\non stdout or stderr - if this value is exceeded then the child process is\nterminated.</p>\n<p><em>Note: Unlike the <code>exec()</code> POSIX system call, <code>child_process.exec()</code> does not\nreplace the existing process and uses a shell to execute the command.</em></p>\n"
            },
            {
              "textRaw": "child_process.execFile(file[, args][, options][, callback])",
              "type": "method",
              "name": "execFile",
              "meta": {
                "added": [
                  "v0.1.91"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {ChildProcess} ",
                    "name": "return",
                    "type": "ChildProcess"
                  },
                  "params": [
                    {
                      "textRaw": "`file` {String} The name or path of the executable file to run ",
                      "name": "file",
                      "type": "String",
                      "desc": "The name or path of the executable file to run"
                    },
                    {
                      "textRaw": "`args` {Array} List of string arguments ",
                      "name": "args",
                      "type": "Array",
                      "desc": "List of string arguments",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`encoding` {String} (Default: 'utf8') ",
                          "name": "encoding",
                          "default": "utf8",
                          "type": "String"
                        },
                        {
                          "textRaw": "`timeout` {Number} (Default: 0) ",
                          "name": "timeout",
                          "default": "0",
                          "type": "Number"
                        },
                        {
                          "textRaw": "`maxBuffer` {Number} largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed (Default: 200\\*1024) ",
                          "name": "maxBuffer",
                          "default": "200\\*1024",
                          "type": "Number",
                          "desc": "largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed"
                        },
                        {
                          "textRaw": "`killSignal` {String} (Default: 'SIGTERM') ",
                          "name": "killSignal",
                          "default": "SIGTERM",
                          "type": "String"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} called with the output when process terminates ",
                      "options": [
                        {
                          "textRaw": "`error` {Error} ",
                          "name": "error",
                          "type": "Error"
                        },
                        {
                          "textRaw": "`stdout` {String|Buffer} ",
                          "name": "stdout",
                          "type": "String|Buffer"
                        },
                        {
                          "textRaw": "`stderr` {String|Buffer} ",
                          "name": "stderr",
                          "type": "String|Buffer"
                        }
                      ],
                      "name": "callback",
                      "type": "Function",
                      "desc": "called with the output when process terminates",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "file"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child_process.execFile()</code> function is similar to [<code>child_process.exec()</code>][]\nexcept that it does not spawn a shell. Rather, the specified executable <code>file</code>\nis spawned directly as a new process making it slightly more efficient than\n[<code>child_process.exec()</code>][].</p>\n<p>The same options as <code>child_process.exec()</code> are supported. Since a shell is not\nspawned, behaviors such as I/O redirection and file globbing are not supported.</p>\n<pre><code class=\"lang-js\">const execFile = require(&#39;child_process&#39;).execFile;\nconst child = execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) =&gt; {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n</code></pre>\n<p>The <code>stdout</code> and <code>stderr</code> arguments passed to the callback will contain the\nstdout and stderr output of the child process. By default, Node.js will decode\nthe output as UTF-8 and pass strings to the callback. The <code>encoding</code> option\ncan be used to specify the character encoding used to decode the stdout and\nstderr output. If <code>encoding</code> is <code>&#39;buffer&#39;</code>, or an unrecognized character\nencoding, <code>Buffer</code> objects will be passed to the callback instead.</p>\n"
            },
            {
              "textRaw": "child_process.fork(modulePath[, args][, options])",
              "type": "method",
              "name": "fork",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {ChildProcess} ",
                    "name": "return",
                    "type": "ChildProcess"
                  },
                  "params": [
                    {
                      "textRaw": "`modulePath` {String} The module to run in the child ",
                      "name": "modulePath",
                      "type": "String",
                      "desc": "The module to run in the child"
                    },
                    {
                      "textRaw": "`args` {Array} List of string arguments ",
                      "name": "args",
                      "type": "Array",
                      "desc": "List of string arguments",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`execPath` {String} Executable used to create the child process ",
                          "name": "execPath",
                          "type": "String",
                          "desc": "Executable used to create the child process"
                        },
                        {
                          "textRaw": "`execArgv` {Array} List of string arguments passed to the executable (Default: `process.execArgv`) ",
                          "name": "execArgv",
                          "default": "process.execArgv",
                          "type": "Array",
                          "desc": "List of string arguments passed to the executable"
                        },
                        {
                          "textRaw": "`silent` {Boolean} If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the `'pipe'` and `'inherit'` options for [`child_process.spawn()`][]'s [`stdio`][] for more details (default is false) ",
                          "name": "silent",
                          "type": "Boolean",
                          "desc": "If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the `'pipe'` and `'inherit'` options for [`child_process.spawn()`][]'s [`stdio`][] for more details (default is false)"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "modulePath"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child_process.fork()</code> method is a special case of\n[<code>child_process.spawn()</code>][] used specifically to spawn new Node.js processes.\nLike <code>child_process.spawn()</code>, a <code>ChildProcess</code> object is returned. The returned\n<code>ChildProcess</code> will have an additional communication channel built-in that\nallows messages to be passed back and forth between the parent and child. See\n[<code>ChildProcess#send()</code>][] for details.</p>\n<p>It is important to keep in mind that spawned Node.js child processes are\nindependent of the parent with exception of the IPC communication channel\nthat is established between the two. Each process has it&#39;s own memory, with\ntheir own V8 instances. Because of the additional resource allocations\nrequired, spawning a large number of child Node.js processes is not\nrecommended.</p>\n<p>By default, <code>child_process.fork()</code> will spawn new Node.js instances using the\n<code>process.execPath</code> of the parent process. The <code>execPath</code> property in the\n<code>options</code> object allows for an alternative execution path to be used.</p>\n<p>Node.js processes launched with a custom <code>execPath</code> will communicate with the\nparent process using the file descriptor (fd) identified using the\nenvironment variable <code>NODE_CHANNEL_FD</code> on the child process. The input and\noutput on this fd is expected to be line delimited JSON objects.</p>\n<p><em>Note: Unlike the <code>fork()</code> POSIX system call, [<code>child_process.fork()</code>][] does\nnot clone the current process.</em></p>\n"
            },
            {
              "textRaw": "child_process.spawn(command[, args][, options])",
              "type": "method",
              "name": "spawn",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "return: {ChildProcess} ",
                    "name": "return",
                    "type": "ChildProcess"
                  },
                  "params": [
                    {
                      "textRaw": "`command` {String} The command to run ",
                      "name": "command",
                      "type": "String",
                      "desc": "The command to run"
                    },
                    {
                      "textRaw": "`args` {Array} List of string arguments ",
                      "name": "args",
                      "type": "Array",
                      "desc": "List of string arguments",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`stdio` {Array|String} Child's stdio configuration. (See [`options.stdio`][]) ",
                          "name": "stdio",
                          "type": "Array|String",
                          "desc": "Child's stdio configuration. (See [`options.stdio`][])"
                        },
                        {
                          "textRaw": "`detached` {Boolean} Prepare child to run independently of its parent process. Specific behavior depends on the platform, see [`options.detached`][]) ",
                          "name": "detached",
                          "type": "Boolean",
                          "desc": "Prepare child to run independently of its parent process. Specific behavior depends on the platform, see [`options.detached`][])"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child_process.spawn()</code> method spawns a new process using the given\n<code>command</code>, with command line arguments in <code>args</code>. If omitted, <code>args</code> defaults\nto an empty array.</p>\n<p>A third argument may be used to specify additional options, with these defaults:</p>\n<pre><code class=\"lang-js\">{\n  cwd: undefined,\n  env: process.env\n}\n</code></pre>\n<p>Use <code>cwd</code> to specify the working directory from which the process is spawned.\nIf not given, the default is to inherit the current working directory.</p>\n<p>Use <code>env</code> to specify environment variables that will be visible to the new\nprocess, the default is <code>process.env</code>.</p>\n<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the\nexit code:</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);\n\nls.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stderr: ${data}`);\n});\n\nls.on(&#39;close&#39;, (code) =&gt; {\n  console.log(`child process exited with code ${code}`);\n});\n</code></pre>\n<p>Example: A very elaborate way to run &#39;ps ax | grep ssh&#39;</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst ps = spawn(&#39;ps&#39;, [&#39;ax&#39;]);\nconst grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\nps.stdout.on(&#39;data&#39;, (data) =&gt; {\n  grep.stdin.write(data);\n});\n\nps.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`ps stderr: ${data}`);\n});\n\nps.on(&#39;close&#39;, (code) =&gt; {\n  if (code !== 0) {\n    console.log(`ps process exited with code ${code}`);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`${data}`);\n});\n\ngrep.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`grep stderr: ${data}`);\n});\n\ngrep.on(&#39;close&#39;, (code) =&gt; {\n  if (code !== 0) {\n    console.log(`grep process exited with code ${code}`);\n  }\n});\n</code></pre>\n<p>Example of checking for failed exec:</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst child = spawn(&#39;bad_command&#39;);\n\nchild.on(&#39;error&#39;, (err) =&gt; {\n  console.log(&#39;Failed to start child process.&#39;);\n});\n</code></pre>\n",
              "properties": [
                {
                  "textRaw": "options.detached",
                  "name": "detached",
                  "meta": {
                    "added": [
                      "v0.7.10"
                    ]
                  },
                  "desc": "<p>On Windows, setting <code>options.detached</code> to <code>true</code> makes it possible for the\nchild process to continue running after the parent exits. The child will have\nits own console window. <em>Once enabled for a child process, it cannot be\ndisabled</em>.</p>\n<p>On non-Windows platforms, if <code>options.detached</code> is set to <code>true</code>, the child\nprocess will be made the leader of a new process group and session. Note that\nchild processes may continue running after the parent exits regardless of\nwhether they are detached or not.  See <code>setsid(2)</code> for more information.</p>\n<p>By default, the parent will wait for the detached child to exit. To prevent\nthe parent from waiting for a given <code>child</code>, use the <code>child.unref()</code> method.\nDoing so will cause the parent&#39;s event loop to not include the child in its\nreference count, allowing the parent to exit independently of the child, unless\nthere is an established IPC channel between the child and parent.</p>\n<p>When using the <code>detached</code> option to start a long-running process, the process\nwill not stay running in the background after the parent exits unless it is\nprovided with a <code>stdio</code> configuration that is not connected to the parent.\nIf the parent&#39;s <code>stdio</code> is inherited, the child will remain attached to the\ncontrolling terminal.</p>\n<p>Example of a long-running process, by detaching and also ignoring its parent\n<code>stdio</code> file descriptors, in order to ignore the parent&#39;s termination:</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\n\nconst child = spawn(process.argv[0], [&#39;child_program.js&#39;], {\n  detached: true,\n  stdio: &#39;ignore&#39;\n});\n\nchild.unref();\n</code></pre>\n<p>Alternatively one can redirect the child process&#39; output into files:</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\nconst spawn = require(&#39;child_process&#39;).spawn;\nconst out = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);\nconst err = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);\n\nconst child = spawn(&#39;prg&#39;, [], {\n detached: true,\n stdio: [ &#39;ignore&#39;, out, err ]\n});\n\nchild.unref();\n</code></pre>\n"
                },
                {
                  "textRaw": "options.stdio",
                  "name": "stdio",
                  "meta": {
                    "added": [
                      "v0.7.10"
                    ]
                  },
                  "desc": "<p>The <code>options.stdio</code> option is used to configure the pipes that are established\nbetween the parent and child process. By default, the child&#39;s stdin, stdout,\nand stderr are redirected to corresponding <code>child.stdin</code>, <code>child.stdout</code>, and\n<code>child.stderr</code> streams on the <code>ChildProcess</code> object. This is equivalent to\nsetting the <code>options.stdio</code> equal to <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>.</p>\n<p>For convenience, <code>options.stdio</code> may be one of the following strings:</p>\n<ul>\n<li><code>&#39;pipe&#39;</code> - equivalent to <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code> (the default)</li>\n<li><code>&#39;ignore&#39;</code> - equivalent to <code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>\n<li><code>&#39;inherit&#39;</code> - equivalent to <code>[process.stdin, process.stdout, process.stderr]</code>\n or <code>[0,1,2]</code></li>\n</ul>\n<p>Otherwise, the value of <code>option.stdio</code> is an array where each index corresponds\nto an fd in the child. The fds 0, 1, and 2 correspond to stdin, stdout,\nand stderr, respectively. Additional fds can be specified to create additional\npipes between the parent and child. The value is one of the following:</p>\n<ol>\n<li><code>&#39;pipe&#39;</code> - Create a pipe between the child process and the parent process.\nThe parent end of the pipe is exposed to the parent as a property on the\n<code>child_process</code> object as <code>ChildProcess.stdio[fd]</code>. Pipes created for\nfds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout\nand ChildProcess.stderr, respectively.</li>\n<li><code>&#39;ipc&#39;</code> - Create an IPC channel for passing messages/file descriptors\nbetween parent and child. A ChildProcess may have at most <em>one</em> IPC stdio\nfile descriptor. Setting this option enables the ChildProcess.send() method.\nIf the child writes JSON messages to this file descriptor, the\n<code>ChildProcess.on(&#39;message&#39;)</code> event handler will be triggered in the parent.\nIf the child is a Node.js process, the presence of an IPC channel will enable\n<code>process.send()</code>, <code>process.disconnect()</code>, <code>process.on(&#39;disconnect&#39;)</code>, and\n<code>process.on(&#39;message&#39;)</code> within the child.</li>\n<li><code>&#39;ignore&#39;</code> - Instructs Node.js to ignore the fd in the child. While Node.js\nwill always open fds 0 - 2 for the processes it spawns, setting the fd to\n<code>&#39;ignore&#39;</code> will cause Node.js to open <code>/dev/null</code> and attach it to the\nchild&#39;s fd.</li>\n<li><code>Stream</code> object - Share a readable or writable stream that refers to a tty,\nfile, socket, or a pipe with the child process. The stream&#39;s underlying\nfile descriptor is duplicated in the child process to the fd that\ncorresponds to the index in the <code>stdio</code> array. Note that the stream must\nhave an underlying descriptor (file streams do not until the <code>&#39;open&#39;</code>\nevent has occurred).</li>\n<li>Positive integer - The integer value is interpreted as a file descriptor\nthat is is currently open in the parent process. It is shared with the child\nprocess, similar to how <code>Stream</code> objects can be shared.</li>\n<li><code>null</code>, <code>undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other\nwords, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the\ndefault is <code>&#39;ignore&#39;</code>.</li>\n</ol>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\n\n// Child will use parent&#39;s stdios\nspawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });\n\n// Spawn child sharing only stderr\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });\n\n// Open an extra fd=4, to interact with programs presenting a\n// startd-style interface.\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] });\n</code></pre>\n<p><em>It is worth noting that when an IPC channel is established between the\nparent and child processes, and the child is a Node.js process, the child\nis launched with the IPC channel unreferenced (using <code>unref()</code>) until the\nchild registers an event handler for the <code>process.on(&#39;disconnected&#39;)</code> event.\nThis allows the child to exit normally without the process being held open\nby the open IPC channel.</em></p>\n<p>See also: [<code>child_process.exec()</code>][] and [<code>child_process.fork()</code>][]</p>\n"
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Asynchronous Process Creation"
        },
        {
          "textRaw": "Synchronous Process Creation",
          "name": "synchronous_process_creation",
          "desc": "<p>The <code>child_process.spawnSync()</code>, <code>child_process.execSync()</code>, and\n<code>child_process.execFileSync()</code> methods are <strong>synchronous</strong> and <strong>WILL</strong> block\nthe Node.js event loop, pausing execution of any additional code until the\nspawned process exits.</p>\n<p>Blocking calls like these are mostly useful for simplifying general purpose\nscripting tasks and for simplifying the loading/processing of application\nconfiguration at startup.</p>\n",
          "methods": [
            {
              "textRaw": "child_process.execFileSync(file[, args][, options])",
              "type": "method",
              "name": "execFileSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "return: {Buffer|String} The stdout from the command ",
                    "name": "return",
                    "type": "Buffer|String",
                    "desc": "The stdout from the command"
                  },
                  "params": [
                    {
                      "textRaw": "`file` {String} The name or path of the executable file to run ",
                      "name": "file",
                      "type": "String",
                      "desc": "The name or path of the executable file to run"
                    },
                    {
                      "textRaw": "`args` {Array} List of string arguments ",
                      "name": "args",
                      "type": "Array",
                      "desc": "List of string arguments",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`input` {String|Buffer} The value which will be passed as stdin to the spawned process ",
                          "options": [
                            {
                              "textRaw": "supplying this value will override `stdio[0]` ",
                              "name": "supplying",
                              "desc": "this value will override `stdio[0]`"
                            }
                          ],
                          "name": "input",
                          "type": "String|Buffer",
                          "desc": "The value which will be passed as stdin to the spawned process"
                        },
                        {
                          "textRaw": "`stdio` {Array} Child's stdio configuration. (Default: 'pipe') ",
                          "options": [
                            {
                              "textRaw": "`stderr` by default will be output to the parent process' stderr unless `stdio` is specified ",
                              "name": "stderr",
                              "desc": "by default will be output to the parent process' stderr unless `stdio` is specified"
                            }
                          ],
                          "name": "stdio",
                          "default": "pipe",
                          "type": "Array",
                          "desc": "Child's stdio configuration."
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        },
                        {
                          "textRaw": "`timeout` {Number} In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined) ",
                          "name": "timeout",
                          "default": "undefined",
                          "type": "Number",
                          "desc": "In milliseconds the maximum amount of time the process is allowed to run."
                        },
                        {
                          "textRaw": "`killSignal` {String} The signal value to be used when the spawned process will be killed. (Default: 'SIGTERM') ",
                          "name": "killSignal",
                          "default": "SIGTERM",
                          "type": "String",
                          "desc": "The signal value to be used when the spawned process will be killed."
                        },
                        {
                          "textRaw": "`maxBuffer` {Number} largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed ",
                          "name": "maxBuffer",
                          "type": "Number",
                          "desc": "largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed"
                        },
                        {
                          "textRaw": "`encoding` {String} The encoding used for all stdio inputs and outputs. (Default: 'buffer') ",
                          "name": "encoding",
                          "default": "buffer",
                          "type": "String",
                          "desc": "The encoding used for all stdio inputs and outputs."
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "file"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child_process.execFileSync()</code> method is generally identical to\n<code>child_process.execFile()</code> with the exception that the method will not return\nuntil the child process has fully closed. When a timeout has been encountered\nand <code>killSignal</code> is sent, the method won&#39;t return until the process has\ncompletely exited. <em>Note that if the child process intercepts and handles\nthe <code>SIGTERM</code> signal and does not exit, the parent process will still wait\nuntil the child process has exited.</em></p>\n<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>\nthrow.  The [<code>Error</code>][] object will contain the entire result from\n[<code>child_process.spawnSync()</code>][]</p>\n"
            },
            {
              "textRaw": "child_process.execSync(command[, options])",
              "type": "method",
              "name": "execSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "return: {Buffer|String} The stdout from the command ",
                    "name": "return",
                    "type": "Buffer|String",
                    "desc": "The stdout from the command"
                  },
                  "params": [
                    {
                      "textRaw": "`command` {String} The command to run ",
                      "name": "command",
                      "type": "String",
                      "desc": "The command to run"
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`input` {String|Buffer} The value which will be passed as stdin to the spawned process ",
                          "options": [
                            {
                              "textRaw": "supplying this value will override `stdio[0]` ",
                              "name": "supplying",
                              "desc": "this value will override `stdio[0]`"
                            }
                          ],
                          "name": "input",
                          "type": "String|Buffer",
                          "desc": "The value which will be passed as stdin to the spawned process"
                        },
                        {
                          "textRaw": "`stdio` {Array} Child's stdio configuration. (Default: 'pipe') ",
                          "options": [
                            {
                              "textRaw": "`stderr` by default will be output to the parent process' stderr unless `stdio` is specified ",
                              "name": "stderr",
                              "desc": "by default will be output to the parent process' stderr unless `stdio` is specified"
                            }
                          ],
                          "name": "stdio",
                          "default": "pipe",
                          "type": "Array",
                          "desc": "Child's stdio configuration."
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`shell` {String} Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows,  The shell should  understand the `-c` switch on UNIX or `/s /c` on Windows. On Windows,  command line parsing should be compatible with `cmd.exe`.) ",
                          "name": "shell",
                          "type": "String",
                          "desc": "Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows,  The shell should  understand the `-c` switch on UNIX or `/s /c` on Windows. On Windows,  command line parsing should be compatible with `cmd.exe`.)"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        },
                        {
                          "textRaw": "`timeout` {Number} In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined) ",
                          "name": "timeout",
                          "default": "undefined",
                          "type": "Number",
                          "desc": "In milliseconds the maximum amount of time the process is allowed to run."
                        },
                        {
                          "textRaw": "`killSignal` {String} The signal value to be used when the spawned process will be killed. (Default: 'SIGTERM') ",
                          "name": "killSignal",
                          "default": "SIGTERM",
                          "type": "String",
                          "desc": "The signal value to be used when the spawned process will be killed."
                        },
                        {
                          "textRaw": "`maxBuffer` {Number} largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed ",
                          "name": "maxBuffer",
                          "type": "Number",
                          "desc": "largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed"
                        },
                        {
                          "textRaw": "`encoding` {String} The encoding used for all stdio inputs and outputs. (Default: 'buffer') ",
                          "name": "encoding",
                          "default": "buffer",
                          "type": "String",
                          "desc": "The encoding used for all stdio inputs and outputs."
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child_process.execSync()</code> method is generally identical to\n<code>child_process.exec()</code> with the exception that the method will not return until\nthe child process has fully closed. When a timeout has been encountered and\n<code>killSignal</code> is sent, the method won&#39;t return until the process has completely\nexited. <em>Note that if  the child process intercepts and handles the <code>SIGTERM</code>\nsignal and doesn&#39;t exit, the parent process will wait until the child\nprocess has exited.</em></p>\n<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>\nthrow.  The [<code>Error</code>][] object will contain the entire result from\n[<code>child_process.spawnSync()</code>][]</p>\n"
            },
            {
              "textRaw": "child_process.spawnSync(command[, args][, options])",
              "type": "method",
              "name": "spawnSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "return: {Object} ",
                    "options": [
                      {
                        "textRaw": "`pid` {Number} Pid of the child process ",
                        "name": "pid",
                        "type": "Number",
                        "desc": "Pid of the child process"
                      },
                      {
                        "textRaw": "`output` {Array} Array of results from stdio output ",
                        "name": "output",
                        "type": "Array",
                        "desc": "Array of results from stdio output"
                      },
                      {
                        "textRaw": "`stdout` {Buffer|String} The contents of `output[1]` ",
                        "name": "stdout",
                        "type": "Buffer|String",
                        "desc": "The contents of `output[1]`"
                      },
                      {
                        "textRaw": "`stderr` {Buffer|String} The contents of `output[2]` ",
                        "name": "stderr",
                        "type": "Buffer|String",
                        "desc": "The contents of `output[2]`"
                      },
                      {
                        "textRaw": "`status` {Number} The exit code of the child process ",
                        "name": "status",
                        "type": "Number",
                        "desc": "The exit code of the child process"
                      },
                      {
                        "textRaw": "`signal` {String} The signal used to kill the child process ",
                        "name": "signal",
                        "type": "String",
                        "desc": "The signal used to kill the child process"
                      },
                      {
                        "textRaw": "`error` {Error} The error object if the child process failed or timed out ",
                        "name": "error",
                        "type": "Error",
                        "desc": "The error object if the child process failed or timed out"
                      }
                    ],
                    "name": "return",
                    "type": "Object"
                  },
                  "params": [
                    {
                      "textRaw": "`command` {String} The command to run ",
                      "name": "command",
                      "type": "String",
                      "desc": "The command to run"
                    },
                    {
                      "textRaw": "`args` {Array} List of string arguments ",
                      "name": "args",
                      "type": "Array",
                      "desc": "List of string arguments",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} Current working directory of the child process ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "Current working directory of the child process"
                        },
                        {
                          "textRaw": "`input` {String|Buffer} The value which will be passed as stdin to the spawned process ",
                          "options": [
                            {
                              "textRaw": "supplying this value will override `stdio[0]` ",
                              "name": "supplying",
                              "desc": "this value will override `stdio[0]`"
                            }
                          ],
                          "name": "input",
                          "type": "String|Buffer",
                          "desc": "The value which will be passed as stdin to the spawned process"
                        },
                        {
                          "textRaw": "`stdio` {Array} Child's stdio configuration. ",
                          "name": "stdio",
                          "type": "Array",
                          "desc": "Child's stdio configuration."
                        },
                        {
                          "textRaw": "`env` {Object} Environment key-value pairs ",
                          "name": "env",
                          "type": "Object",
                          "desc": "Environment key-value pairs"
                        },
                        {
                          "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "Sets the user identity of the process. (See setuid(2).)"
                        },
                        {
                          "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "Sets the group identity of the process. (See setgid(2).)"
                        },
                        {
                          "textRaw": "`timeout` {Number} In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined) ",
                          "name": "timeout",
                          "default": "undefined",
                          "type": "Number",
                          "desc": "In milliseconds the maximum amount of time the process is allowed to run."
                        },
                        {
                          "textRaw": "`killSignal` {String} The signal value to be used when the spawned process will be killed. (Default: 'SIGTERM') ",
                          "name": "killSignal",
                          "default": "SIGTERM",
                          "type": "String",
                          "desc": "The signal value to be used when the spawned process will be killed."
                        },
                        {
                          "textRaw": "`maxBuffer` {Number} largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed ",
                          "name": "maxBuffer",
                          "type": "Number",
                          "desc": "largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed"
                        },
                        {
                          "textRaw": "`encoding` {String} The encoding used for all stdio inputs and outputs. (Default: 'buffer') ",
                          "name": "encoding",
                          "default": "buffer",
                          "type": "String",
                          "desc": "The encoding used for all stdio inputs and outputs."
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child_process.spawnSync()</code> method is generally identical to\n<code>child_process.spawn()</code> with the exception that the function will not return\nuntil the child process has fully closed. When a timeout has been encountered\nand <code>killSignal</code> is sent, the method won&#39;t return until the process has\ncompletely exited. Note that if the process intercepts and handles the\n<code>SIGTERM</code> signal and doesn&#39;t exit, the parent process will wait until the child\nprocess has exited.</p>\n"
            }
          ],
          "type": "module",
          "displayName": "Synchronous Process Creation"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: ChildProcess",
          "type": "class",
          "name": "ChildProcess",
          "meta": {
            "added": [
              "v2.2.0"
            ]
          },
          "desc": "<p>Instances of the <code>ChildProcess</code> class are [<code>EventEmitters</code>][] that represent\nspawned child processes.</p>\n<p>Instances of <code>ChildProcess</code> are not intended to be created directly. Rather,\nuse the [<code>child_process.spawn()</code>][], [<code>child_process.exec()</code>][],\n[<code>child_process.execFile()</code>][], or [<code>child_process.fork()</code>][] methods to create\ninstances of <code>ChildProcess</code>.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "params": [],
              "desc": "<p>The <code>&#39;close&#39;</code> event is emitted when the stdio streams of a child process have\nbeen closed. This is distinct from the <code>&#39;exit&#39;</code> event, since multiple\nprocesses might share the same stdio streams.</p>\n"
            },
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>The <code>&#39;disconnect&#39;</code> event is emitted after calling the\n<code>ChildProcess.disconnect()</code> method in the parent or child process. After\ndisconnecting it is no longer possible to send or receive messages, and the\n<code>ChildProcess.connected</code> property is false.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>The <code>&#39;error&#39;</code> event is emitted whenever:</p>\n<ol>\n<li>The process could not be spawned, or</li>\n<li>The process could not be killed, or</li>\n<li>Sending a message to the child process failed.</li>\n</ol>\n<p>Note that the <code>&#39;exit&#39;</code> event may or may not fire after an error has occurred.\nIf you are listening to both the <code>&#39;exit&#39;</code> and <code>&#39;error&#39;</code> events, it is important\nto guard against accidentally invoking handler functions multiple times.</p>\n<p>See also [<code>ChildProcess#kill()</code>][] and [<code>ChildProcess#send()</code>][].</p>\n"
            },
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>The <code>&#39;exit&#39;</code> event is emitted after the child process ends. If the process\nexited, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If the\nprocess terminated due to receipt of a signal, <code>signal</code> is the string name of\nthe signal, otherwise <code>null</code>. One of the two will always be non-null.</p>\n<p>Note that when the <code>&#39;exit&#39;</code> event is triggered, child process stdio streams\nmight still be open.</p>\n<p>Also, note that Node.js establishes signal handlers for <code>SIGINT</code> and\n<code>SIGTERM</code> and Node.js processes will not terminate immediately due to receipt\nof those signals. Rather, Node.js will perform a sequence of cleanup actions\nand then will re-raise the handled signal.</p>\n<p>See <code>waitpid(2)</code>.</p>\n"
            },
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "params": [],
              "desc": "<p>The <code>&#39;message&#39;</code> event is triggered when a child process uses <code>process.send()</code>\nto send messages.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`connected` {Boolean} Set to false after `.disconnect` is called ",
              "type": "Boolean",
              "name": "connected",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>The <code>child.connected</code> property indicates whether it is still possible to send\nand receive messages from a child process. When <code>child.connected</code> is false, it\nis no longer possible to send or receive messages.</p>\n",
              "shortDesc": "Set to false after `.disconnect` is called"
            },
            {
              "textRaw": "`pid` {Number} Integer ",
              "type": "Number",
              "name": "pid",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Returns the process identifier (PID) of the child process.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\nconsole.log(`Spawned child pid: ${grep.pid}`);\ngrep.stdin.end();\n</code></pre>\n",
              "shortDesc": "Integer"
            },
            {
              "textRaw": "`stderr` {Stream} ",
              "type": "Stream",
              "name": "stderr",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>A <code>Readable Stream</code> that represents the child process&#39;s <code>stderr</code>.</p>\n<p>If the child was spawned with <code>stdio[2]</code> set to anything other than <code>&#39;pipe&#39;</code>,\nthen this will be <code>undefined</code>.</p>\n<p><code>child.stderr</code> is an alias for <code>child.stdio[2]</code>. Both properties will refer to\nthe same value.</p>\n"
            },
            {
              "textRaw": "`stdin` {Stream} ",
              "type": "Stream",
              "name": "stdin",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>A <code>Writable Stream</code> that represents the child process&#39;s <code>stdin</code>.</p>\n<p><em>Note that if a child process waits to read all of its input, the child will not\ncontinue until this stream has been closed via <code>end()</code>.</em></p>\n<p>If the child was spawned with <code>stdio[0]</code> set to anything other than <code>&#39;pipe&#39;</code>,\nthen this will be <code>undefined</code>.</p>\n<p><code>child.stdin</code> is an alias for <code>child.stdio[0]</code>. Both properties will refer to\nthe same value.</p>\n"
            },
            {
              "textRaw": "`stdio` {Array} ",
              "type": "Array",
              "name": "stdio",
              "meta": {
                "added": [
                  "v0.7.10"
                ]
              },
              "desc": "<p>A sparse array of pipes to the child process, corresponding with positions in\nthe [<code>stdio</code>][] option passed to [<code>child_process.spawn()</code>][] that have been set\nto the value <code>&#39;pipe&#39;</code>. Note that <code>child.stdio[0]</code>, <code>child.stdio[1]</code>, and\n<code>child.stdio[2]</code> are also available as <code>child.stdin</code>, <code>child.stdout</code>, and\n<code>child.stderr</code>, respectively.</p>\n<p>In the following example, only the child&#39;s fd <code>1</code> (stdout) is configured as a\npipe, so only the parent&#39;s <code>child.stdio[1]</code> is a stream, all other values in\nthe array are <code>null</code>.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\nconst fs = require(&#39;fs&#39;);\nconst child_process = require(&#39;child_process&#39;);\n\nconst child = child_process.spawn(&#39;ls&#39;, {\n    stdio: [\n      0, // Use parents stdin for child\n      &#39;pipe&#39;, // Pipe child&#39;s stdout to parent\n      fs.openSync(&#39;err.out&#39;, &#39;w&#39;) // Direct child&#39;s stderr to a file\n    ]\n});\n\nassert.equal(child.stdio[0], null);\nassert.equal(child.stdio[0], child.stdin);\n\nassert(child.stdout);\nassert.equal(child.stdio[1], child.stdout);\n\nassert.equal(child.stdio[2], null);\nassert.equal(child.stdio[2], child.stderr);\n</code></pre>\n"
            },
            {
              "textRaw": "`stdout` {Stream} ",
              "type": "Stream",
              "name": "stdout",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>A <code>Readable Stream</code> that represents the child process&#39;s <code>stdout</code>.</p>\n<p>If the child was spawned with <code>stdio[1]</code> set to anything other than <code>&#39;pipe&#39;</code>,\nthen this will be <code>undefined</code>.</p>\n<p><code>child.stdout</code> is an alias for <code>child.stdio[1]</code>. Both properties will refer\nto the same value.</p>\n<!-- [end-include:child_process.md] -->\n<!-- [start-include:cluster.md] -->\n"
            }
          ],
          "methods": [
            {
              "textRaw": "child.disconnect()",
              "type": "method",
              "name": "disconnect",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>Closes the IPC channel between parent and child, allowing the child to exit\ngracefully once there are no other connections keeping it alive. After calling\nthis method the <code>child.connected</code> and <code>process.connected</code> properties in both\nthe parent and child (respectively) will be set to <code>false</code>, and it will be no\nlonger possible to pass messages between the processes.</p>\n<p>The <code>&#39;disconnect&#39;</code> event will be emitted when there are no messages in the\nprocess of being received. This will most often be triggered immediately after\ncalling <code>child.disconnect()</code>.</p>\n<p>Note that when the child process is a Node.js instance (e.g. spawned using\n[<code>child_process.fork()</code>]), the <code>process.disconnect()</code> method can be invoked\nwithin the child process to close the IPC channel as well.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "child.kill([signal])",
              "type": "method",
              "name": "kill",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`signal` {String} ",
                      "name": "signal",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>child.kill()</code> methods sends a signal to the child process. If no argument\nis given, the process will be sent the <code>&#39;SIGTERM&#39;</code> signal. See <code>signal(7)</code> for\na list of available signals.</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\ngrep.on(&#39;close&#39;, (code, signal) =&gt; {\n  console.log(\n    `child process terminated due to receipt of signal ${signal}`);\n});\n\n// Send SIGHUP to process\ngrep.kill(&#39;SIGHUP&#39;);\n</code></pre>\n<p>The <code>ChildProcess</code> object may emit an <code>&#39;error&#39;</code> event if the signal cannot be\ndelivered. Sending a signal to a child process that has already exited is not\nan error but may have unforeseen consequences. Specifically, if the process\nidentifier (PID) has been reassigned to another process, the signal will be\ndelivered to that process instead which can have unexpected results.</p>\n<p>Note that while the function is called <code>kill</code>, the signal delivered to the\nchild process may not actually terminate the process.</p>\n<p>See <code>kill(2)</code> for reference.</p>\n<p>Also note: on Linux, child processes of child processes will not be terminated\nwhen attempting to kill their parent. This is likely to happen when running a\nnew process in a shell or with use of the <code>shell</code> option of <code>ChildProcess</code>, such\nas in this example:</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\nconst spawn = require(&#39;child_process&#39;).spawn;\n\nlet child = spawn(&#39;sh&#39;, [&#39;-c&#39;,\n  `node -e &quot;setInterval(() =&gt; {\n      console.log(process.pid + &#39;is alive&#39;)\n    }, 500);&quot;`\n  ], {\n    stdio: [&#39;inherit&#39;, &#39;inherit&#39;, &#39;inherit&#39;]\n  });\n\nsetTimeout(() =&gt; {\n  child.kill(); // does not terminate the node process in the shell\n}, 2000);\n</code></pre>\n"
            },
            {
              "textRaw": "child.send(message[, sendHandle][, callback])",
              "type": "method",
              "name": "send",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle} ",
                      "name": "sendHandle",
                      "type": "Handle",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>When an IPC channel has been established between the parent and child (\ni.e. when using [<code>child_process.fork()</code>][]), the <code>child.send()</code> method can be\nused to send messages to the child process. When the child process is a Node.js\ninstance, these messages can be received via the <code>process.on(&#39;message&#39;)</code> event.</p>\n<p>For example, in the parent script:</p>\n<pre><code class=\"lang-js\">const cp = require(&#39;child_process&#39;);\nconst n = cp.fork(`${__dirname}/sub.js`);\n\nn.on(&#39;message&#39;, (m) =&gt; {\n  console.log(&#39;PARENT got message:&#39;, m);\n});\n\nn.send({ hello: &#39;world&#39; });\n</code></pre>\n<p>And then the child script, <code>&#39;sub.js&#39;</code> might look like this:</p>\n<pre><code class=\"lang-js\">process.on(&#39;message&#39;, (m) =&gt; {\n  console.log(&#39;CHILD got message:&#39;, m);\n});\n\nprocess.send({ foo: &#39;bar&#39; });\n</code></pre>\n<p>Child Node.js processes will have a <code>process.send()</code> method of their own that\nallows the child to send messages back to the parent.</p>\n<p>There is a special case when sending a <code>{cmd: &#39;NODE_foo&#39;}</code> message. All messages\ncontaining a <code>NODE_</code> prefix in its <code>cmd</code> property are considered to be reserved\nfor use within Node.js core and will not be emitted in the child&#39;s\n<code>process.on(&#39;message&#39;)</code> event. Rather, such messages are emitted using the\n<code>process.on(&#39;internalMessage&#39;)</code> event and are consumed internally by Node.js.\nApplications should avoid using such messages or listening for\n<code>&#39;internalMessage&#39;</code> events as it is subject to change without notice.</p>\n<p>The optional <code>sendHandle</code> argument that may be passed to <code>child.send()</code> is for\npassing a TCP server or socket object to the child process. The child will\nreceive the object as the second argument passed to the callback function\nregistered on the <code>process.on(&#39;message&#39;)</code> event. Any data that is received and\nbuffered in the socket will not be sent to the child.</p>\n<p>The optional <code>callback</code> is a function that is invoked after the message is\nsent but before the child may have received it.  The function is called with a\nsingle argument: <code>null</code> on success, or an [<code>Error</code>][] object on failure.</p>\n<p>If no <code>callback</code> function is provided and the message cannot be sent, an\n<code>&#39;error&#39;</code> event will be emitted by the <code>ChildProcess</code> object. This can happen,\nfor instance, when the child process has already exited.</p>\n<p><code>child.send()</code> will return <code>false</code> if the channel has closed or when the\nbacklog of unsent messages exceeds a threshold that makes it unwise to send\nmore. Otherwise, the method returns <code>true</code>. The <code>callback</code> function can be\nused to implement flow control.</p>\n<h4>Example: sending a server object</h4>\n<p>The <code>sendHandle</code> argument can be used, for instance, to pass the handle of\na TCP server object to the child process as illustrated in the example below:</p>\n<pre><code class=\"lang-js\">const child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;);\n\n// Open up the server object and send the handle.\nconst server = require(&#39;net&#39;).createServer();\nserver.on(&#39;connection&#39;, (socket) =&gt; {\n  socket.end(&#39;handled by parent&#39;);\n});\nserver.listen(1337, () =&gt; {\n  child.send(&#39;server&#39;, server);\n});\n</code></pre>\n<p>The child would then receive the server object as:</p>\n<pre><code class=\"lang-js\">process.on(&#39;message&#39;, (m, server) =&gt; {\n  if (m === &#39;server&#39;) {\n    server.on(&#39;connection&#39;, (socket) =&gt; {\n      socket.end(&#39;handled by child&#39;);\n    });\n  }\n});\n</code></pre>\n<p>Once the server is now shared between the parent and child, some connections\ncan be handled by the parent and some by the child.</p>\n<p>While the example above uses a server created using the <code>net</code> module, <code>dgram</code>\nmodule servers use exactly the same workflow with the exceptions of listening on\na <code>&#39;message&#39;</code> event instead of <code>&#39;connection&#39;</code> and using <code>server.bind</code> instead of\n<code>server.listen</code>. This is, however, currently only supported on UNIX platforms.</p>\n<h4>Example: sending a socket object</h4>\n<p>Similarly, the <code>sendHandler</code> argument can be used to pass the handle of a\nsocket to the child process. The example below spawns two children that each\nhandle connections with &quot;normal&quot; or &quot;special&quot; priority:</p>\n<pre><code class=\"lang-js\">const normal = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;normal&#39;]);\nconst special = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;special&#39;]);\n\n// Open up the server and send sockets to child\nconst server = require(&#39;net&#39;).createServer();\nserver.on(&#39;connection&#39;, (socket) =&gt; {\n\n  // If this is special priority\n  if (socket.remoteAddress === &#39;74.125.127.100&#39;) {\n    special.send(&#39;socket&#39;, socket);\n    return;\n  }\n  // This is normal priority\n  normal.send(&#39;socket&#39;, socket);\n});\nserver.listen(1337);\n</code></pre>\n<p>The <code>child.js</code> would receive the socket handle as the second argument passed\nto the event callback function:</p>\n<pre><code class=\"lang-js\">process.on(&#39;message&#39;, (m, socket) =&gt; {\n  if (m === &#39;socket&#39;) {\n    socket.end(`Request handled with ${process.argv[2]} priority`);\n  }\n});\n</code></pre>\n<p>Once a socket has been passed to a child, the parent is no longer capable of\ntracking when the socket is destroyed. To indicate this, the <code>.connections</code>\nproperty becomes <code>null</code>. It is recommended not to use <code>.maxConnections</code> when\nthis occurs.</p>\n<p><em>Note: this function uses [<code>JSON.stringify()</code>][] internally to serialize the <code>message</code>.</em></p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Child Process"
    },
    {
      "textRaw": "Cluster",
      "name": "cluster",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>A single instance of Node.js runs in a single thread. To take advantage of\nmulti-core systems the user will sometimes want to launch a cluster of Node.js\nprocesses to handle the load.</p>\n<p>The cluster module allows you to easily create child processes that\nall share server ports.</p>\n<pre><code class=\"lang-js\">const cluster = require(&#39;cluster&#39;);\nconst http = require(&#39;http&#39;);\nconst numCPUs = require(&#39;os&#39;).cpus().length;\n\nif (cluster.isMaster) {\n  // Fork workers.\n  for (var i = 0; i &lt; numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on(&#39;exit&#39;, (worker, code, signal) =&gt; {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this case it is an HTTP server\n  http.createServer((req, res) =&gt; {\n    res.writeHead(200);\n    res.end(&#39;hello world\\n&#39;);\n  }).listen(8000);\n}\n</code></pre>\n<p>Running Node.js will now share port 8000 between the workers:</p>\n<pre><code>$ NODE_DEBUG=cluster node server.js\n23521,Master Worker 23524 online\n23521,Master Worker 23526 online\n23521,Master Worker 23523 online\n23521,Master Worker 23528 online\n</code></pre><p>Please note that, on Windows, it is not yet possible to set up a named pipe\nserver in a worker.</p>\n",
      "miscs": [
        {
          "textRaw": "How It Works",
          "name": "How It Works",
          "type": "misc",
          "desc": "<p>The worker processes are spawned using the [<code>child_process.fork()</code>][] method,\nso that they can communicate with the parent via IPC and pass server\nhandles back and forth.</p>\n<p>The cluster module supports two methods of distributing incoming\nconnections.</p>\n<p>The first one (and the default one on all platforms except Windows),\nis the round-robin approach, where the master process listens on a\nport, accepts new connections and distributes them across the workers\nin a round-robin fashion, with some built-in smarts to avoid\noverloading a worker process.</p>\n<p>The second approach is where the master process creates the listen\nsocket and sends it to interested workers. The workers then accept\nincoming connections directly.</p>\n<p>The second approach should, in theory, give the best performance.\nIn practice however, distribution tends to be very unbalanced due\nto operating system scheduler vagaries. Loads have been observed\nwhere over 70% of all connections ended up in just two processes,\nout of a total of eight.</p>\n<p>Because <code>server.listen()</code> hands off most of the work to the master\nprocess, there are three cases where the behavior between a normal\nNode.js process and a cluster worker differs:</p>\n<ol>\n<li><code>server.listen({fd: 7})</code> Because the message is passed to the master,\nfile descriptor 7 <strong>in the parent</strong> will be listened on, and the\nhandle passed to the worker, rather than listening to the worker&#39;s\nidea of what the number 7 file descriptor references.</li>\n<li><code>server.listen(handle)</code> Listening on handles explicitly will cause\nthe worker to use the supplied handle, rather than talk to the master\nprocess.  If the worker already has the handle, then it&#39;s presumed\nthat you know what you are doing.</li>\n<li><code>server.listen(0)</code> Normally, this will cause servers to listen on a\nrandom port.  However, in a cluster, each worker will receive the\nsame &quot;random&quot; port each time they do <code>listen(0)</code>.  In essence, the\nport is random the first time, but predictable thereafter.  If you\nwant to listen on a unique port, generate a port number based on the\ncluster worker ID.</li>\n</ol>\n<p>There is no routing logic in Node.js, or in your program, and no shared\nstate between the workers.  Therefore, it is important to design your\nprogram such that it does not rely too heavily on in-memory data objects\nfor things like sessions and login.</p>\n<p>Because workers are all separate processes, they can be killed or\nre-spawned depending on your program&#39;s needs, without affecting other\nworkers.  As long as there are some workers still alive, the server will\ncontinue to accept connections.  If no workers are alive, existing connections\nwill be dropped and new connections will be refused.  Node.js does not\nautomatically manage the number of workers for you, however.  It is your\nresponsibility to manage the worker pool for your application&#39;s needs.</p>\n"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Worker",
          "type": "class",
          "name": "Worker",
          "desc": "<p>A Worker object contains all public information and method about a worker.\nIn the master it can be obtained using <code>cluster.workers</code>. In a worker\nit can be obtained using <code>cluster.worker</code>.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "desc": "<p>Similar to the <code>cluster.on(&#39;disconnect&#39;)</code> event, but specific to this worker.</p>\n<pre><code class=\"lang-js\">cluster.fork().on(&#39;disconnect&#39;, () =&gt; {\n  // Worker has disconnected\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<p>This event is the same as the one provided by [<code>child_process.fork()</code>][].</p>\n<p>In a worker you can also use <code>process.on(&#39;error&#39;)</code>.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "params": [],
              "desc": "<p>Similar to the <code>cluster.on(&#39;exit&#39;)</code> event, but specific to this worker.</p>\n<pre><code class=\"lang-js\">const worker = cluster.fork();\nworker.on(&#39;exit&#39;, (code, signal) =&gt; {\n  if (signal) {\n    console.log(`worker was killed by signal: ${signal}`);\n  } else if (code !== 0) {\n    console.log(`worker exited with error code: ${code}`);\n  } else {\n    console.log(&#39;worker success!&#39;);\n  }\n});\n</code></pre>\n"
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "params": [],
              "desc": "<p>Similar to the <code>cluster.on(&#39;listening&#39;)</code> event, but specific to this worker.</p>\n<pre><code class=\"lang-js\">cluster.fork().on(&#39;listening&#39;, (address) =&gt; {\n  // Worker is listening\n});\n</code></pre>\n<p>It is not emitted in the worker.</p>\n"
            },
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "params": [],
              "desc": "<p>Similar to the <code>cluster.on(&#39;message&#39;)</code> event, but specific to this worker. In a\nworker you can also use <code>process.on(&#39;message&#39;)</code>.</p>\n<p>See [<code>process</code> event: <code>&#39;message&#39;</code>][].</p>\n<p>As an example, here is a cluster that keeps count of the number of requests\nin the master process using the message system:</p>\n<pre><code class=\"lang-js\">const cluster = require(&#39;cluster&#39;);\nconst http = require(&#39;http&#39;);\n\nif (cluster.isMaster) {\n\n  // Keep track of http requests\n  var numReqs = 0;\n  setInterval(() =&gt; {\n    console.log(&#39;numReqs =&#39;, numReqs);\n  }, 1000);\n\n  // Count requests\n  function messageHandler(msg) {\n    if (msg.cmd &amp;&amp; msg.cmd == &#39;notifyRequest&#39;) {\n      numReqs += 1;\n    }\n  }\n\n  // Start workers and listen for messages containing notifyRequest\n  const numCPUs = require(&#39;os&#39;).cpus().length;\n  for (var i = 0; i &lt; numCPUs; i++) {\n    cluster.fork();\n  }\n\n  Object.keys(cluster.workers).forEach((id) =&gt; {\n    cluster.workers[id].on(&#39;message&#39;, messageHandler);\n  });\n\n} else {\n\n  // Worker processes have a http server.\n  http.Server((req, res) =&gt; {\n    res.writeHead(200);\n    res.end(&#39;hello world\\n&#39;);\n\n    // notify master about the request\n    process.send({ cmd: &#39;notifyRequest&#39; });\n  }).listen(8000);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "Event: 'online'",
              "type": "event",
              "name": "online",
              "desc": "<p>Similar to the <code>cluster.on(&#39;online&#39;)</code> event, but specific to this worker.</p>\n<pre><code class=\"lang-js\">cluster.fork().on(&#39;online&#39;, () =&gt; {\n  // Worker is online\n});\n</code></pre>\n<p>It is not emitted in the worker.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "worker.disconnect()",
              "type": "method",
              "name": "disconnect",
              "desc": "<p>In a worker, this function will close all servers, wait for the <code>&#39;close&#39;</code> event on\nthose servers, and then disconnect the IPC channel.</p>\n<p>In the master, an internal message is sent to the worker causing it to call\n<code>.disconnect()</code> on itself.</p>\n<p>Causes <code>.suicide</code> to be set.</p>\n<p>Note that after a server is closed, it will no longer accept new connections,\nbut connections may be accepted by any other listening worker. Existing\nconnections will be allowed to close as usual. When no more connections exist,\nsee [<code>server.close()</code>][], the IPC channel to the worker will close allowing it to\ndie gracefully.</p>\n<p>The above applies <em>only</em> to server connections, client connections are not\nautomatically closed by workers, and disconnect does not wait for them to close\nbefore exiting.</p>\n<p>Note that in a worker, <code>process.disconnect</code> exists, but it is not this function,\nit is [<code>disconnect</code>][].</p>\n<p>Because long living server connections may block workers from disconnecting, it\nmay be useful to send a message, so application specific actions may be taken to\nclose them. It also may be useful to implement a timeout, killing a worker if\nthe <code>&#39;disconnect&#39;</code> event has not been emitted after some time.</p>\n<pre><code class=\"lang-js\">if (cluster.isMaster) {\n  var worker = cluster.fork();\n  var timeout;\n\n  worker.on(&#39;listening&#39;, (address) =&gt; {\n    worker.send(&#39;shutdown&#39;);\n    worker.disconnect();\n    timeout = setTimeout(() =&gt; {\n      worker.kill();\n    }, 2000);\n  });\n\n  worker.on(&#39;disconnect&#39;, () =&gt; {\n    clearTimeout(timeout);\n  });\n\n} else if (cluster.isWorker) {\n  const net = require(&#39;net&#39;);\n  var server = net.createServer((socket) =&gt; {\n    // connections never end\n  });\n\n  server.listen(8000);\n\n  process.on(&#39;message&#39;, (msg) =&gt; {\n    if (msg === &#39;shutdown&#39;) {\n      // initiate graceful close of any connections to server\n    }\n  });\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "worker.isConnected()",
              "type": "method",
              "name": "isConnected",
              "desc": "<p>This function returns <code>true</code> if the worker is connected to its master via its IPC\nchannel, <code>false</code> otherwise. A worker is connected to its master after it&#39;s been\ncreated. It is disconnected after the <code>&#39;disconnect&#39;</code> event is emitted.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "worker.isDead()",
              "type": "method",
              "name": "isDead",
              "desc": "<p>This function returns <code>true</code> if the worker&#39;s process has terminated (either\nbecause of exiting or being signaled). Otherwise, it returns <code>false</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "worker.kill([signal='SIGTERM'])",
              "type": "method",
              "name": "kill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`signal` {String} Name of the kill signal to send to the worker process. ",
                      "name": "signal",
                      "type": "String",
                      "desc": "Name of the kill signal to send to the worker process.",
                      "optional": true,
                      "default": "'SIGTERM'"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true,
                      "default": "'SIGTERM'"
                    }
                  ]
                }
              ],
              "desc": "<p>This function will kill the worker. In the master, it does this by disconnecting\nthe <code>worker.process</code>, and once disconnected, killing with <code>signal</code>. In the\nworker, it does it by disconnecting the channel, and then exiting with code <code>0</code>.</p>\n<p>Causes <code>.suicide</code> to be set.</p>\n<p>This method is aliased as <code>worker.destroy()</code> for backwards compatibility.</p>\n<p>Note that in a worker, <code>process.kill()</code> exists, but it is not this function,\nit is [<code>kill</code>][].</p>\n"
            },
            {
              "textRaw": "worker.send(message[, sendHandle][, callback])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Boolean ",
                    "name": "return",
                    "desc": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle} ",
                      "name": "sendHandle",
                      "type": "Handle",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Send a message to a worker or master, optionally with a handle.</p>\n<p>In the master this sends a message to a specific worker. It is identical to\n[<code>ChildProcess.send()</code>][].</p>\n<p>In a worker this sends a message to the master. It is identical to\n<code>process.send()</code>.</p>\n<p>This example will echo back all messages from the master:</p>\n<pre><code class=\"lang-js\">if (cluster.isMaster) {\n  var worker = cluster.fork();\n  worker.send(&#39;hi there&#39;);\n\n} else if (cluster.isWorker) {\n  process.on(&#39;message&#39;, (msg) =&gt; {\n    process.send(msg);\n  });\n}\n</code></pre>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`id` {Number} ",
              "type": "Number",
              "name": "id",
              "desc": "<p>Each new worker is given its own unique id, this id is stored in the\n<code>id</code>.</p>\n<p>While a worker is alive, this is the key that indexes it in\ncluster.workers</p>\n"
            },
            {
              "textRaw": "`process` {ChildProcess} ",
              "type": "ChildProcess",
              "name": "process",
              "desc": "<p>All workers are created using [<code>child_process.fork()</code>][], the returned object\nfrom this function is stored as <code>.process</code>. In a worker, the global <code>process</code>\nis stored.</p>\n<p>See: [Child Process module][]</p>\n<p>Note that workers will call <code>process.exit(0)</code> if the <code>&#39;disconnect&#39;</code> event occurs\non <code>process</code> and <code>.suicide</code> is not <code>true</code>. This protects against accidental\ndisconnection.</p>\n"
            },
            {
              "textRaw": "`suicide` {Boolean} ",
              "type": "Boolean",
              "name": "suicide",
              "desc": "<p>Set by calling <code>.kill()</code> or <code>.disconnect()</code>, until then it is <code>undefined</code>.</p>\n<p>The boolean <code>worker.suicide</code> lets you distinguish between voluntary and accidental\nexit, the master may choose not to respawn a worker based on this value.</p>\n<pre><code class=\"lang-js\">cluster.on(&#39;exit&#39;, (worker, code, signal) =&gt; {\n  if (worker.suicide === true) {\n    console.log(&#39;Oh, it was just suicide\\&#39; â€“ no need to worry&#39;).\n  }\n});\n\n// kill worker\nworker.kill();\n</code></pre>\n"
            }
          ]
        }
      ],
      "events": [
        {
          "textRaw": "Event: 'disconnect'",
          "type": "event",
          "name": "disconnect",
          "params": [],
          "desc": "<p>Emitted after the worker IPC channel has disconnected. This can occur when a\nworker exits gracefully, is killed, or is disconnected manually (such as with\nworker.disconnect()).</p>\n<p>There may be a delay between the <code>&#39;disconnect&#39;</code> and <code>&#39;exit&#39;</code> events.  These events\ncan be used to detect if the process is stuck in a cleanup or if there are\nlong-living connections.</p>\n<pre><code class=\"lang-js\">cluster.on(&#39;disconnect&#39;, (worker) =&gt; {\n  console.log(`The worker #${worker.id} has disconnected`);\n});\n</code></pre>\n"
        },
        {
          "textRaw": "Event: 'exit'",
          "type": "event",
          "name": "exit",
          "params": [],
          "desc": "<p>When any of the workers die the cluster module will emit the <code>&#39;exit&#39;</code> event.</p>\n<p>This can be used to restart the worker by calling <code>.fork()</code> again.</p>\n<pre><code class=\"lang-js\">cluster.on(&#39;exit&#39;, (worker, code, signal) =&gt; {\n  console.log(&#39;worker %d died (%s). restarting...&#39;,\n    worker.process.pid, signal || code);\n  cluster.fork();\n});\n</code></pre>\n<p>See [child_process event: &#39;exit&#39;][].</p>\n"
        },
        {
          "textRaw": "Event: 'fork'",
          "type": "event",
          "name": "fork",
          "params": [],
          "desc": "<p>When a new worker is forked the cluster module will emit a <code>&#39;fork&#39;</code> event.\nThis can be used to log worker activity, and create your own timeout.</p>\n<pre><code class=\"lang-js\">var timeouts = [];\nfunction errorMsg() {\n  console.error(&#39;Something must be wrong with the connection ...&#39;);\n}\n\ncluster.on(&#39;fork&#39;, (worker) =&gt; {\n  timeouts[worker.id] = setTimeout(errorMsg, 2000);\n});\ncluster.on(&#39;listening&#39;, (worker, address) =&gt; {\n  clearTimeout(timeouts[worker.id]);\n});\ncluster.on(&#39;exit&#39;, (worker, code, signal) =&gt; {\n  clearTimeout(timeouts[worker.id]);\n  errorMsg();\n});\n</code></pre>\n"
        },
        {
          "textRaw": "Event: 'listening'",
          "type": "event",
          "name": "listening",
          "params": [],
          "desc": "<p>After calling <code>listen()</code> from a worker, when the <code>&#39;listening&#39;</code> event is emitted on\nthe server, a <code>&#39;listening&#39;</code> event will also be emitted on <code>cluster</code> in the master.</p>\n<p>The event handler is executed with two arguments, the <code>worker</code> contains the worker\nobject and the <code>address</code> object contains the following connection properties:\n<code>address</code>, <code>port</code> and <code>addressType</code>. This is very useful if the worker is listening\non more than one address.</p>\n<pre><code class=\"lang-js\">cluster.on(&#39;listening&#39;, (worker, address) =&gt; {\n  console.log(\n    `A worker is now connected to ${address.address}:${address.port}`);\n});\n</code></pre>\n<p>The <code>addressType</code> is one of:</p>\n<ul>\n<li><code>4</code> (TCPv4)</li>\n<li><code>6</code> (TCPv6)</li>\n<li><code>-1</code> (unix domain socket)</li>\n<li><code>&quot;udp4&quot;</code> or <code>&quot;udp6&quot;</code> (UDP v4 or v6)</li>\n</ul>\n"
        },
        {
          "textRaw": "Event: 'message'",
          "type": "event",
          "name": "message",
          "params": [],
          "desc": "<p>Emitted when any worker receives a message.</p>\n<p>See [child_process event: &#39;message&#39;][].</p>\n"
        },
        {
          "textRaw": "Event: 'online'",
          "type": "event",
          "name": "online",
          "params": [],
          "desc": "<p>After forking a new worker, the worker should respond with an online message.\nWhen the master receives an online message it will emit this event.\nThe difference between <code>&#39;fork&#39;</code> and <code>&#39;online&#39;</code> is that fork is emitted when the\nmaster forks a worker, and &#39;online&#39; is emitted when the worker is running.</p>\n<pre><code class=\"lang-js\">cluster.on(&#39;online&#39;, (worker) =&gt; {\n  console.log(&#39;Yay, the worker responded after it was forked&#39;);\n});\n</code></pre>\n"
        },
        {
          "textRaw": "Event: 'setup'",
          "type": "event",
          "name": "setup",
          "params": [],
          "desc": "<p>Emitted every time <code>.setupMaster()</code> is called.</p>\n<p>The <code>settings</code> object is the <code>cluster.settings</code> object at the time\n<code>.setupMaster()</code> was called and is advisory only, since multiple calls to\n<code>.setupMaster()</code> can be made in a single tick.</p>\n<p>If accuracy is important, use <code>cluster.settings</code>.</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "cluster.disconnect([callback])",
          "type": "method",
          "name": "disconnect",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} called when all workers are disconnected and handles are closed ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "called when all workers are disconnected and handles are closed",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Calls <code>.disconnect()</code> on each worker in <code>cluster.workers</code>.</p>\n<p>When they are disconnected all internal handles will be closed, allowing the\nmaster process to die gracefully if no other event is waiting.</p>\n<p>The method takes an optional callback argument which will be called when finished.</p>\n<p>This can only be called from the master process.</p>\n"
        },
        {
          "textRaw": "cluster.fork([env])",
          "type": "method",
          "name": "fork",
          "signatures": [
            {
              "return": {
                "textRaw": "return {cluster.Worker} ",
                "name": "return",
                "type": "cluster.Worker"
              },
              "params": [
                {
                  "textRaw": "`env` {Object} Key/value pairs to add to worker process environment. ",
                  "name": "env",
                  "type": "Object",
                  "desc": "Key/value pairs to add to worker process environment.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "env",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Spawn a new worker process.</p>\n<p>This can only be called from the master process.</p>\n"
        },
        {
          "textRaw": "cluster.setupMaster([settings])",
          "type": "method",
          "name": "setupMaster",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`settings` {Object} ",
                  "options": [
                    {
                      "textRaw": "`exec` {String} file path to worker file.  (Default=`process.argv[1]`) ",
                      "name": "exec",
                      "default": "process.argv[1]",
                      "type": "String",
                      "desc": "file path to worker file."
                    },
                    {
                      "textRaw": "`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) ",
                      "name": "args",
                      "default": "process.argv.slice(2)",
                      "type": "Array",
                      "desc": "string arguments passed to worker."
                    },
                    {
                      "textRaw": "`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) ",
                      "name": "silent",
                      "default": "false",
                      "type": "Boolean",
                      "desc": "whether or not to send output to parent's stdio."
                    }
                  ],
                  "name": "settings",
                  "type": "Object",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "settings",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p><code>setupMaster</code> is used to change the default &#39;fork&#39; behavior. Once called,\nthe settings will be present in <code>cluster.settings</code>.</p>\n<p>Note that:</p>\n<ul>\n<li>any settings changes only affect future calls to <code>.fork()</code> and have no\neffect on workers that are already running</li>\n<li>The <em>only</em> attribute of a worker that cannot be set via <code>.setupMaster()</code> is\nthe <code>env</code> passed to <code>.fork()</code></li>\n<li>the defaults above apply to the first call only, the defaults for later\ncalls is the current value at the time of <code>cluster.setupMaster()</code> is called</li>\n</ul>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const cluster = require(&#39;cluster&#39;);\ncluster.setupMaster({\n  exec: &#39;worker.js&#39;,\n  args: [&#39;--use&#39;, &#39;https&#39;],\n  silent: true\n});\ncluster.fork(); // https worker\ncluster.setupMaster({\n  exec: &#39;worker.js&#39;,\n  args: [&#39;--use&#39;, &#39;http&#39;]\n});\ncluster.fork(); // http worker\n</code></pre>\n<p>This can only be called from the master process.</p>\n"
        }
      ],
      "properties": [
        {
          "textRaw": "`isMaster` {Boolean} ",
          "type": "Boolean",
          "name": "isMaster",
          "desc": "<p>True if the process is a master. This is determined\nby the <code>process.env.NODE_UNIQUE_ID</code>. If <code>process.env.NODE_UNIQUE_ID</code> is\nundefined, then <code>isMaster</code> is <code>true</code>.</p>\n"
        },
        {
          "textRaw": "`isWorker` {Boolean} ",
          "type": "Boolean",
          "name": "isWorker",
          "desc": "<p>True if the process is not a master (it is the negation of <code>cluster.isMaster</code>).</p>\n"
        },
        {
          "textRaw": "cluster.schedulingPolicy",
          "name": "schedulingPolicy",
          "desc": "<p>The scheduling policy, either <code>cluster.SCHED_RR</code> for round-robin or\n<code>cluster.SCHED_NONE</code> to leave it to the operating system. This is a\nglobal setting and effectively frozen once you spawn the first worker\nor call <code>cluster.setupMaster()</code>, whatever comes first.</p>\n<p><code>SCHED_RR</code> is the default on all operating systems except Windows.\nWindows will change to <code>SCHED_RR</code> once libuv is able to effectively\ndistribute IOCP handles without incurring a large performance hit.</p>\n<p><code>cluster.schedulingPolicy</code> can also be set through the\n<code>NODE_CLUSTER_SCHED_POLICY</code> environment variable. Valid\nvalues are <code>&quot;rr&quot;</code> and <code>&quot;none&quot;</code>.</p>\n"
        },
        {
          "textRaw": "`settings` {Object} ",
          "type": "Object",
          "name": "settings",
          "options": [
            {
              "textRaw": "`execArgv` {Array} list of string arguments passed to the Node.js executable. (Default=`process.execArgv`) ",
              "name": "execArgv",
              "default": "process.execArgv",
              "type": "Array",
              "desc": "list of string arguments passed to the Node.js executable."
            },
            {
              "textRaw": "`exec` {String} file path to worker file.  (Default=`process.argv[1]`) ",
              "name": "exec",
              "default": "process.argv[1]",
              "type": "String",
              "desc": "file path to worker file."
            },
            {
              "textRaw": "`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) ",
              "name": "args",
              "default": "process.argv.slice(2)",
              "type": "Array",
              "desc": "string arguments passed to worker."
            },
            {
              "textRaw": "`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) ",
              "name": "silent",
              "default": "false",
              "type": "Boolean",
              "desc": "whether or not to send output to parent's stdio."
            },
            {
              "textRaw": "`uid` {Number} Sets the user identity of the process. (See setuid(2).) ",
              "name": "uid",
              "type": "Number",
              "desc": "Sets the user identity of the process. (See setuid(2).)"
            },
            {
              "textRaw": "`gid` {Number} Sets the group identity of the process. (See setgid(2).) ",
              "name": "gid",
              "type": "Number",
              "desc": "Sets the group identity of the process. (See setgid(2).)"
            }
          ],
          "desc": "<p>After calling <code>.setupMaster()</code> (or <code>.fork()</code>) this settings object will contain\nthe settings, including the default values.</p>\n<p>This object is not supposed to be changed or set manually, by you.</p>\n"
        },
        {
          "textRaw": "`worker` {Object} ",
          "type": "Object",
          "name": "worker",
          "desc": "<p>A reference to the current worker object. Not available in the master process.</p>\n<pre><code class=\"lang-js\">const cluster = require(&#39;cluster&#39;);\n\nif (cluster.isMaster) {\n  console.log(&#39;I am master&#39;);\n  cluster.fork();\n  cluster.fork();\n} else if (cluster.isWorker) {\n  console.log(`I am worker #${cluster.worker.id}`);\n}\n</code></pre>\n"
        },
        {
          "textRaw": "`workers` {Object} ",
          "type": "Object",
          "name": "workers",
          "desc": "<p>A hash that stores the active worker objects, keyed by <code>id</code> field. Makes it\neasy to loop through all the workers. It is only available in the master\nprocess.</p>\n<p>A worker is removed from cluster.workers after the worker has disconnected <em>and</em>\nexited. The order between these two events cannot be determined in advance.\nHowever, it is guaranteed that the removal from the cluster.workers list happens\nbefore last <code>&#39;disconnect&#39;</code> or <code>&#39;exit&#39;</code> event is emitted.</p>\n<pre><code class=\"lang-js\">// Go through all workers\nfunction eachWorker(callback) {\n  for (var id in cluster.workers) {\n    callback(cluster.workers[id]);\n  }\n}\neachWorker((worker) =&gt; {\n  worker.send(&#39;big announcement to all workers&#39;);\n});\n</code></pre>\n<p>Should you wish to reference a worker over a communication channel, using\nthe worker&#39;s unique id is the easiest way to find the worker.</p>\n<pre><code class=\"lang-js\">socket.on(&#39;data&#39;, (id) =&gt; {\n  var worker = cluster.workers[id];\n});\n</code></pre>\n<!-- [end-include:cluster.md] -->\n<!-- [start-include:cli.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "Cluster"
    },
    {
      "textRaw": "Console",
      "name": "console",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>console</code> module provides a simple debugging console that is similar to the\nJavaScript console mechanism provided by web browsers.</p>\n<p>The module exports two specific components:</p>\n<ul>\n<li>A <code>Console</code> class with methods such as <code>console.log()</code>, <code>console.error()</code> and\n<code>console.warn()</code> that can be used to write to any Node.js stream.</li>\n<li>A global <code>console</code> instance configured to write to <code>stdout</code> and <code>stderr</code>.\nBecause this object is global, it can be used without calling\n<code>require(&#39;console&#39;)</code>.</li>\n</ul>\n<p>Example using the global <code>console</code>:</p>\n<pre><code class=\"lang-js\">console.log(&#39;hello world&#39;);\n  // Prints: hello world, to stdout\nconsole.log(&#39;hello %s&#39;, &#39;world&#39;);\n  // Prints: hello world, to stdout\nconsole.error(new Error(&#39;Whoops, something bad happened&#39;));\n  // Prints: [Error: Whoops, something bad happened], to stderr\n\nconst name = &#39;Will Robinson&#39;;\nconsole.warn(`Danger ${name}! Danger!`);\n  // Prints: Danger Will Robinson! Danger!, to stderr\n</code></pre>\n<p>Example using the <code>Console</code> class:</p>\n<pre><code class=\"lang-js\">const out = getStreamSomehow();\nconst err = getStreamSomehow();\nconst myConsole = new console.Console(out, err);\n\nmyConsole.log(&#39;hello world&#39;);\n  // Prints: hello world, to out\nmyConsole.log(&#39;hello %s&#39;, &#39;world&#39;);\n  // Prints: hello world, to out\nmyConsole.error(new Error(&#39;Whoops, something bad happened&#39;));\n  // Prints: [Error: Whoops, something bad happened], to err\n\nconst name = &#39;Will Robinson&#39;;\nmyConsole.warn(`Danger ${name}! Danger!`);\n  // Prints: Danger Will Robinson! Danger!, to err\n</code></pre>\n<p>While the API for the <code>Console</code> class is designed fundamentally around the\nbrowser <code>console</code> object, the <code>Console</code> in Node.js is <em>not</em> intended to\nduplicate the browser&#39;s functionality exactly.</p>\n",
      "modules": [
        {
          "textRaw": "Asynchronous vs Synchronous Consoles",
          "name": "asynchronous_vs_synchronous_consoles",
          "desc": "<p>The console functions are usually asynchronous unless the destination is a file.\nDisks are fast and operating systems normally employ write-back caching;\nit should be a very rare occurrence indeed that a write blocks, but it\nis possible.</p>\n<p>Additionally, console functions are blocking when outputting to TTYs\n(terminals) on OS X as a workaround for the OS&#39;s very small, 1kb buffer size.\nThis is to prevent interleaving between <code>stdout</code> and <code>stderr</code>.</p>\n",
          "type": "module",
          "displayName": "Asynchronous vs Synchronous Consoles"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Console",
          "type": "class",
          "name": "Console",
          "desc": "<p>The <code>Console</code> class can be used to create a simple logger with configurable\noutput streams and can be accessed using either <code>require(&#39;console&#39;).Console</code>\nor <code>console.Console</code>:</p>\n<pre><code class=\"lang-js\">const Console = require(&#39;console&#39;).Console;\nconst Console = console.Console;\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "console.assert(value[, message][, ...])",
              "type": "method",
              "name": "assert",
              "meta": {
                "added": [
                  "v0.1.101"
                ]
              },
              "desc": "<p>A simple assertion test that verifies whether <code>value</code> is truthy. If it is not,\nan <code>AssertionError</code> is thrown. If provided, the error <code>message</code> is formatted\nusing [<code>util.format()</code>][] and used as the error message.</p>\n<pre><code class=\"lang-js\">console.assert(true, &#39;does nothing&#39;);\n  // OK\nconsole.assert(false, &#39;Whoops %s&#39;, &#39;didn\\&#39;t work&#39;);\n  // AssertionError: Whoops didn&#39;t work\n</code></pre>\n<p><em>Note: the <code>console.assert()</code> method is implemented differently in Node.js\nthan the <code>console.assert()</code> method [available in browsers][web-api-assert].</em></p>\n<p>Specifically, in browsers, calling <code>console.assert()</code> with a falsy\nassertion will cause the <code>message</code> to be printed to the console without\ninterrupting execution of subsequent code. In Node.js, however, a falsy\nassertion will cause an <code>AssertionError</code> to be thrown.</p>\n<p>Functionality approximating that implemented by browsers can be implemented\nby extending Node.js&#39; <code>console</code> and overriding the <code>console.assert()</code> method.</p>\n<p>In the following example, a simple module is created that extends and overrides\nthe default behavior of <code>console</code> in Node.js.</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\n\n// Creates a simple extension of console with a\n// new impl for assert without monkey-patching.\nconst myConsole = Object.setPrototypeOf({\n  assert(assertion, message, ...args) {\n    try {\n      console.assert(assertion, message, ...args);\n    } catch (err) {\n      console.error(err.stack);\n    }\n  }\n}, console);\n\nmodule.exports = myConsole;\n</code></pre>\n<p>This can then be used as a direct replacement for the built in console:</p>\n<pre><code class=\"lang-js\">const console = require(&#39;./myConsole&#39;);\nconsole.assert(false, &#39;this message will print, but no error thrown&#39;);\nconsole.log(&#39;this will also print&#39;);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "message",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.dir(obj[, options])",
              "type": "method",
              "name": "dir",
              "meta": {
                "added": [
                  "v0.1.101"
                ]
              },
              "desc": "<p>Uses [<code>util.inspect()</code>][] on <code>obj</code> and prints the resulting string to <code>stdout</code>.\nThis function bypasses any custom <code>inspect()</code> function defined on <code>obj</code>. An\noptional <code>options</code> object may be passed to alter certain aspects of the\nformatted string:</p>\n<ul>\n<li><p><code>showHidden</code> - if <code>true</code> then the object&#39;s non-enumerable and symbol\nproperties will be shown too. Defaults to <code>false</code>.</p>\n</li>\n<li><p><code>depth</code> - tells [<code>util.inspect()</code>][] how many times to recurse while\nformatting the object. This is useful for inspecting large complicated objects.\nDefaults to <code>2</code>. To make it recurse indefinitely, pass <code>null</code>.</p>\n</li>\n<li><p><code>colors</code> - if <code>true</code>, then the output will be styled with ANSI color codes.\nDefaults to <code>false</code>. Colors are customizable; see\n[customizing <code>util.inspect()</code> colors][].</p>\n</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "obj"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.error([data][, ...])",
              "type": "method",
              "name": "error",
              "meta": {
                "added": [
                  "v0.1.100"
                ]
              },
              "desc": "<p>Prints to <code>stderr</code> with newline. Multiple arguments can be passed, with the\nfirst used as the primary message and all additional used as substitution\nvalues similar to <code>printf(3)</code> (the arguments are all passed to\n[<code>util.format()</code>][]).</p>\n<pre><code class=\"lang-js\">const code = 5;\nconsole.error(&#39;error #%d&#39;, code);\n  // Prints: error #5, to stderr\nconsole.error(&#39;error&#39;, code);\n  // Prints: error 5, to stderr\n</code></pre>\n<p>If formatting elements (e.g. <code>%d</code>) are not found in the first string then\n[<code>util.inspect()</code>][] is called on each argument and the resulting string\nvalues are concatenated. See [<code>util.format()</code>][] for more information.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.info([data][, ...])",
              "type": "method",
              "name": "info",
              "meta": {
                "added": [
                  "v0.1.100"
                ]
              },
              "desc": "<p>The <code>console.info()</code> function is an alias for [<code>console.log()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.log([data][, ...])",
              "type": "method",
              "name": "log",
              "meta": {
                "added": [
                  "v0.1.100"
                ]
              },
              "desc": "<p>Prints to <code>stdout</code> with newline. Multiple arguments can be passed, with the\nfirst used as the primary message and all additional used as substitution\nvalues similar to <code>printf(3)</code> (the arguments are all passed to\n[<code>util.format()</code>][]).</p>\n<pre><code class=\"lang-js\">var count = 5;\nconsole.log(&#39;count: %d&#39;, count);\n  // Prints: count: 5, to stdout\nconsole.log(&#39;count: &#39;, count);\n  // Prints: count: 5, to stdout\n</code></pre>\n<p>If formatting elements (e.g. <code>%d</code>) are not found in the first string then\n[<code>util.inspect()</code>][] is called on each argument and the resulting string\nvalues are concatenated. See [<code>util.format()</code>][] for more information.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.time(label)",
              "type": "method",
              "name": "time",
              "meta": {
                "added": [
                  "v0.1.104"
                ]
              },
              "desc": "<p>Used to calculate the duration of a specific operation. To start a timer, call\nthe <code>console.time()</code> method, giving it a unique <code>label</code> as the only parameter. To stop the\ntimer, and to get the elapsed time in milliseconds, just call the\n[<code>console.timeEnd()</code>][] method, again passing the\ntimer&#39;s unique <code>label</code> as the parameter.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.timeEnd(label)",
              "type": "method",
              "name": "timeEnd",
              "meta": {
                "added": [
                  "v0.1.104"
                ]
              },
              "desc": "<p>Stops a timer that was previously started by calling [<code>console.time()</code>][] and\nprints the result to stdout:</p>\n<pre><code class=\"lang-js\">console.time(&#39;100-elements&#39;);\nfor (var i = 0; i &lt; 100; i++) {\n  ;\n}\nconsole.timeEnd(&#39;100-elements&#39;);\n// prints 100-elements: 262ms\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.trace(message[, ...])",
              "type": "method",
              "name": "trace",
              "meta": {
                "added": [
                  "v0.1.104"
                ]
              },
              "desc": "<p>Prints to <code>stderr</code> the string <code>&#39;Trace :&#39;</code>, followed by the [<code>util.format()</code>][]\nformatted message and stack trace to the current position in the code.</p>\n<pre><code class=\"lang-js\">console.trace(&#39;Show me&#39;);\n  // Prints: (stack trace will vary based on where trace is called)\n  //  Trace: Show me\n  //    at repl:2:9\n  //    at REPLServer.defaultEval (repl.js:248:27)\n  //    at bound (domain.js:287:14)\n  //    at REPLServer.runBound [as eval] (domain.js:300:12)\n  //    at REPLServer.&lt;anonymous&gt; (repl.js:412:12)\n  //    at emitOne (events.js:82:20)\n  //    at REPLServer.emit (events.js:169:7)\n  //    at REPLServer.Interface._onLine (readline.js:210:10)\n  //    at REPLServer.Interface._line (readline.js:549:8)\n  //    at REPLServer.Interface._ttyWrite (readline.js:826:14)\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.warn([data][, ...])",
              "type": "method",
              "name": "warn",
              "meta": {
                "added": [
                  "v0.1.100"
                ]
              },
              "desc": "<p>The <code>console.warn()</code> function is an alias for [<code>console.error()</code>][].</p>\n<!-- [end-include:console.md] -->\n<!-- [start-include:crypto.md] -->\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "stdout"
                },
                {
                  "name": "stderr",
                  "optional": true
                }
              ],
              "desc": "<p>Creates a new <code>Console</code> by passing one or two writable stream instances.\n<code>stdout</code> is a writable stream to print log or info output. <code>stderr</code>\nis used for warning or error output. If <code>stderr</code> isn&#39;t passed, warning and error\noutput will be sent to <code>stdout</code>.</p>\n<pre><code class=\"lang-js\">const output = fs.createWriteStream(&#39;./stdout.log&#39;);\nconst errorOutput = fs.createWriteStream(&#39;./stderr.log&#39;);\n// custom simple logger\nconst logger = new Console(output, errorOutput);\n// use it like console\nvar count = 5;\nlogger.log(&#39;count: %d&#39;, count);\n// in stdout.log: count 5\n</code></pre>\n<p>The global <code>console</code> is a special <code>Console</code> whose output is sent to\n[<code>process.stdout</code>][] and [<code>process.stderr</code>][]. It is equivalent to calling:</p>\n<pre><code class=\"lang-js\">new Console(process.stdout, process.stderr);\n</code></pre>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Console"
    },
    {
      "textRaw": "Crypto",
      "name": "crypto",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>crypto</code> module provides cryptographic functionality that includes a set of\nwrappers for OpenSSL&#39;s hash, HMAC, cipher, decipher, sign and verify functions.</p>\n<p>Use <code>require(&#39;crypto&#39;)</code> to access this module.</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\n\nconst secret = &#39;abcdefg&#39;;\nconst hash = crypto.createHmac(&#39;sha256&#39;, secret)\n                   .update(&#39;I love cupcakes&#39;)\n                   .digest(&#39;hex&#39;);\nconsole.log(hash);\n  // Prints:\n  //   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n</code></pre>\n",
      "classes": [
        {
          "textRaw": "Class: Certificate",
          "type": "class",
          "name": "Certificate",
          "desc": "<p>SPKAC is a Certificate Signing Request mechanism originally implemented by\nNetscape and now specified formally as part of [HTML5&#39;s <code>keygen</code> element][].</p>\n<p>The <code>crypto</code> module provides the <code>Certificate</code> class for working with SPKAC\ndata. The most common usage is handling output generated by the HTML5\n<code>&lt;keygen&gt;</code> element. Node.js uses [OpenSSL&#39;s SPKAC implementation][] internally.</p>\n",
          "methods": [
            {
              "textRaw": "new crypto.Certificate()",
              "type": "method",
              "name": "Certificate",
              "desc": "<p>Instances of the <code>Certificate</code> class can be created using the <code>new</code> keyword\nor by calling <code>crypto.Certificate()</code> as a function:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\n\nconst cert1 = new crypto.Certificate();\nconst cert2 = crypto.Certificate();\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "certificate.exportChallenge(spkac)",
              "type": "method",
              "name": "exportChallenge",
              "desc": "<p>The <code>spkac</code> data structure includes a public key and a challenge. The\n<code>certificate.exportChallenge()</code> returns the challenge component in the\nform of a Node.js [<code>Buffer</code>][]. The <code>spkac</code> argument can be either a string\nor a [<code>Buffer</code>][].</p>\n<pre><code class=\"lang-js\">const cert = require(&#39;crypto&#39;).Certificate();\nconst spkac = getSpkacSomehow();\nconst challenge = cert.exportChallenge(spkac);\nconsole.log(challenge.toString(&#39;utf8&#39;));\n  // Prints the challenge as a UTF8 string\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "spkac"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "certificate.exportPublicKey(spkac)",
              "type": "method",
              "name": "exportPublicKey",
              "desc": "<p>The <code>spkac</code> data structure includes a public key and a challenge. The\n<code>certificate.exportPublicKey()</code> returns the public key component in the\nform of a Node.js [<code>Buffer</code>][]. The <code>spkac</code> argument can be either a string\nor a [<code>Buffer</code>][].</p>\n<pre><code class=\"lang-js\">const cert = require(&#39;crypto&#39;).Certificate();\nconst spkac = getSpkacSomehow();\nconst publicKey = cert.exportPublicKey(spkac);\nconsole.log(publicKey);\n  // Prints the public key as &lt;Buffer ...&gt;\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "spkac"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "certificate.verifySpkac(spkac)",
              "type": "method",
              "name": "verifySpkac",
              "desc": "<p>Returns <code>true</code> if the given <code>spkac</code> data structure is valid, <code>false</code> otherwise.\nThe <code>spkac</code> argument must be a Node.js [<code>Buffer</code>][].</p>\n<pre><code class=\"lang-js\">const cert = require(&#39;crypto&#39;).Certificate();\nconst spkac = getSpkacSomehow();\nconsole.log(cert.verifySpkac(new Buffer(spkac)));\n  // Prints true or false\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "spkac"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "desc": "<p>Instances of the <code>Cipher</code> class are used to encrypt data. The class can be\nused in one of two ways:</p>\n<ul>\n<li>As a [stream][] that is both readable and writable, where plain unencrypted\ndata is written to produce encrypted data on the readable side, or</li>\n<li>Using the [<code>cipher.update()</code>][] and [<code>cipher.final()</code>][] methods to produce\nthe encrypted data.</li>\n</ul>\n<p>The [<code>crypto.createCipher()</code>][] or [<code>crypto.createCipheriv()</code>][] methods are\nused to create <code>Cipher</code> instances. <code>Cipher</code> objects are not to be created\ndirectly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Cipher</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst cipher = crypto.createCipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar encrypted = &#39;&#39;;\ncipher.on(&#39;readable&#39;, () =&gt; {\n  var data = cipher.read();\n  if (data)\n    encrypted += data.toString(&#39;hex&#39;);\n});\ncipher.on(&#39;end&#39;, () =&gt; {\n  console.log(encrypted);\n  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n});\n\ncipher.write(&#39;some clear text data&#39;);\ncipher.end();\n</code></pre>\n<p>Example: Using <code>Cipher</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst cipher = crypto.createCipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nconst input = fs.createReadStream(&#39;test.js&#39;);\nconst output = fs.createWriteStream(&#39;test.enc&#39;);\n\ninput.pipe(cipher).pipe(output);\n</code></pre>\n<p>Example: Using the [<code>cipher.update()</code>][] and [<code>cipher.final()</code>][] methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst cipher = crypto.createCipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar encrypted = cipher.update(&#39;some clear text data&#39;, &#39;utf8&#39;, &#39;hex&#39;);\nencrypted += cipher.final(&#39;hex&#39;);\nconsole.log(encrypted);\n  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<p>Returns any remaining enciphered contents. If <code>output_encoding</code>\nparameter is one of <code>&#39;binary&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>, a string is returned.\nIf an <code>output_encoding</code> is not provided, a [<code>Buffer</code>][] is returned.</p>\n<p>Once the <code>cipher.final()</code> method has been called, the <code>Cipher</code> object can no\nlonger be used to encrypt data. Attempts to call <code>cipher.final()</code> more than\nonce will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAAD(buffer)",
              "type": "method",
              "name": "setAAD",
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>cipher.setAAD()</code> method sets the value used for the\n<em>additional authenticated data</em> (AAD) input parameter.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.getAuthTag()",
              "type": "method",
              "name": "getAuthTag",
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>cipher.getAuthTag()</code> method returns a [<code>Buffer</code>][] containing\nthe <em>authentication tag</em> that has been computed from the given data.</p>\n<p>The <code>cipher.getAuthTag()</code> method should only be called after encryption has\nbeen completed using the [<code>cipher.final()</code>][] method.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<p>When using block encryption algorithms, the <code>Cipher</code> class will automatically\nadd padding to the input data to the appropriate block size. To disable the\ndefault padding call <code>cipher.setAutoPadding(false)</code>.</p>\n<p>When <code>auto_padding</code> is <code>false</code>, the length of the entire input data must be a\nmultiple of the cipher&#39;s block size or [<code>cipher.final()</code>][] will throw an Error.\nDisabling automatic padding is useful for non-standard padding, for instance\nusing <code>0x0</code> instead of PKCS padding.</p>\n<p>The <code>cipher.setAutoPadding()</code> method must be called before [<code>cipher.final()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.update(data[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the cipher with <code>data</code>. If the <code>input_encoding</code> argument is given,\nit&#39;s value must be one of <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code>, or <code>&#39;binary&#39;</code> and the <code>data</code>\nargument is a string using the specified encoding. If the <code>input_encoding</code>\nargument is not given, <code>data</code> must be a [<code>Buffer</code>][]. If <code>data</code> is a\n[<code>Buffer</code>][] then <code>input_encoding</code> is ignored.</p>\n<p>The <code>output_encoding</code> specifies the output format of the enciphered\ndata, and can be <code>&#39;binary&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>. If the <code>output_encoding</code>\nis specified, a string using the specified encoding is returned. If no\n<code>output_encoding</code> is provided, a [<code>Buffer</code>][] is returned.</p>\n<p>The <code>cipher.update()</code> method can be called multiple times with new data until\n[<code>cipher.final()</code>][] is called. Calling <code>cipher.update()</code> after\n[<code>cipher.final()</code>][] will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "desc": "<p>Instances of the <code>Decipher</code> class are used to decrypt data. The class can be\nused in one of two ways:</p>\n<ul>\n<li>As a [stream][] that is both readable and writable, where plain encrypted\ndata is written to produce unencrypted data on the readable side, or</li>\n<li>Using the [<code>decipher.update()</code>][] and [<code>decipher.final()</code>][] methods to\nproduce the unencrypted data.</li>\n</ul>\n<p>The [<code>crypto.createDecipher()</code>][] or [<code>crypto.createDecipheriv()</code>][] methods are\nused to create <code>Decipher</code> instances. <code>Decipher</code> objects are not to be created\ndirectly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Decipher</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst decipher = crypto.createDecipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar decrypted = &#39;&#39;;\ndecipher.on(&#39;readable&#39;, () =&gt; {\n  var data = decipher.read();\n  if (data)\n  decrypted += data.toString(&#39;utf8&#39;);\n});\ndecipher.on(&#39;end&#39;, () =&gt; {\n  console.log(decrypted);\n  // Prints: some clear text data\n});\n\nvar encrypted = &#39;ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#39;;\ndecipher.write(encrypted, &#39;hex&#39;);\ndecipher.end();\n</code></pre>\n<p>Example: Using <code>Decipher</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst decipher = crypto.createDecipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nconst input = fs.createReadStream(&#39;test.enc&#39;);\nconst output = fs.createWriteStream(&#39;test.js&#39;);\n\ninput.pipe(decipher).pipe(output);\n</code></pre>\n<p>Example: Using the [<code>decipher.update()</code>][] and [<code>decipher.final()</code>][] methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst decipher = crypto.createDecipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar encrypted = &#39;ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#39;;\nvar decrypted = decipher.update(encrypted, &#39;hex&#39;, &#39;utf8&#39;);\ndecrypted += decipher.final(&#39;utf8&#39;);\nconsole.log(decrypted);\n  // Prints: some clear text data\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<p>Returns any remaining deciphered contents. If <code>output_encoding</code>\nparameter is one of <code>&#39;binary&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>, a string is returned.\nIf an <code>output_encoding</code> is not provided, a [<code>Buffer</code>][] is returned.</p>\n<p>Once the <code>decipher.final()</code> method has been called, the <code>Decipher</code> object can\nno longer be used to decrypt data. Attempts to call <code>decipher.final()</code> more\nthan once will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAAD(buffer)",
              "type": "method",
              "name": "setAAD",
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>cipher.setAAD()</code> method sets the value used for the\n<em>additional authenticated data</em> (AAD) input parameter.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAuthTag(buffer)",
              "type": "method",
              "name": "setAuthTag",
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>decipher.setAuthTag()</code> method is used to pass in the\nreceived <em>authentication tag</em>. If no tag is provided, or if the cipher text\nhas been tampered with, [<code>decipher.final()</code>][] with throw, indicating that the\ncipher text should be discarded due to failed authentication.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<p>When data has been encrypted without standard block padding, calling\n<code>decipher.setAutoPadding(false)</code> will disable automatic padding to prevent\n[<code>decipher.final()</code>][] from checking for and removing padding.</p>\n<p>Turning auto padding off will only work if the input data&#39;s length is a\nmultiple of the ciphers block size.</p>\n<p>The <code>decipher.setAutoPadding()</code> method must be called before\n[<code>decipher.update()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.update(data[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the decipher with <code>data</code>. If the <code>input_encoding</code> argument is given,\nit&#39;s value must be one of <code>&#39;binary&#39;</code>, <code>&#39;base64&#39;</code>, or <code>&#39;hex&#39;</code> and the <code>data</code>\nargument is a string using the specified encoding. If the <code>input_encoding</code>\nargument is not given, <code>data</code> must be a [<code>Buffer</code>][]. If <code>data</code> is a\n[<code>Buffer</code>][] then <code>input_encoding</code> is ignored.</p>\n<p>The <code>output_encoding</code> specifies the output format of the enciphered\ndata, and can be <code>&#39;binary&#39;</code>, <code>&#39;ascii&#39;</code> or <code>&#39;utf8&#39;</code>. If the <code>output_encoding</code>\nis specified, a string using the specified encoding is returned. If no\n<code>output_encoding</code> is provided, a [<code>Buffer</code>][] is returned.</p>\n<p>The <code>decipher.update()</code> method can be called multiple times with new data until\n[<code>decipher.final()</code>][] is called. Calling <code>decipher.update()</code> after\n[<code>decipher.final()</code>][] will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "desc": "<p>The <code>DiffieHellman</code> class is a utility for creating Diffie-Hellman key\nexchanges.</p>\n<p>Instances of the <code>DiffieHellman</code> class can be created using the\n[<code>crypto.createDiffieHellman()</code>][] function.</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst assert = require(&#39;assert&#39;);\n\n// Generate Alice&#39;s keys...\nconst alice = crypto.createDiffieHellman(2048);\nconst alice_key = alice.generateKeys();\n\n// Generate Bob&#39;s keys...\nconst bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());\nconst bob_key = bob.generateKeys();\n\n// Exchange and generate the secret...\nconst alice_secret = alice.computeSecret(bob_key);\nconst bob_secret = bob.computeSecret(alice_key);\n\n// OK\nassert.equal(alice_secret.toString(&#39;hex&#39;), bob_secret.toString(&#39;hex&#39;));\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<p>Computes the shared secret using <code>other_public_key</code> as the other\nparty&#39;s public key and returns the computed shared secret. The supplied\nkey is interpreted using the specified <code>input_encoding</code>, and secret is\nencoded using specified <code>output_encoding</code>. Encodings can be\n<code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If the <code>input_encoding</code> is not\nprovided, <code>other_public_key</code> is expected to be a [<code>Buffer</code>][].</p>\n<p>If <code>output_encoding</code> is given a string is returned; otherwise, a\n[<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<p>Generates private and public Diffie-Hellman key values, and returns\nthe public key in the specified <code>encoding</code>. This key should be\ntransferred to the other party. Encoding can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>,\nor <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a string is returned; otherwise a\n[<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "desc": "<p>Returns the Diffie-Hellman generator in the specified <code>encoding</code>, which can\nbe <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If  <code>encoding</code> is provided a string is\nreturned; otherwise a [<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "desc": "<p>Returns the Diffie-Hellman prime in the specified <code>encoding</code>, which can\nbe <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a string is\nreturned; otherwise a [<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<p>Returns the Diffie-Hellman private key in the specified <code>encoding</code>,\nwhich can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a\nstring is returned; otherwise a [<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<p>Returns the Diffie-Hellman public key in the specified <code>encoding</code>, which\ncan be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a\nstring is returned; otherwise a [<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(private_key[, encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<p>Sets the Diffie-Hellman private key. If the <code>encoding</code> argument is provided\nand is either <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>, <code>private_key</code> is expected\nto be a string. If no <code>encoding</code> is provided, <code>private_key</code> is expected\nto be a [<code>Buffer</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key[, encoding])",
              "type": "method",
              "name": "setPublicKey",
              "desc": "<p>Sets the Diffie-Hellman public key. If the <code>encoding</code> argument is provided\nand is either <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>, <code>public_key</code> is expected\nto be a string. If no <code>encoding</code> is provided, <code>public_key</code> is expected\nto be a [<code>Buffer</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "diffieHellman.verifyError",
              "name": "verifyError",
              "desc": "<p>A bit field containing any warnings and/or errors resulting from a check\nperformed during initialization of the <code>DiffieHellman</code> object.</p>\n<p>The following values are valid for this property (as defined in <code>constants</code>\nmodule):</p>\n<ul>\n<li><code>DH_CHECK_P_NOT_SAFE_PRIME</code></li>\n<li><code>DH_CHECK_P_NOT_PRIME</code></li>\n<li><code>DH_UNABLE_TO_CHECK_GENERATOR</code></li>\n<li><code>DH_NOT_SUITABLE_GENERATOR</code></li>\n</ul>\n"
            }
          ]
        },
        {
          "textRaw": "Class: ECDH",
          "type": "class",
          "name": "ECDH",
          "desc": "<p>The <code>ECDH</code> class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH)\nkey exchanges.</p>\n<p>Instances of the <code>ECDH</code> class can be created using the\n[<code>crypto.createECDH()</code>][] function.</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst assert = require(&#39;assert&#39;);\n\n// Generate Alice&#39;s keys...\nconst alice = crypto.createECDH(&#39;secp521r1&#39;);\nconst alice_key = alice.generateKeys();\n\n// Generate Bob&#39;s keys...\nconst bob = crypto.createECDH(&#39;secp521r1&#39;);\nconst bob_key = bob.generateKeys();\n\n// Exchange and generate the secret...\nconst alice_secret = alice.computeSecret(bob_key);\nconst bob_secret = bob.computeSecret(alice_key);\n\nassert(alice_secret, bob_secret);\n  // OK\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "ecdh.computeSecret(other_public_key[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<p>Computes the shared secret using <code>other_public_key</code> as the other\nparty&#39;s public key and returns the computed shared secret. The supplied\nkey is interpreted using specified <code>input_encoding</code>, and the returned secret\nis encoded using the specified <code>output_encoding</code>. Encodings can be\n<code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If the <code>input_encoding</code> is not\nprovided, <code>other_public_key</code> is expected to be a [<code>Buffer</code>][].</p>\n<p>If <code>output_encoding</code> is given a string will be returned; otherwise a\n[<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.generateKeys([encoding[, format]])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<p>Generates private and public EC Diffie-Hellman key values, and returns\nthe public key in the specified <code>format</code> and <code>encoding</code>. This key should be\ntransferred to the other party.</p>\n<p>The <code>format</code> arguments specifies point encoding and can be <code>&#39;compressed&#39;</code>,\n<code>&#39;uncompressed&#39;</code>, or <code>&#39;hybrid&#39;</code>. If <code>format</code> is not specified, the point will\nbe returned in <code>&#39;uncompressed&#39;</code> format.</p>\n<p>The <code>encoding</code> argument can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If\n<code>encoding</code> is provided a string is returned; otherwise a [<code>Buffer</code>][]\nis returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "format",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<p>Returns the EC Diffie-Hellman private key in the specified <code>encoding</code>,\nwhich can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided\na string is returned; otherwise a [<code>Buffer</code>][] is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.getPublicKey([encoding[, format]])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<p>Returns the EC Diffie-Hellman public key in the specified <code>encoding</code> and\n<code>format</code>.</p>\n<p>The <code>format</code> argument specifies point encoding and can be <code>&#39;compressed&#39;</code>,\n<code>&#39;uncompressed&#39;</code>, or <code>&#39;hybrid&#39;</code>. If <code>format</code> is not specified the point will be\nreturned in <code>&#39;uncompressed&#39;</code> format.</p>\n<p>The <code>encoding</code> argument can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If\n<code>encoding</code> is specified, a string is returned; otherwise a [<code>Buffer</code>][] is\nreturned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "format",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.setPrivateKey(private_key[, encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<p>Sets the EC Diffie-Hellman private key. The <code>encoding</code> can be <code>&#39;binary&#39;</code>,\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided, <code>private_key</code> is expected\nto be a string; otherwise <code>private_key</code> is expected to be a [<code>Buffer</code>][]. If\n<code>private_key</code> is not valid for the curve specified when the <code>ECDH</code> object was\ncreated, an error is thrown. Upon setting the private key, the associated\npublic point (key) is also generated and set in the ECDH object.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.setPublicKey(public_key[, encoding])",
              "type": "method",
              "name": "setPublicKey",
              "stability": 0,
              "stabilityText": "Deprecated",
              "desc": "<p>Sets the EC Diffie-Hellman public key. Key encoding can be <code>&#39;binary&#39;</code>,\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided <code>public_key</code> is expected to\nbe a string; otherwise a [<code>Buffer</code>][] is expected.</p>\n<p>Note that there is not normally a reason to call this method because <code>ECDH</code>\nonly requires a private key and the other party&#39;s public key to compute the\nshared secret. Typically either [<code>ecdh.generateKeys()</code>][] or\n[<code>ecdh.setPrivateKey()</code>][] will be called. The [<code>ecdh.setPrivateKey()</code>][] method\nattempts to generate the public point/key associated with the private key being\nset.</p>\n<p>Example (obtaining a shared secret):</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst alice = crypto.createECDH(&#39;secp256k1&#39;);\nconst bob = crypto.createECDH(&#39;secp256k1&#39;);\n\n// Note: This is a shortcut way to specify one of Alice&#39;s previous private\n// keys. It would be unwise to use such a predictable private key in a real\n// application.\nalice.setPrivateKey(\n  crypto.createHash(&#39;sha256&#39;).update(&#39;alice&#39;, &#39;utf8&#39;).digest()\n);\n\n// Bob uses a newly generated cryptographically strong\n// pseudorandom key pair bob.generateKeys();\n\nconst alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\nconst bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\n\n// alice_secret and bob_secret should be the same shared secret value\nconsole.log(alice_secret === bob_secret);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hash",
          "type": "class",
          "name": "Hash",
          "desc": "<p>The <code>Hash</code> class is a utility for creating hash digests of data. It can be\nused in one of two ways:</p>\n<ul>\n<li>As a [stream][] that is both readable and writable, where data is written\nto produce a computed hash digest on the readable side, or</li>\n<li>Using the [<code>hash.update()</code>][] and [<code>hash.digest()</code>][] methods to produce the\ncomputed hash.</li>\n</ul>\n<p>The [<code>crypto.createHash()</code>][] method is used to create <code>Hash</code> instances. <code>Hash</code>\nobjects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Hash</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nhash.on(&#39;readable&#39;, () =&gt; {\n  var data = hash.read();\n  if (data)\n    console.log(data.toString(&#39;hex&#39;));\n    // Prints:\n    //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50\n});\n\nhash.write(&#39;some data to hash&#39;);\nhash.end();\n</code></pre>\n<p>Example: Using <code>Hash</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nconst input = fs.createReadStream(&#39;test.js&#39;);\ninput.pipe(hash).pipe(process.stdout);\n</code></pre>\n<p>Example: Using the [<code>hash.update()</code>][] and [<code>hash.digest()</code>][] methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nhash.update(&#39;some data to hash&#39;);\nconsole.log(hash.digest(&#39;hex&#39;));\n  // Prints:\n  //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<p>Calculates the digest of all of the data passed to be hashed (using the\n[<code>hash.update()</code>][] method). The <code>encoding</code> can be <code>&#39;hex&#39;</code>, <code>&#39;binary&#39;</code> or\n<code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a string will be returned; otherwise\na [<code>Buffer</code>][] is returned.</p>\n<p>The <code>Hash</code> object can not be used again after <code>hash.digest()</code> method has been\ncalled. Multiple calls will cause an error to be thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the hash content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;binary&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;binary&#39;</code> is enforced. If <code>data</code> is a [<code>Buffer</code>][] then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "desc": "<p>The <code>Hmac</code> Class is a utility for creating cryptographic HMAC digests. It can\nbe used in one of two ways:</p>\n<ul>\n<li>As a [stream][] that is both readable and writable, where data is written\nto produce a computed HMAC digest on the readable side, or</li>\n<li>Using the [<code>hmac.update()</code>][] and [<code>hmac.digest()</code>][] methods to produce the\ncomputed HMAC digest.</li>\n</ul>\n<p>The [<code>crypto.createHmac()</code>][] method is used to create <code>Hmac</code> instances. <code>Hmac</code>\nobjects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Hmac</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nhmac.on(&#39;readable&#39;, () =&gt; {\n  var data = hmac.read();\n  if (data)\n    console.log(data.toString(&#39;hex&#39;));\n    // Prints:\n    //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e\n});\n\nhmac.write(&#39;some data to hash&#39;);\nhmac.end();\n</code></pre>\n<p>Example: Using <code>Hmac</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nconst input = fs.createReadStream(&#39;test.js&#39;);\ninput.pipe(hmac).pipe(process.stdout);\n</code></pre>\n<p>Example: Using the [<code>hmac.update()</code>][] and [<code>hmac.digest()</code>][] methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nhmac.update(&#39;some data to hash&#39;);\nconsole.log(hmac.digest(&#39;hex&#39;));\n  // Prints:\n  //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "hmac.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<p>Calculates the HMAC digest of all of the data passed using [<code>hmac.update()</code>][].\nThe <code>encoding</code> can be <code>&#39;hex&#39;</code>, <code>&#39;binary&#39;</code> or <code>&#39;base64&#39;</code>. If <code>encoding</code> is\nprovided a string is returned; otherwise a [<code>Buffer</code>][] is returned;</p>\n<p>The <code>Hmac</code> object can not be used again after <code>hmac.digest()</code> has been\ncalled. Multiple calls to <code>hmac.digest()</code> will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the <code>Hmac</code> content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;binary&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a [<code>Buffer</code>][] then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Sign",
          "type": "class",
          "name": "Sign",
          "desc": "<p>The <code>Sign</code> Class is a utility for generating signatures. It can be used in one\nof two ways:</p>\n<ul>\n<li>As a writable [stream][], where data to be signed is written and the\n[<code>sign.sign()</code>][] method is used to generate and return the signature, or</li>\n<li>Using the [<code>sign.update()</code>][] and [<code>sign.sign()</code>][] methods to produce the\nsignature.</li>\n</ul>\n<p>The [<code>crypto.createSign()</code>][] method is used to create <code>Sign</code> instances. <code>Sign</code>\nobjects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Sign</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst sign = crypto.createSign(&#39;RSA-SHA256&#39;);\n\nsign.write(&#39;some data to sign&#39;);\nsign.end();\n\nconst private_key = getPrivateKeySomehow();\nconsole.log(sign.sign(private_key, &#39;hex&#39;));\n  // Prints the calculated signature\n</code></pre>\n<p>Example: Using the [<code>sign.update()</code>][] and [<code>sign.sign()</code>][] methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst sign = crypto.createSign(&#39;RSA-SHA256&#39;);\n\nsign.update(&#39;some data to sign&#39;);\n\nconst private_key = getPrivateKeySomehow();\nconsole.log(sign.sign(private_key, &#39;hex&#39;));\n  // Prints the calculated signature\n</code></pre>\n<p>A <code>Sign</code> instance can also be created by just passing in the digest\nalgorithm name, in which case OpenSSL will infer the full signature algorithm\nfrom the type of the PEM-formatted private key, including algorithms that\ndo not have directly exposed name constants, e.g. &#39;ecdsa-with-SHA256&#39;.</p>\n<p>Example: signing using ECDSA with SHA256</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst sign = crypto.createSign(&#39;sha256&#39;);\n\nsign.update(&#39;some data to sign&#39;);\n\nconst private_key = &#39;-----BEGIN EC PRIVATE KEY-----\\n&#39; +\n        &#39;MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\\n&#39; +\n        &#39;AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\\n&#39; +\n        &#39;pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\\n&#39; +\n        &#39;-----END EC PRIVATE KEY-----\\n&#39;;\n\nconsole.log(sign.sign(private_key).toString(&#39;hex&#39;));\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "sign.sign(private_key[, output_format])",
              "type": "method",
              "name": "sign",
              "desc": "<p>Calculates the signature on all the data passed through using either\n[<code>sign.update()</code>][] or [<code>sign.write()</code>][stream-writable-write].</p>\n<p>The <code>private_key</code> argument can be an object or a string. If <code>private_key</code> is a\nstring, it is treated as a raw key with no passphrase. If <code>private_key</code> is an\nobject, it is interpreted as a hash containing two properties:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - passphrase for the private key</li>\n</ul>\n<p>The <code>output_format</code> can specify one of <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If\n<code>output_format</code> is provided a string is returned; otherwise a [<code>Buffer</code>][] is\nreturned.</p>\n<p>The <code>Sign</code> object can not be again used after <code>sign.sign()</code> method has been\ncalled. Multiple calls to <code>sign.sign()</code> will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sign.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the <code>Sign</code> content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;binary&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a [<code>Buffer</code>][] then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "desc": "<p>The <code>Verify</code> class is a utility for verifying signatures. It can be used in one\nof two ways:</p>\n<ul>\n<li>As a writable [stream][] where written data is used to validate against the\nsupplied signature, or</li>\n<li><p>Using the [<code>verify.update()</code>][] and [<code>verify.verify()</code>][] methods to verify\nthe signature.</p>\n<p>The [<code>crypto.createSign()</code>][] method is used to create <code>Sign</code> instances.\n<code>Sign</code> objects are not to be created directly using the <code>new</code> keyword.</p>\n</li>\n</ul>\n<p>Example: Using <code>Verify</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst verify = crypto.createVerify(&#39;RSA-SHA256&#39;);\n\nverify.write(&#39;some data to sign&#39;);\nverify.end();\n\nconst public_key = getPublicKeySomehow();\nconst signature = getSignatureToVerify();\nconsole.log(verify.verify(public_key, signature));\n  // Prints true or false\n</code></pre>\n<p>Example: Using the [<code>verify.update()</code>][] and [<code>verify.verify()</code>][] methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst verify = crypto.createVerify(&#39;RSA-SHA256&#39;);\n\nverify.update(&#39;some data to sign&#39;);\n\nconst public_key = getPublicKeySomehow();\nconst signature = getSignatureToVerify();\nconsole.log(verify.verify(public_key, signature));\n  // Prints true or false\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the <code>Verify</code> content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;binary&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a [<code>Buffer</code>][] then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(object, signature[, signature_format])",
              "type": "method",
              "name": "verify",
              "desc": "<p>Verifies the provided data using the given <code>object</code> and <code>signature</code>.\nThe <code>object</code> argument is a string containing a PEM encoded object, which can be\none an RSA public key, a DSA public key, or an X.509 certificate.\nThe <code>signature</code> argument is the previously calculated signature for the data, in\nthe <code>signature_format</code> which can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>.\nIf a <code>signature_format</code> is specified, the <code>signature</code> is expected to be a\nstring; otherwise <code>signature</code> is expected to be a [<code>Buffer</code>][].</p>\n<p>Returns <code>true</code> or <code>false</code> depending on the validity of the signature for\nthe data and public key.</p>\n<p>The <code>verifier</code> object can not be used again after <code>verify.verify()</code> has been\ncalled. Multiple calls to <code>verify.verify()</code> will result in an error being\nthrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "`crypto` module methods and properties",
          "name": "`crypto`_module_methods_and_properties",
          "properties": [
            {
              "textRaw": "crypto.DEFAULT_ENCODING",
              "name": "DEFAULT_ENCODING",
              "desc": "<p>The default encoding to use for functions that can take either strings\nor [buffers][<code>Buffer</code>]. The default value is <code>&#39;buffer&#39;</code>, which makes methods\ndefault to [<code>Buffer</code>][] objects.</p>\n<p>The <code>crypto.DEFAULT_ENCODING</code> mechanism is provided for backwards compatibility\nwith legacy programs that expect <code>&#39;binary&#39;</code> to be the default encoding.</p>\n<p>New applications should expect the default to be <code>&#39;buffer&#39;</code>. This property may\nbecome deprecated in a future Node.js release.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "crypto.createCipher(algorithm, password)",
              "type": "method",
              "name": "createCipher",
              "desc": "<p>Creates and returns a <code>Cipher</code> object that uses the given <code>algorithm</code> and\n<code>password</code>.</p>\n<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On\nrecent OpenSSL releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.</p>\n<p>The <code>password</code> is used to derive the cipher key and initialization vector (IV).\nThe value must be either a <code>&#39;binary&#39;</code> encoded string or a [<code>Buffer</code>][].</p>\n<p>The implementation of <code>crypto.createCipher()</code> derives keys using the OpenSSL\nfunction [<code>EVP_BytesToKey</code>][] with the digest algorithm set to MD5, one\niteration, and no salt. The lack of salt allows dictionary attacks as the same\npassword always creates the same key. The low iteration count and\nnon-cryptographically secure hash algorithm allow passwords to be tested very\nrapidly.</p>\n<p>In line with OpenSSL&#39;s recommendation to use pbkdf2 instead of\n[<code>EVP_BytesToKey</code>][] it is recommended that developers derive a key and IV on\ntheir own using [<code>crypto.pbkdf2()</code>][] and to use [<code>crypto.createCipheriv()</code>][]\nto create the <code>Cipher</code> object.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "password"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
              "type": "method",
              "name": "createCipheriv",
              "desc": "<p>Creates and returns a <code>Cipher</code> object, with the given <code>algorithm</code>, <code>key</code> and\ninitialization vector (<code>iv</code>).</p>\n<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On\nrecent OpenSSL releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.</p>\n<p>The <code>key</code> is the raw key used by the <code>algorithm</code> and <code>iv</code> is an\n[initialization vector][]. Both arguments must be <code>&#39;binary&#39;</code> encoded strings or\n[buffers][<code>Buffer</code>].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    },
                    {
                      "name": "iv"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createCredentials(details)",
              "type": "method",
              "name": "createCredentials",
              "stability": 0,
              "stabilityText": "Deprecated: Use [`tls.createSecureContext()`][] instead.",
              "desc": "<p>The <code>crypto.createCredentials()</code> method is a deprecated alias for creating\nand returning a <code>tls.SecureContext</code> object. The <code>crypto.createCredentials()</code>\nmethod should not be used.</p>\n<p>The optional <code>details</code> argument is a hash object with keys:</p>\n<ul>\n<li><code>pfx</code> : {String|Buffer} - PFX or PKCS12 encoded private\nkey, certificate and CA certificates</li>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - passphrase for the private key or PFX</li>\n<li><code>cert</code> : {String} - PEM encoded certificate</li>\n<li><code>ca</code> : {String|Array} - Either a string or array of strings of PEM encoded CA\ncertificates to trust.</li>\n<li><code>crl</code> : {String|Array} - Either a string or array of strings of PEM encoded CRLs\n(Certificate Revocation List)</li>\n<li><code>ciphers</code>: {String} using the [OpenSSL cipher list format][] describing the\ncipher algorithms to use or exclude.</li>\n</ul>\n<p>If no &#39;ca&#39; details are given, Node.js will use Mozilla&#39;s default\n[publicly trusted list of CAs][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "details"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDecipher(algorithm, password)",
              "type": "method",
              "name": "createDecipher",
              "desc": "<p>Creates and returns a <code>Decipher</code> object that uses the given <code>algorithm</code> and\n<code>password</code> (key).</p>\n<p>The implementation of <code>crypto.createDecipher()</code> derives keys using the OpenSSL\nfunction [<code>EVP_BytesToKey</code>][] with the digest algorithm set to MD5, one\niteration, and no salt. The lack of salt allows dictionary attacks as the same\npassword always creates the same key. The low iteration count and\nnon-cryptographically secure hash algorithm allow passwords to be tested very\nrapidly.</p>\n<p>In line with OpenSSL&#39;s recommendation to use pbkdf2 instead of\n[<code>EVP_BytesToKey</code>][] it is recommended that developers derive a key and IV on\ntheir own using [<code>crypto.pbkdf2()</code>][] and to use [<code>crypto.createDecipheriv()</code>][]\nto create the <code>Decipher</code> object.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "password"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDecipheriv(algorithm, key, iv)",
              "type": "method",
              "name": "createDecipheriv",
              "desc": "<p>Creates and returns a <code>Decipher</code> object that uses the given <code>algorithm</code>, <code>key</code>\nand initialization vector (<code>iv</code>).</p>\n<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On\nrecent OpenSSL releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.</p>\n<p>The <code>key</code> is the raw key used by the <code>algorithm</code> and <code>iv</code> is an\n[initialization vector][]. Both arguments must be <code>&#39;binary&#39;</code> encoded strings or\n[buffers][<code>Buffer</code>].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    },
                    {
                      "name": "iv"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])",
              "type": "method",
              "name": "createDiffieHellman",
              "desc": "<p>Creates a <code>DiffieHellman</code> key exchange object using the supplied <code>prime</code> and an\noptional specific <code>generator</code>.</p>\n<p>The <code>generator</code> argument can be a number, string, or [<code>Buffer</code>][]. If\n<code>generator</code> is not specified, the value <code>2</code> is used.</p>\n<p>The <code>prime_encoding</code> and <code>generator_encoding</code> arguments can be <code>&#39;binary&#39;</code>,\n<code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>.</p>\n<p>If <code>prime_encoding</code> is specified, <code>prime</code> is expected to be a string; otherwise\na [<code>Buffer</code>][] is expected.</p>\n<p>If <code>generator_encoding</code> is specified, <code>generator</code> is expected to be a string;\notherwise either a number or [<code>Buffer</code>][] is expected.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prime"
                    },
                    {
                      "name": "prime_encoding",
                      "optional": true
                    },
                    {
                      "name": "generator",
                      "optional": true
                    },
                    {
                      "name": "generator_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDiffieHellman(prime_length[, generator])",
              "type": "method",
              "name": "createDiffieHellman",
              "desc": "<p>Creates a <code>DiffieHellman</code> key exchange object and generates a prime of\n<code>prime_length</code> bits using an optional specific numeric <code>generator</code>.\nIf <code>generator</code> is not specified, the value <code>2</code> is used.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prime_length"
                    },
                    {
                      "name": "generator",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createECDH(curve_name)",
              "type": "method",
              "name": "createECDH",
              "desc": "<p>Creates an Elliptic Curve Diffie-Hellman (<code>ECDH</code>) key exchange object using a\npredefined curve specified by the <code>curve_name</code> string. Use\n[<code>crypto.getCurves()</code>][] to obtain a list of available curve names. On recent\nOpenSSL releases, <code>openssl ecparam -list_curves</code> will also display the name\nand description of each available elliptic curve.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "curve_name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createHash(algorithm)",
              "type": "method",
              "name": "createHash",
              "desc": "<p>Creates and returns a <code>Hash</code> object that can be used to generate hash digests\nusing the given <code>algorithm</code>.</p>\n<p>The <code>algorithm</code> is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are <code>&#39;sha256&#39;</code>, <code>&#39;sha512&#39;</code>, etc.\nOn recent releases of OpenSSL, <code>openssl list-message-digest-algorithms</code> will\ndisplay the available digest algorithms.</p>\n<p>Example: generating the sha256 sum of a file</p>\n<pre><code class=\"lang-js\">const filename = process.argv[2];\nconst crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nconst input = fs.createReadStream(filename);\ninput.on(&#39;readable&#39;, () =&gt; {\n  var data = input.read();\n  if (data)\n    hash.update(data);\n  else {\n    console.log(`${hash.digest(&#39;hex&#39;)} ${filename}`);\n  }\n});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createHmac(algorithm, key)",
              "type": "method",
              "name": "createHmac",
              "desc": "<p>Creates and returns an <code>Hmac</code> object that uses the given <code>algorithm</code> and <code>key</code>.</p>\n<p>The <code>algorithm</code> is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are <code>&#39;sha256&#39;</code>, <code>&#39;sha512&#39;</code>, etc.\nOn recent releases of OpenSSL, <code>openssl list-message-digest-algorithms</code> will\ndisplay the available digest algorithms.</p>\n<p>The <code>key</code> is the HMAC key used to generate the cryptographic HMAC hash.</p>\n<p>Example: generating the sha256 HMAC of a file</p>\n<pre><code class=\"lang-js\">const filename = process.argv[2];\nconst crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nconst input = fs.createReadStream(filename);\ninput.on(&#39;readable&#39;, () =&gt; {\n  var data = input.read();\n  if (data)\n    hmac.update(data);\n  else {\n    console.log(`${hmac.digest(&#39;hex&#39;)} ${filename}`);\n  }\n});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createSign(algorithm)",
              "type": "method",
              "name": "createSign",
              "desc": "<p>Creates and returns a <code>Sign</code> object that uses the given <code>algorithm</code>. On\nrecent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will\ndisplay the available signing algorithms. One example is <code>&#39;RSA-SHA256&#39;</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createVerify(algorithm)",
              "type": "method",
              "name": "createVerify",
              "desc": "<p>Creates and returns a <code>Verify</code> object that uses the given algorithm. On\nrecent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will\ndisplay the available signing algorithms. One example is <code>&#39;RSA-SHA256&#39;</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.getCiphers()",
              "type": "method",
              "name": "getCiphers",
              "desc": "<p>Returns an array with the names of the supported cipher algorithms.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const ciphers = crypto.getCiphers();\nconsole.log(ciphers); // [&#39;aes-128-cbc&#39;, &#39;aes-128-ccm&#39;, ...]\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "crypto.getCurves()",
              "type": "method",
              "name": "getCurves",
              "desc": "<p>Returns an array with the names of the supported elliptic curves.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const curves = crypto.getCurves();\nconsole.log(curves); // [&#39;secp256k1&#39;, &#39;secp384r1&#39;, ...]\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "crypto.getDiffieHellman(group_name)",
              "type": "method",
              "name": "getDiffieHellman",
              "desc": "<p>Creates a predefined <code>DiffieHellman</code> key exchange object. The\nsupported groups are: <code>&#39;modp1&#39;</code>, <code>&#39;modp2&#39;</code>, <code>&#39;modp5&#39;</code> (defined in\n[RFC 2412][], but see [Caveats][]) and <code>&#39;modp14&#39;</code>, <code>&#39;modp15&#39;</code>,\n<code>&#39;modp16&#39;</code>, <code>&#39;modp17&#39;</code>, <code>&#39;modp18&#39;</code> (defined in [RFC 3526][]). The\nreturned object mimics the interface of objects created by\n[<code>crypto.createDiffieHellman()</code>][], but will not allow changing\nthe keys (with [<code>diffieHellman.setPublicKey()</code>][] for example). The\nadvantage of using this method is that the parties do not have to\ngenerate nor exchange a group modulus beforehand, saving both processor\nand communication time.</p>\n<p>Example (obtaining a shared secret):</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst alice = crypto.getDiffieHellman(&#39;modp14&#39;);\nconst bob = crypto.getDiffieHellman(&#39;modp14&#39;);\n\nalice.generateKeys();\nbob.generateKeys();\n\nconst alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\nconst bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "group_name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.getHashes()",
              "type": "method",
              "name": "getHashes",
              "desc": "<p>Returns an array with the names of the supported hash algorithms.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const hashes = crypto.getHashes();\nconsole.log(hashes); // [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen[, digest], callback)",
              "type": "method",
              "name": "pbkdf2",
              "desc": "<p>Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)\nimplementation. A selected HMAC digest algorithm specified by <code>digest</code> is\napplied to derive a key of the requested byte length (<code>keylen</code>) from the\n<code>password</code>, <code>salt</code> and <code>iterations</code>. If the <code>digest</code> algorithm is not specified,\na default of <code>&#39;sha1&#39;</code> is used.</p>\n<p>The supplied <code>callback</code> function is called with two arguments: <code>err</code> and\n<code>derivedKey</code>. If an error occurs, <code>err</code> will be set; otherwise <code>err</code> will be\nnull. The successfully generated <code>derivedKey</code> will be passed as a [<code>Buffer</code>][].</p>\n<p>The <code>iterations</code> argument must be a number set as high as possible. The\nhigher the number of iterations, the more secure the derived key will be,\nbut will take a longer amount of time to complete.</p>\n<p>The <code>salt</code> should also be as unique as possible. It is recommended that the\nsalts are random and their lengths are greater than 16 bytes. See\n[NIST SP 800-132][] for details.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\ncrypto.pbkdf2(&#39;secret&#39;, &#39;salt&#39;, 100000, 512, &#39;sha512&#39;, (err, key) =&gt; {\n  if (err) throw err;\n  console.log(key.toString(&#39;hex&#39;));  // &#39;c5e478d...1469e50&#39;\n});\n</code></pre>\n<p>An array of supported digest functions can be retrieved using\n[<code>crypto.getHashes()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "password"
                    },
                    {
                      "name": "salt"
                    },
                    {
                      "name": "iterations"
                    },
                    {
                      "name": "keylen"
                    },
                    {
                      "name": "digest",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.pbkdf2Sync(password, salt, iterations, keylen[, digest])",
              "type": "method",
              "name": "pbkdf2Sync",
              "desc": "<p>Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2)\nimplementation. A selected HMAC digest algorithm specified by <code>digest</code> is\napplied to derive a key of the requested byte length (<code>keylen</code>) from the\n<code>password</code>, <code>salt</code> and <code>iterations</code>. If the <code>digest</code> algorithm is not specified,\na default of <code>&#39;sha1&#39;</code> is used.</p>\n<p>If an error occurs an Error will be thrown, otherwise the derived key will be\nreturned as a [<code>Buffer</code>][].</p>\n<p>The <code>iterations</code> argument must be a number set as high as possible. The\nhigher the number of iterations, the more secure the derived key will be,\nbut will take a longer amount of time to complete.</p>\n<p>The <code>salt</code> should also be as unique as possible. It is recommended that the\nsalts are random and their lengths are greater than 16 bytes. See\n[NIST SP 800-132][] for details.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst key = crypto.pbkdf2Sync(&#39;secret&#39;, &#39;salt&#39;, 100000, 512, &#39;sha512&#39;);\nconsole.log(key.toString(&#39;hex&#39;));  // &#39;c5e478d...1469e50&#39;\n</code></pre>\n<p>An array of supported digest functions can be retrieved using\n[<code>crypto.getHashes()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "password"
                    },
                    {
                      "name": "salt"
                    },
                    {
                      "name": "iterations"
                    },
                    {
                      "name": "keylen"
                    },
                    {
                      "name": "digest",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.privateDecrypt(private_key, buffer)",
              "type": "method",
              "name": "privateDecrypt",
              "desc": "<p>Decrypts <code>buffer</code> with <code>private_key</code>.</p>\n<p><code>private_key</code> can be an object or a string. If <code>private_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_OAEP_PADDING</code>.\nIf <code>private_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>constants.RSA_NO_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>All paddings are defined in the <code>constants</code> module.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.privateEncrypt(private_key, buffer)",
              "type": "method",
              "name": "privateEncrypt",
              "desc": "<p>Encrypts <code>buffer</code> with <code>private_key</code>.</p>\n<p><code>private_key</code> can be an object or a string. If <code>private_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_PADDING</code>.\nIf <code>private_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>constants.RSA_NO_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>All paddings are defined in the <code>constants</code> module.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.publicDecrypt(public_key, buffer)",
              "type": "method",
              "name": "publicDecrypt",
              "desc": "<p>Decrypts <code>buffer</code> with <code>public_key</code>.</p>\n<p><code>public_key</code> can be an object or a string. If <code>public_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_PADDING</code>.\nIf <code>public_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded public key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>constants.RSA_NO_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>Because RSA public keys can be derived from private keys, a private key may\nbe passed instead of a public key.</p>\n<p>All paddings are defined in the <code>constants</code> module.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.publicEncrypt(public_key, buffer)",
              "type": "method",
              "name": "publicEncrypt",
              "desc": "<p>Encrypts <code>buffer</code> with <code>public_key</code>.</p>\n<p><code>public_key</code> can be an object or a string. If <code>public_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_OAEP_PADDING</code>.\nIf <code>public_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded public key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>constants.RSA_NO_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_PADDING</code></li>\n<li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>Because RSA public keys can be derived from private keys, a private key may\nbe passed instead of a public key.</p>\n<p>All paddings are defined in the <code>constants</code> module.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.randomBytes(size[, callback])",
              "type": "method",
              "name": "randomBytes",
              "desc": "<p>Generates cryptographically strong pseudo-random data. The <code>size</code> argument\nis a number indicating the number of bytes to generate.</p>\n<p>If a <code>callback</code> function is provided, the bytes are generated asynchronously\nand the <code>callback</code> function is invoked with two arguments: <code>err</code> and <code>buf</code>.\nIf an error occurs, <code>err</code> will be an Error object; otherwise it is null. The\n<code>buf</code> argument is a [<code>Buffer</code>][] containing the generated bytes.</p>\n<pre><code class=\"lang-js\">// Asynchronous\nconst crypto = require(&#39;crypto&#39;);\ncrypto.randomBytes(256, (err, buf) =&gt; {\n  if (err) throw err;\n  console.log(`${buf.length} bytes of random data: ${buf.toString(&#39;hex&#39;)}`);\n});\n</code></pre>\n<p>If the <code>callback</code> function is not provided, the random bytes are generated\nsynchronously and returned as a [<code>Buffer</code>][]. An error will be thrown if\nthere is a problem generating the bytes.</p>\n<pre><code class=\"lang-js\">// Synchronous\nconst buf = crypto.randomBytes(256);\nconsole.log(\n  `${buf.length} bytes of random data: ${buf.toString(&#39;hex&#39;)}`);\n</code></pre>\n<p>The <code>crypto.randomBytes()</code> method will block until there is sufficient entropy.\nThis should normally never take longer than a few milliseconds. The only time\nwhen generating the random bytes may conceivably block for a longer period of\ntime is right after boot, when the whole system is still low on entropy.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.setEngine(engine[, flags])",
              "type": "method",
              "name": "setEngine",
              "desc": "<p>Load and set the <code>engine</code> for some or all OpenSSL functions (selected by flags).</p>\n<p><code>engine</code> could be either an id or a path to the engine&#39;s shared library.</p>\n<p>The optional <code>flags</code> argument uses <code>ENGINE_METHOD_ALL</code> by default. The <code>flags</code>\nis a bit field taking one of or a mix of the following flags (defined in the\n<code>constants</code> module):</p>\n<ul>\n<li><code>ENGINE_METHOD_RSA</code></li>\n<li><code>ENGINE_METHOD_DSA</code></li>\n<li><code>ENGINE_METHOD_DH</code></li>\n<li><code>ENGINE_METHOD_RAND</code></li>\n<li><code>ENGINE_METHOD_ECDH</code></li>\n<li><code>ENGINE_METHOD_ECDSA</code></li>\n<li><code>ENGINE_METHOD_CIPHERS</code></li>\n<li><code>ENGINE_METHOD_DIGESTS</code></li>\n<li><code>ENGINE_METHOD_STORE</code></li>\n<li><code>ENGINE_METHOD_PKEY_METH</code></li>\n<li><code>ENGINE_METHOD_PKEY_ASN1_METH</code></li>\n<li><code>ENGINE_METHOD_ALL</code></li>\n<li><code>ENGINE_METHOD_NONE</code></li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "engine"
                    },
                    {
                      "name": "flags",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "`crypto` module methods and properties"
        },
        {
          "textRaw": "Notes",
          "name": "notes",
          "modules": [
            {
              "textRaw": "Legacy Streams API (pre Node.js v0.10)",
              "name": "legacy_streams_api_(pre_node.js_v0.10)",
              "desc": "<p>The Crypto module was added to Node.js before there was the concept of a\nunified Stream API, and before there were [<code>Buffer</code>][] objects for handling\nbinary data. As such, the many of the <code>crypto</code> defined classes have methods not\ntypically found on other Node.js classes that implement the [streams][stream]\nAPI (e.g. <code>update()</code>, <code>final()</code>, or <code>digest()</code>). Also, many methods accepted\nand returned <code>&#39;binary&#39;</code> encoded strings by default rather than Buffers. This\ndefault was changed after Node.js v0.8 to use [<code>Buffer</code>][] objects by default\ninstead.</p>\n",
              "type": "module",
              "displayName": "Legacy Streams API (pre Node.js v0.10)"
            },
            {
              "textRaw": "Recent ECDH Changes",
              "name": "recent_ecdh_changes",
              "desc": "<p>Usage of <code>ECDH</code> with non-dynamically generated key pairs has been simplified.\nNow, [<code>ecdh.setPrivateKey()</code>][] can be called with a preselected private key\nand the associated public point (key) will be computed and stored in the object.\nThis allows code to only store and provide the private part of the EC key pair.\n[<code>ecdh.setPrivateKey()</code>][] now also validates that the private key is valid for\nthe selected curve.</p>\n<p>The [<code>ecdh.setPublicKey()</code>][] method is now deprecated as its inclusion in the\nAPI is not useful. Either a previously stored private key should be set, which\nautomatically generates the associated public key, or [<code>ecdh.generateKeys()</code>][]\nshould be called. The main drawback of using [<code>ecdh.setPublicKey()</code>][] is that\nit can be used to put the ECDH key pair into an inconsistent state.</p>\n",
              "type": "module",
              "displayName": "Recent ECDH Changes"
            },
            {
              "textRaw": "Support for weak or compromised algorithms",
              "name": "support_for_weak_or_compromised_algorithms",
              "desc": "<p>The <code>crypto</code> module still supports some algorithms which are already\ncompromised and are not currently recommended for use. The API also allows\nthe use of ciphers and hashes with a small key size that are considered to be\ntoo weak for safe use.</p>\n<p>Users should take full responsibility for selecting the crypto\nalgorithm and key size according to their security requirements.</p>\n<p>Based on the recommendations of [NIST SP 800-131A][]:</p>\n<ul>\n<li>MD5 and SHA-1 are no longer acceptable where collision resistance is\nrequired such as digital signatures.</li>\n<li>The key used with RSA, DSA and DH algorithms is recommended to have\nat least 2048 bits and that of the curve of ECDSA and ECDH at least\n224 bits, to be safe to use for several years.</li>\n<li>The DH groups of <code>modp1</code>, <code>modp2</code> and <code>modp5</code> have a key size\nsmaller than 2048 bits and are not recommended.</li>\n</ul>\n<p>See the reference for other recommendations and details.</p>\n<!-- [end-include:crypto.md] -->\n<!-- [start-include:debugger.md] -->\n",
              "type": "module",
              "displayName": "Support for weak or compromised algorithms"
            }
          ],
          "type": "module",
          "displayName": "Notes"
        }
      ],
      "type": "module",
      "displayName": "Crypto"
    },
    {
      "textRaw": "UDP / Datagram Sockets",
      "name": "dgram",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>dgram</code> module provides an implementation of UDP Datagram sockets.</p>\n<pre><code class=\"lang-js\">const dgram = require(&#39;dgram&#39;);\nconst server = dgram.createSocket(&#39;udp4&#39;);\n\nserver.on(&#39;error&#39;, (err) =&gt; {\n  console.log(`server error:\\n${err.stack}`);\n  server.close();\n});\n\nserver.on(&#39;message&#39;, (msg, rinfo) =&gt; {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.on(&#39;listening&#39;, () =&gt; {\n  var address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);\n// server listening 0.0.0.0:41234\n</code></pre>\n",
      "classes": [
        {
          "textRaw": "Class: dgram.Socket",
          "type": "class",
          "name": "dgram.Socket",
          "desc": "<p>The <code>dgram.Socket</code> object is an [<code>EventEmitter</code>][] that encapsulates the\ndatagram functionality.</p>\n<p>New instances of <code>dgram.Socket</code> are created using [<code>dgram.createSocket()</code>][].\nThe <code>new</code> keyword is not to be used to create <code>dgram.Socket</code> instances.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p>The <code>&#39;close&#39;</code> event is emitted after a socket is closed with [<code>close()</code>][].\nOnce triggered, no new <code>&#39;message&#39;</code> events will be emitted on this socket.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>The <code>&#39;error&#39;</code> event is emitted whenever any error occurs. The event handler\nfunction is passed a single Error object.</p>\n"
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "desc": "<p>The <code>&#39;listening&#39;</code> event is emitted whenever a socket begins listening for\ndatagram messages. This occurs as soon as UDP sockets are created.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "params": [],
              "desc": "<p>The <code>&#39;message&#39;</code> event is emitted when a new datagram is available on a socket.\nThe event handler function is passed two arguments: <code>msg</code> and <code>rinfo</code>. The\n<code>msg</code> argument is a [<code>Buffer</code>][] and <code>rinfo</code> is an object with the sender&#39;s\naddress information provided by the <code>address</code>, <code>family</code> and <code>port</code> properties:</p>\n<pre><code class=\"lang-js\">socket.on(&#39;message&#39;, (msg, rinfo) =&gt; {\n  console.log(&#39;Received %d bytes from %s:%d\\n&#39;,\n              msg.length, rinfo.address, rinfo.port);\n});\n</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "socket.addMembership(multicastAddress[, multicastInterface])",
              "type": "method",
              "name": "addMembership",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastAddress` {String} ",
                      "name": "multicastAddress",
                      "type": "String"
                    },
                    {
                      "textRaw": "`multicastInterface` {String}, Optional ",
                      "name": "multicastInterface",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "multicastInterface",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Tells the kernel to join a multicast group at the given <code>multicastAddress</code> and\n<code>multicastInterface</code> using the <code>IP_ADD_MEMBERSHIP</code> socket option. If the\n<code>multicastInterface</code> argument is not specified, the operating system will choose\none interface and will add membership to it. To add membership to every\navailable interface, call <code>addMembership</code> multiple times, once per interface.</p>\n"
            },
            {
              "textRaw": "socket.address()",
              "type": "method",
              "name": "address",
              "desc": "<p>Returns an object containing the address information for a socket.\nFor UDP sockets, this object will contain <code>address</code>, <code>family</code> and <code>port</code>\nproperties.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.bind([port][, address][, callback])",
              "type": "method",
              "name": "bind",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`port` {Number} - Integer, Optional ",
                      "name": "port",
                      "type": "Number",
                      "optional": true,
                      "desc": "Integer"
                    },
                    {
                      "textRaw": "`address` {String}, Optional ",
                      "name": "address",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} with no parameters, Optional. Called when binding is complete. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "with no parameters, Optional. Called when binding is complete.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "port",
                      "optional": true
                    },
                    {
                      "name": "address",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>For UDP sockets, causes the <code>dgram.Socket</code> to listen for datagram messages on a\nnamed <code>port</code> and optional <code>address</code>. If <code>port</code> is not specified, the operating\nsystem will attempt to bind to a random port. If <code>address</code> is not specified,\nthe operating system will attempt to listen on all addresses.  Once binding is\ncomplete, a <code>&#39;listening&#39;</code> event is emitted and the optional <code>callback</code> function\nis called.</p>\n<p>Note that specifying both a <code>&#39;listening&#39;</code> event listener and passing a\n<code>callback</code> to the <code>socket.bind()</code> method is not harmful but not very\nuseful.</p>\n<p>A bound datagram socket keeps the Node.js process running to receive\ndatagram messages.</p>\n<p>If binding fails, an <code>&#39;error&#39;</code> event is generated. In rare case (e.g.\nattempting to bind with a closed socket), an [<code>Error</code>][] may be thrown.</p>\n<p>Example of a UDP server listening on port 41234:</p>\n<pre><code class=\"lang-js\">const dgram = require(&#39;dgram&#39;);\nconst server = dgram.createSocket(&#39;udp4&#39;);\n\nserver.on(&#39;error&#39;, (err) =&gt; {\n  console.log(`server error:\\n${err.stack}`);\n  server.close();\n});\n\nserver.on(&#39;message&#39;, (msg, rinfo) =&gt; {\n  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.on(&#39;listening&#39;, () =&gt; {\n  var address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\n\nserver.bind(41234);\n// server listening 0.0.0.0:41234\n</code></pre>\n"
            },
            {
              "textRaw": "socket.bind(options[, callback])",
              "type": "method",
              "name": "bind",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} - Required. Supports the following properties: ",
                      "options": [
                        {
                          "textRaw": "`port` {Number} - Required. ",
                          "name": "port",
                          "type": "Number",
                          "desc": "Required."
                        },
                        {
                          "textRaw": "`address` {String} - Optional. ",
                          "name": "address",
                          "type": "String",
                          "desc": "Optional."
                        },
                        {
                          "textRaw": "`exclusive` {Boolean} - Optional. ",
                          "name": "exclusive",
                          "type": "Boolean",
                          "desc": "Optional."
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "Required. Supports the following properties:"
                    },
                    {
                      "textRaw": "`callback` {Function} - Optional. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Optional.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>For UDP sockets, causes the <code>dgram.Socket</code> to listen for datagram messages on a\nnamed <code>port</code> and optional <code>address</code> that are passed as properties of an\n<code>options</code> object passed as the first argument. If <code>port</code> is not specified, the\noperating system will attempt to bind to a random port. If <code>address</code> is not\nspecified, the operating system will attempt to listen on all addresses.  Once\nbinding is complete, a <code>&#39;listening&#39;</code> event is emitted and the optional\n<code>callback</code> function is called.</p>\n<p>The <code>options</code> object may contain an additional <code>exclusive</code> property that is\nuse when using <code>dgram.Socket</code> objects with the [<code>cluster</code>] module. When\n<code>exclusive</code> is set to <code>false</code> (the default), cluster workers will use the same\nunderlying socket handle allowing connection handling duties to be shared.\nWhen <code>exclusive</code> is <code>true</code>, however, the handle is not shared and attempted\nport sharing results in an error.</p>\n<p>An example socket listening on an exclusive port is shown below.</p>\n<pre><code class=\"lang-js\">socket.bind({\n  address: &#39;localhost&#39;,\n  port: 8000,\n  exclusive: true\n});\n</code></pre>\n"
            },
            {
              "textRaw": "socket.close([callback])",
              "type": "method",
              "name": "close",
              "desc": "<p>Close the underlying socket and stop listening for data on it. If a callback is\nprovided, it is added as a listener for the [<code>&#39;close&#39;</code>][] event.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.dropMembership(multicastAddress[, multicastInterface])",
              "type": "method",
              "name": "dropMembership",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastAddress` {String} ",
                      "name": "multicastAddress",
                      "type": "String"
                    },
                    {
                      "textRaw": "`multicastInterface` {String}, Optional ",
                      "name": "multicastInterface",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "multicastInterface",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Instructs the kernel to leave a multicast group at <code>multicastAddress</code> using the\n<code>IP_DROP_MEMBERSHIP</code> socket option. This method is automatically called by the\nkernel when the socket is closed or the process terminates, so most apps will\nnever have reason to call this.</p>\n<p>If <code>multicastInterface</code> is not specified, the operating system will attempt to\ndrop membership on all valid interfaces.</p>\n"
            },
            {
              "textRaw": "socket.send(buf, offset, length, port, address[, callback])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buf` {Buffer|String} Message to be sent ",
                      "name": "buf",
                      "type": "Buffer|String",
                      "desc": "Message to be sent"
                    },
                    {
                      "textRaw": "`offset` {Number} Integer. Offset in the buffer where the message starts. ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "Integer. Offset in the buffer where the message starts."
                    },
                    {
                      "textRaw": "`length` {Number} Integer. Number of bytes in the message. ",
                      "name": "length",
                      "type": "Number",
                      "desc": "Integer. Number of bytes in the message."
                    },
                    {
                      "textRaw": "`port` {Number} Integer. Destination port. ",
                      "name": "port",
                      "type": "Number",
                      "desc": "Integer. Destination port."
                    },
                    {
                      "textRaw": "`address` {String} Destination hostname or IP address. ",
                      "name": "address",
                      "type": "String",
                      "desc": "Destination hostname or IP address."
                    },
                    {
                      "textRaw": "`callback` {Function} Called when the message has been sent. Optional. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Called when the message has been sent. Optional.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "length"
                    },
                    {
                      "name": "port"
                    },
                    {
                      "name": "address"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Broadcasts a datagram on the socket. The destination <code>port</code> and <code>address</code> must\nbe specified.</p>\n<p>The <code>buf</code> argument is a [<code>Buffer</code>] object containing the message. The <code>offset</code>\nand <code>length</code> specify the offset within the <code>Buffer</code> where the message begins\nand the number of bytes in the message, respectively. With messages that\ncontain  multi-byte characters, <code>offset</code> and <code>length</code> will be calculated with\nrespect to [byte length][] and not the character position.</p>\n<p>The <code>address</code> argument is a string. If the value of <code>address</code> is a host name,\nDNS will be used to resolve the address of the host. If the <code>address</code> is not\nspecified or is an empty string, <code>&#39;0.0.0.0&#39;</code> or <code>&#39;::0&#39;</code> will be used instead.\nIt is possible, depending on the network configuration, that these defaults\nmay not work; accordingly, it is best to be explicit about the destination\naddress.</p>\n<p>If the socket has not been previously bound with a call to <code>bind</code>, the socket\nis assigned a random port number and is bound to the &quot;all interfaces&quot; address\n(<code>&#39;0.0.0.0&#39;</code> for <code>udp4</code> sockets, <code>&#39;::0&#39;</code> for <code>udp6</code> sockets.)</p>\n<p>An optional <code>callback</code> function  may be specified to as a way of reporting\nDNS errors or for determining when it is safe to reuse the <code>buf</code> object.\nNote that DNS lookups delay the time to send for at least one tick of the\nNode.js event loop.</p>\n<p>The only way to know for sure that the datagram has been sent is by using a\n<code>callback</code>. If an error occurs and a <code>callback</code> is given, the error will be\npassed as the first argument to the <code>callback</code>. If a <code>callback</code> is not given,\nthe error is emitted as an <code>&#39;error&#39;</code> event on the <code>socket</code> object.</p>\n<p>Example of sending a UDP packet to a random port on <code>localhost</code>;</p>\n<pre><code class=\"lang-js\">const dgram = require(&#39;dgram&#39;);\nconst message = new Buffer(&#39;Some bytes&#39;);\nconst client = dgram.createSocket(&#39;udp4&#39;);\nclient.send(message, 0, message.length, 41234, &#39;localhost&#39;, (err) =&gt; {\n  client.close();\n});\n</code></pre>\n<p><strong>A Note about UDP datagram size</strong></p>\n<p>The maximum size of an <code>IPv4/v6</code> datagram depends on the <code>MTU</code>\n(<em>Maximum Transmission Unit</em>) and on the <code>Payload Length</code> field size.</p>\n<ul>\n<li><p>The <code>Payload Length</code> field is <code>16 bits</code> wide, which means that a normal\npayload exceed 64K octets <em>including</em> the internet header and data\n(65,507 bytes = 65,535 âˆ’ 8 bytes UDP header âˆ’ 20 bytes IP header);\nthis is generally true for loopback interfaces, but such long datagram\nmessages are impractical for most hosts and networks.</p>\n</li>\n<li><p>The <code>MTU</code> is the largest size a given link layer technology can support for\ndatagram messages. For any link, <code>IPv4</code> mandates a minimum <code>MTU</code> of <code>68</code>\noctets, while the recommended <code>MTU</code> for IPv4 is <code>576</code> (typically recommended\nas the <code>MTU</code> for dial-up type applications), whether they arrive whole or in\nfragments.</p>\n<p>For <code>IPv6</code>, the minimum <code>MTU</code> is <code>1280</code> octets, however, the mandatory minimum\nfragment reassembly buffer size is <code>1500</code> octets. The value of <code>68</code> octets is\nvery small, since most current link layer technologies, like Ethernet, have a\nminimum <code>MTU</code> of <code>1500</code>.</p>\n</li>\n</ul>\n<p>It is impossible to know in advance the MTU of each link through which\na packet might travel. Sending a datagram greater than the receiver <code>MTU</code> will\nnot work because the packet will get silently dropped without informing the\nsource that the data did not reach its intended recipient.</p>\n"
            },
            {
              "textRaw": "socket.setBroadcast(flag)",
              "type": "method",
              "name": "setBroadcast",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`flag` {Boolean} ",
                      "name": "flag",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "flag"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When set to <code>true</code>, UDP\npackets may be sent to a local interface&#39;s broadcast address.</p>\n"
            },
            {
              "textRaw": "socket.setMulticastLoopback(flag)",
              "type": "method",
              "name": "setMulticastLoopback",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`flag` {Boolean} ",
                      "name": "flag",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "flag"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When set to <code>true</code>,\nmulticast packets will also be received on the local interface.</p>\n"
            },
            {
              "textRaw": "socket.setMulticastTTL(ttl)",
              "type": "method",
              "name": "setMulticastTTL",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`ttl` {Number} Integer ",
                      "name": "ttl",
                      "type": "Number",
                      "desc": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "ttl"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  While TTL generally stands for\n&quot;Time to Live&quot;, in this context it specifies the number of IP hops that a\npacket is allowed to travel through, specifically for multicast traffic.  Each\nrouter or gateway that forwards a packet decrements the TTL. If the TTL is\ndecremented to 0 by a router, it will not be forwarded.</p>\n<p>The argument passed to to <code>socket.setMulticastTTL()</code> is a number of hops\nbetween 0 and 255. The default on most systems is <code>1</code> but can vary.</p>\n"
            },
            {
              "textRaw": "socket.setTTL(ttl)",
              "type": "method",
              "name": "setTTL",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`ttl` {Number} Integer ",
                      "name": "ttl",
                      "type": "Number",
                      "desc": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "ttl"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the <code>IP_TTL</code> socket option. While TTL generally stands for &quot;Time to Live&quot;,\nin this context it specifies the number of IP hops that a packet is allowed to\ntravel through.  Each router or gateway that forwards a packet decrements the\nTTL.  If the TTL is decremented to 0 by a router, it will not be forwarded.\nChanging TTL values is typically done for network probes or when multicasting.</p>\n<p>The argument to <code>socket.setTTL()</code> is a number of hops between 1 and 255.\nThe default on most systems is 64 but can vary.</p>\n"
            },
            {
              "textRaw": "socket.ref()",
              "type": "method",
              "name": "ref",
              "desc": "<p>By default, binding a socket will cause it to block the Node.js process from\nexiting as long as the socket is open. The <code>socket.unref()</code> method can be used\nto exclude the socket from the reference counting that keeps the Node.js\nprocess active. The <code>socket.ref()</code> method adds the socket back to the reference\ncounting and restores the default behavior.</p>\n<p>Calling <code>socket.ref()</code> multiples times will have no additional effect.</p>\n<p>The <code>socket.ref()</code> method returns a reference to the socket so calls can be\nchained.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.unref()",
              "type": "method",
              "name": "unref",
              "desc": "<p>By default, binding a socket will cause it to block the Node.js process from\nexiting as long as the socket is open. The <code>socket.unref()</code> method can be used\nto exclude the socket from the reference counting that keeps the Node.js\nprocess active, allowing the process to exit even if the socket is still\nlistening.</p>\n<p>Calling <code>socket.unref()</code> multiple times will have no addition effect.</p>\n<p>The <code>socket.unref()</code> method returns a reference to the socket so calls can be\nchained.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "modules": [
            {
              "textRaw": "Change to asynchronous `socket.bind()` behavior",
              "name": "change_to_asynchronous_`socket.bind()`_behavior",
              "desc": "<p>As of Node.js v0.10, [<code>dgram.Socket#bind()</code>][] changed to an asynchronous\nexecution model. Legacy code that assumes synchronous behavior, as in the\nfollowing example:</p>\n<pre><code class=\"lang-js\">const s = dgram.createSocket(&#39;udp4&#39;);\ns.bind(1234);\ns.addMembership(&#39;224.0.0.114&#39;);\n</code></pre>\n<p>Must be changed to pass a callback function to the [<code>dgram.Socket#bind()</code>][]\nfunction:</p>\n<pre><code class=\"lang-js\">const s = dgram.createSocket(&#39;udp4&#39;);\ns.bind(1234, () =&gt; {\n  s.addMembership(&#39;224.0.0.114&#39;);\n});\n</code></pre>\n",
              "type": "module",
              "displayName": "Change to asynchronous `socket.bind()` behavior"
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "`dgram` module functions",
          "name": "`dgram`_module_functions",
          "methods": [
            {
              "textRaw": "dgram.createSocket(options[, callback])",
              "type": "method",
              "name": "createSocket",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {dgram.Socket} ",
                    "name": "return",
                    "type": "dgram.Socket"
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object} ",
                      "name": "options",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`callback` {Function} Attached as a listener to `'message'` events. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Attached as a listener to `'message'` events.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a <code>dgram.Socket</code> object. The <code>options</code> argument is an object that\nshould contain a <code>type</code> field of either <code>udp4</code> or <code>udp6</code> and an optional\nboolean <code>reuseAddr</code> field.</p>\n<p>When <code>reuseAddr</code> is <code>true</code> [<code>socket.bind()</code>][] will reuse the address, even if\nanother process has already bound a socket on it. <code>reuseAddr</code> defaults to\n<code>false</code>. An optional <code>callback</code> function can be passed specified which is added\nas a listener for <code>&#39;message&#39;</code> events.</p>\n<p>Once the socket is created, calling [<code>socket.bind()</code>][] will instruct the\nsocket to begin listening for datagram messages. When <code>address</code> and <code>port</code> are\nnot passed to  [<code>socket.bind()</code>][] the method will bind the socket to the &quot;all\ninterfaces&quot; address on a random port (it does the right thing for both <code>udp4</code>\nand <code>udp6</code> sockets). The bound address and port can be retrieved using\n[<code>socket.address().address</code>][] and [<code>socket.address().port</code>][].</p>\n"
            },
            {
              "textRaw": "dgram.createSocket(type[, callback])",
              "type": "method",
              "name": "createSocket",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {dgram.Socket} ",
                    "name": "return",
                    "type": "dgram.Socket"
                  },
                  "params": [
                    {
                      "textRaw": "`type` {String} - Either 'udp4' or 'udp6' ",
                      "name": "type",
                      "type": "String",
                      "desc": "Either 'udp4' or 'udp6'"
                    },
                    {
                      "textRaw": "`callback` {Function} - Attached as a listener to `'message'` events. Optional ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true,
                      "desc": "Attached as a listener to `'message'` events."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "type"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a <code>dgram.Socket</code> object of the specified <code>type</code>. The <code>type</code> argument\ncan be either <code>udp4</code> or <code>udp6</code>. An optional <code>callback</code> function can be passed\nwhich is added as a listener for <code>&#39;message&#39;</code> events.</p>\n<p>Once the socket is created, calling [<code>socket.bind()</code>][] will instruct the\nsocket to begin listening for datagram messages. When <code>address</code> and <code>port</code> are\nnot passed to  [<code>socket.bind()</code>][] the method will bind the socket to the &quot;all\ninterfaces&quot; address on a random port (it does the right thing for both <code>udp4</code>\nand <code>udp6</code> sockets). The bound address and port can be retrieved using\n[<code>socket.address().address</code>][] and [<code>socket.address().port</code>][].</p>\n<!-- [end-include:dgram.md] -->\n<!-- [start-include:dns.md] -->\n"
            }
          ],
          "type": "module",
          "displayName": "`dgram` module functions"
        }
      ],
      "type": "module",
      "displayName": "dgram"
    },
    {
      "textRaw": "DNS",
      "name": "dns",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>dns</code> module contains functions belonging to two different categories:</p>\n<p>1) Functions that use the underlying operating system facilities to perform\nname resolution, and that do not necessarily perform any network communication.\nThis category contains only one function: [<code>dns.lookup()</code>][]. <strong>Developers\nlooking to perform name resolution in the same way that other applications on\nthe same operating system behave should use [<code>dns.lookup()</code>][].</strong></p>\n<p>For example, looking up <code>nodejs.org</code>.</p>\n<pre><code class=\"lang-js\">const dns = require(&#39;dns&#39;);\n\ndns.lookup(&#39;nodejs.org&#39;, (err, addresses, family) =&gt; {\n  console.log(&#39;addresses:&#39;, addresses);\n});\n</code></pre>\n<p>2) Functions that connect to an actual DNS server to perform name resolution,\nand that <em>always</em> use the network to perform DNS queries. This category\ncontains all functions in the <code>dns</code> module <em>except</em> [<code>dns.lookup()</code>][]. These\nfunctions do not use the same set of configuration files used by\n[<code>dns.lookup()</code>][] (e.g. <code>/etc/hosts</code>). These functions should be used by\ndevelopers who do not want to use the underlying operating system&#39;s facilities\nfor name resolution, and instead want to <em>always</em> perform DNS queries.</p>\n<p>Below is an example that resolves <code>&#39;nodejs.org&#39;</code> then reverse resolves the IP\naddresses that are returned.</p>\n<pre><code class=\"lang-js\">const dns = require(&#39;dns&#39;);\n\ndns.resolve4(&#39;nodejs.org&#39;, (err, addresses) =&gt; {\n  if (err) throw err;\n\n  console.log(`addresses: ${JSON.stringify(addresses)}`);\n\n  addresses.forEach((a) =&gt; {\n    dns.reverse(a, (err, hostnames) =&gt; {\n      if (err) {\n        throw err;\n      }\n      console.log(`reverse for ${a}: ${JSON.stringify(hostnames)}`);\n    });\n  });\n});\n</code></pre>\n<p>There are subtle consequences in choosing one over the other, please consult\nthe [Implementation considerations section][] for more information.</p>\n",
      "methods": [
        {
          "textRaw": "dns.getServers()",
          "type": "method",
          "name": "getServers",
          "meta": {
            "added": [
              "v0.11.3"
            ]
          },
          "desc": "<p>Returns an array of IP address strings that are being used for name\nresolution.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "dns.lookup(hostname[, options], callback)",
          "type": "method",
          "name": "lookup",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>Resolves a hostname (e.g. <code>&#39;nodejs.org&#39;</code>) into the first found A (IPv4) or\nAAAA (IPv6) record. <code>options</code> can be an object or integer. If <code>options</code> is\nnot provided, then IPv4 and IPv6 addresses are both valid. If <code>options</code> is\nan integer, then it must be <code>4</code> or <code>6</code>.</p>\n<p>Alternatively, <code>options</code> can be an object containing these properties:</p>\n<ul>\n<li><code>family</code> {Number} - The record family. If present, must be the integer\n<code>4</code> or <code>6</code>. If not provided, both IP v4 and v6 addresses are accepted.</li>\n<li><code>hints</code>: {Number} - If present, it should be one or more of the supported\n<code>getaddrinfo</code> flags. If <code>hints</code> is not provided, then no flags are passed to\n<code>getaddrinfo</code>. Multiple flags can be passed through <code>hints</code> by logically\n<code>OR</code>ing their values.\nSee [supported <code>getaddrinfo</code> flags][] for more information on supported\nflags.</li>\n<li><code>all</code>: {Boolean} - When <code>true</code>, the callback returns all resolved addresses\nin an array, otherwise returns a single address. Defaults to <code>false</code>.</li>\n</ul>\n<p>All properties are optional. An example usage of options is shown below.</p>\n<pre><code>{\n  family: 4,\n  hints: dns.ADDRCONFIG | dns.V4MAPPED,\n  all: false\n}\n</code></pre><p>The <code>callback</code> function has arguments <code>(err, address, family)</code>. <code>address</code> is a\nstring representation of an IPv4 or IPv6 address. <code>family</code> is either the\ninteger <code>4</code> or <code>6</code> and denotes the family of <code>address</code> (not necessarily the\nvalue initially passed to <code>lookup</code>).</p>\n<p>With the <code>all</code> option set to <code>true</code>, the arguments change to\n<code>(err, addresses)</code>, with <code>addresses</code> being an array of objects with the\nproperties <code>address</code> and <code>family</code>.</p>\n<p>On error, <code>err</code> is an [<code>Error</code>][] object, where <code>err.code</code> is the error code.\nKeep in mind that <code>err.code</code> will be set to <code>&#39;ENOENT&#39;</code> not only when\nthe hostname does not exist but also when the lookup fails in other ways\nsuch as no available file descriptors.</p>\n<p><code>dns.lookup()</code> does not necessarily have anything to do with the DNS protocol.\nThe implementation uses an operating system facility that can associate names\nwith addresses, and vice versa. This implementation can have subtle but\nimportant consequences on the behavior of any Node.js program. Please take some\ntime to consult the [Implementation considerations section][] before using\n<code>dns.lookup()</code>.</p>\n",
          "modules": [
            {
              "textRaw": "Supported getaddrinfo flags",
              "name": "supported_getaddrinfo_flags",
              "desc": "<p>The following flags can be passed as hints to [<code>dns.lookup()</code>][].</p>\n<ul>\n<li><code>dns.ADDRCONFIG</code>: Returned address types are determined by the types\nof addresses supported by the current system. For example, IPv4 addresses\nare only returned if the current system has at least one IPv4 address\nconfigured. Loopback addresses are not considered.</li>\n<li><code>dns.V4MAPPED</code>: If the IPv6 family was specified, but no IPv6 addresses were\nfound, then return IPv4 mapped IPv6 addresses. Note that it is not supported\non some operating systems (e.g FreeBSD 10.1).</li>\n</ul>\n",
              "type": "module",
              "displayName": "Supported getaddrinfo flags"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.lookupService(address, port, callback)",
          "type": "method",
          "name": "lookupService",
          "meta": {
            "added": [
              "v0.11.14"
            ]
          },
          "desc": "<p>Resolves the given <code>address</code> and <code>port</code> into a hostname and service using\nthe operating system&#39;s underlying <code>getnameinfo</code> implementation.</p>\n<p>The callback has arguments <code>(err, hostname, service)</code>. The <code>hostname</code> and\n<code>service</code> arguments are strings (e.g. <code>&#39;localhost&#39;</code> and <code>&#39;http&#39;</code> respectively).</p>\n<p>On error, <code>err</code> is an [<code>Error</code>][] object, where <code>err.code</code> is the error code.</p>\n<pre><code class=\"lang-js\">const dns = require(&#39;dns&#39;);\ndns.lookupService(&#39;127.0.0.1&#39;, 22, (err, hostname, service) =&gt; {\n  console.log(hostname, service);\n    // Prints: localhost ssh\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "address"
                },
                {
                  "name": "port"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve(hostname[, rrtype], callback)",
          "type": "method",
          "name": "resolve",
          "meta": {
            "added": [
              "v0.1.27"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve a hostname (e.g. <code>&#39;nodejs.org&#39;</code>) into an\narray of the record types specified by <code>rrtype</code>.</p>\n<p>Valid values for <code>rrtype</code> are:</p>\n<ul>\n<li><code>&#39;A&#39;</code> - IPV4 addresses, default</li>\n<li><code>&#39;AAAA&#39;</code> - IPV6 addresses</li>\n<li><code>&#39;MX&#39;</code> - mail exchange records</li>\n<li><code>&#39;TXT&#39;</code> - text records</li>\n<li><code>&#39;SRV&#39;</code> - SRV records</li>\n<li><code>&#39;PTR&#39;</code> - used for reverse IP lookups</li>\n<li><code>&#39;NS&#39;</code> - name server records</li>\n<li><code>&#39;CNAME&#39;</code> - canonical name records</li>\n<li><code>&#39;SOA&#39;</code> - start of authority record</li>\n<li><code>&#39;NAPTR&#39;</code> - name authority pointer record</li>\n</ul>\n<p>The <code>callback</code> function has arguments <code>(err, addresses)</code>. When successful,\n<code>addresses</code> will be an array, except when resolving an SOA record which returns\nan object structured in the same manner as one returned by the\n[<code>dns.resolveSoa()</code>][] method. The type of each item in <code>addresses</code> is\ndetermined by the record type, and described in the documentation for the\ncorresponding lookup methods.</p>\n<p>On error, <code>err</code> is an [<code>Error</code>][] object, where <code>err.code</code> is\none of the error codes listed <a href=\"#dns_error_codes\">here</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "rrtype",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve4(hostname, callback)",
          "type": "method",
          "name": "resolve4",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve a IPv4 addresses (<code>A</code> records) for the\n<code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function\nwill contain an array of IPv4 addresses (e.g.\n<code>[&#39;74.125.79.104&#39;, &#39;74.125.79.105&#39;, &#39;74.125.79.106&#39;]</code>).</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve6(hostname, callback)",
          "type": "method",
          "name": "resolve6",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve a IPv6 addresses (<code>AAAA</code> records) for the\n<code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function\nwill contain an array of IPv6 addresses.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveCname(hostname, callback)",
          "type": "method",
          "name": "resolveCname",
          "meta": {
            "added": [
              "v0.3.2"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve <code>CNAME</code> records for the <code>hostname</code>. The\n<code>addresses</code> argument passed to the <code>callback</code> function\nwill contain an array of canonical name records available for the <code>hostname</code>\n(e.g. <code>[&#39;bar.example.com&#39;]</code>).</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveMx(hostname, callback)",
          "type": "method",
          "name": "resolveMx",
          "meta": {
            "added": [
              "v0.1.27"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve mail exchange records (<code>MX</code> records) for the\n<code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function will\ncontain an array of objects containing both a <code>priority</code> and <code>exchange</code>\nproperty (e.g. <code>[{priority: 10, exchange: &#39;mx.example.com&#39;}, ...]</code>).</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveNaptr(hostname, callback)",
          "type": "method",
          "name": "resolveNaptr",
          "meta": {
            "added": [
              "v0.9.12"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve regular expression based records (<code>NAPTR</code>\nrecords) for the <code>hostname</code>. The <code>callback</code> function has arguments\n<code>(err, addresses)</code>.  The <code>addresses</code> argument passed to the <code>callback</code> function\nwill contain an array of objects with the following properties:</p>\n<ul>\n<li><code>flags</code></li>\n<li><code>service</code></li>\n<li><code>regexp</code></li>\n<li><code>replacement</code></li>\n<li><code>order</code></li>\n<li><code>preference</code></li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"lang-js\">{\n  flags: &#39;s&#39;,\n  service: &#39;SIP+D2U&#39;,\n  regexp: &#39;&#39;,\n  replacement: &#39;_sip._udp.example.com&#39;,\n  order: 30,\n  preference: 100\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveNs(hostname, callback)",
          "type": "method",
          "name": "resolveNs",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve name server records (<code>NS</code> records) for the\n<code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function will\ncontain an array of name server records available for <code>hostname</code>\n(e.g., <code>[&#39;ns1.example.com&#39;, &#39;ns2.example.com&#39;]</code>).</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveSoa(hostname, callback)",
          "type": "method",
          "name": "resolveSoa",
          "meta": {
            "added": [
              "v0.11.10"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve a start of authority record (<code>SOA</code> record) for\nthe <code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function will\nbe an object with the following properties:</p>\n<ul>\n<li><code>nsname</code></li>\n<li><code>hostmaster</code></li>\n<li><code>serial</code></li>\n<li><code>refresh</code></li>\n<li><code>retry</code></li>\n<li><code>expire</code></li>\n<li><code>minttl</code></li>\n</ul>\n<pre><code>{\n  nsname: &#39;ns.example.com&#39;,\n  hostmaster: &#39;root.example.com&#39;,\n  serial: 2013101809,\n  refresh: 10000,\n  retry: 2400,\n  expire: 604800,\n  minttl: 3600\n}\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveSrv(hostname, callback)",
          "type": "method",
          "name": "resolveSrv",
          "meta": {
            "added": [
              "v0.1.27"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve service records (<code>SRV</code> records) for the\n<code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function will\nbe an array of objects with the following properties:</p>\n<ul>\n<li><code>priority</code></li>\n<li><code>weight</code></li>\n<li><code>port</code></li>\n<li><code>name</code></li>\n</ul>\n<pre><code>{\n  priority: 10,\n  weight: 5,\n  port: 21223,\n  name: &#39;service.example.com&#39;\n}\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveTxt(hostname, callback)",
          "type": "method",
          "name": "resolveTxt",
          "meta": {
            "added": [
              "v0.1.27"
            ]
          },
          "desc": "<p>Uses the DNS protocol to resolve text queries (<code>TXT</code> records) for the\n<code>hostname</code>. The <code>addresses</code> argument passed to the <code>callback</code> function is\nis a two-dimentional array of the text records available for <code>hostname</code> (e.g.,\n<code>[ [&#39;v=spf1 ip4:0.0.0.0 &#39;, &#39;~all&#39; ] ]</code>). Each sub-array contains TXT chunks of\none record. Depending on the use case, these could be either joined together or\ntreated separately.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "hostname"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.reverse(ip, callback)",
          "type": "method",
          "name": "reverse",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an\narray of hostnames.</p>\n<p>The <code>callback</code> function has arguments <code>(err, hostnames)</code>, where <code>hostnames</code>\nis an array of resolved hostnames for the given <code>ip</code>.</p>\n<p>On error, <code>err</code> is an [<code>Error</code>][] object, where <code>err.code</code> is\none of the [DNS error codes][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "ip"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.setServers(servers)",
          "type": "method",
          "name": "setServers",
          "meta": {
            "added": [
              "v0.11.3"
            ]
          },
          "desc": "<p>Sets the IP addresses of the servers to be used when resolving. The <code>servers</code>\nargument is an array of IPv4 or IPv6 addresses.</p>\n<p>If a port specified on the address it will be removed.</p>\n<p>An error will be thrown if an invalid address is provided.</p>\n<p>The <code>dns.setServers()</code> method must not be called while a DNS query is in\nprogress.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "servers"
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Error codes",
          "name": "error_codes",
          "desc": "<p>Each DNS query can return one of the following error codes:</p>\n<ul>\n<li><code>dns.NODATA</code>: DNS server returned answer with no data.</li>\n<li><code>dns.FORMERR</code>: DNS server claims query was misformatted.</li>\n<li><code>dns.SERVFAIL</code>: DNS server returned general failure.</li>\n<li><code>dns.NOTFOUND</code>: Domain name not found.</li>\n<li><code>dns.NOTIMP</code>: DNS server does not implement requested operation.</li>\n<li><code>dns.REFUSED</code>: DNS server refused query.</li>\n<li><code>dns.BADQUERY</code>: Misformatted DNS query.</li>\n<li><code>dns.BADNAME</code>: Misformatted hostname.</li>\n<li><code>dns.BADFAMILY</code>: Unsupported address family.</li>\n<li><code>dns.BADRESP</code>: Misformatted DNS reply.</li>\n<li><code>dns.CONNREFUSED</code>: Could not contact DNS servers.</li>\n<li><code>dns.TIMEOUT</code>: Timeout while contacting DNS servers.</li>\n<li><code>dns.EOF</code>: End of file.</li>\n<li><code>dns.FILE</code>: Error reading file.</li>\n<li><code>dns.NOMEM</code>: Out of memory.</li>\n<li><code>dns.DESTRUCTION</code>: Channel is being destroyed.</li>\n<li><code>dns.BADSTR</code>: Misformatted string.</li>\n<li><code>dns.BADFLAGS</code>: Illegal flags specified.</li>\n<li><code>dns.NONAME</code>: Given hostname is not numeric.</li>\n<li><code>dns.BADHINTS</code>: Illegal hints flags specified.</li>\n<li><code>dns.NOTINITIALIZED</code>: c-ares library initialization not yet performed.</li>\n<li><code>dns.LOADIPHLPAPI</code>: Error loading iphlpapi.dll.</li>\n<li><code>dns.ADDRGETNETWORKPARAMS</code>: Could not find GetNetworkParams function.</li>\n<li><code>dns.CANCELLED</code>: DNS query cancelled.</li>\n</ul>\n",
          "type": "module",
          "displayName": "Error codes"
        },
        {
          "textRaw": "Implementation considerations",
          "name": "implementation_considerations",
          "desc": "<p>Although [<code>dns.lookup()</code>][] and the various <code>dns.resolve*()/dns.reverse()</code>\nfunctions have the same goal of associating a network name with a network\naddress (or vice versa), their behavior is quite different. These differences\ncan have subtle but significant consequences on the behavior of Node.js\nprograms.</p>\n",
          "modules": [
            {
              "textRaw": "`dns.lookup()`",
              "name": "`dns.lookup()`",
              "desc": "<p>Under the hood, [<code>dns.lookup()</code>][] uses the same operating system facilities\nas most other programs. For instance, [<code>dns.lookup()</code>][] will almost always\nresolve a given name the same way as the <code>ping</code> command. On most POSIX-like\noperating systems, the behavior of the [<code>dns.lookup()</code>][] function can be\nmodified by changing settings in <code>nsswitch.conf(5)</code> and/or <code>resolv.conf(5)</code>,\nbut note that changing these files will change the behavior of <em>all other\nprograms running on the same operating system</em>.</p>\n<p>Though the call to <code>dns.lookup()</code> will be asynchronous from JavaScript&#39;s\nperspective, it is implemented as a synchronous call to <code>getaddrinfo(3)</code> that\nruns on libuv&#39;s threadpool. Because libuv&#39;s threadpool has a fixed size, it\nmeans that if for whatever reason the call to <code>getaddrinfo(3)</code> takes a long\ntime, other operations that could run on libuv&#39;s threadpool (such as filesystem\noperations) will experience degraded performance. In order to mitigate this\nissue, one potential solution is to increase the size of libuv&#39;s threadpool by\nsetting the <code>&#39;UV_THREADPOOL_SIZE&#39;</code> environment variable to a value greater than\n<code>4</code> (its current default value). For more information on libuv&#39;s threadpool, see\n[the official libuv documentation][].</p>\n",
              "type": "module",
              "displayName": "`dns.lookup()`"
            },
            {
              "textRaw": "`dns.resolve()`, `dns.resolve*()` and `dns.reverse()`",
              "name": "`dns.resolve()`,_`dns.resolve*()`_and_`dns.reverse()`",
              "desc": "<p>These functions are implemented quite differently than [<code>dns.lookup()</code>][]. They\ndo not use <code>getaddrinfo(3)</code> and they <em>always</em> perform a DNS query on the\nnetwork. This network communication is always done asynchronously, and does not\nuse libuv&#39;s threadpool.</p>\n<p>As a result, these functions cannot have the same negative impact on other\nprocessing that happens on libuv&#39;s threadpool that [<code>dns.lookup()</code>][] can have.</p>\n<p>They do not use the same set of configuration files than what [<code>dns.lookup()</code>][]\nuses. For instance, <em>they do not use the configuration from <code>/etc/hosts</code></em>.</p>\n<!-- [end-include:dns.md] -->\n<!-- [start-include:domain.md] -->\n",
              "type": "module",
              "displayName": "`dns.resolve()`, `dns.resolve*()` and `dns.reverse()`"
            }
          ],
          "type": "module",
          "displayName": "Implementation considerations"
        }
      ],
      "type": "module",
      "displayName": "DNS"
    },
    {
      "textRaw": "Domain",
      "name": "domain",
      "stability": 0,
      "stabilityText": "Deprecated",
      "desc": "<p><strong>This module is pending deprecation</strong>. Once a replacement API has been\nfinalized, this module will be fully deprecated. Most end users should\n<strong>not</strong> have cause to use this module. Users who absolutely must have\nthe functionality that domains provide may rely on it for the time being\nbut should expect to have to migrate to a different solution\nin the future.</p>\n<p>Domains provide a way to handle multiple different IO operations as a\nsingle group.  If any of the event emitters or callbacks registered to a\ndomain emit an <code>&#39;error&#39;</code> event, or throw an error, then the domain object\nwill be notified, rather than losing the context of the error in the\n<code>process.on(&#39;uncaughtException&#39;)</code> handler, or causing the program to\nexit immediately with an error code.</p>\n",
      "miscs": [
        {
          "textRaw": "Warning: Don't Ignore Errors!",
          "name": "Warning: Don't Ignore Errors!",
          "type": "misc",
          "desc": "<p>Domain error handlers are not a substitute for closing down your\nprocess when an error occurs.</p>\n<p>By the very nature of how [<code>throw</code>][] works in JavaScript, there is almost\nnever any way to safely &quot;pick up where you left off&quot;, without leaking\nreferences, or creating some other sort of undefined brittle state.</p>\n<p>The safest way to respond to a thrown error is to shut down the\nprocess.  Of course, in a normal web server, you might have many\nconnections open, and it is not reasonable to abruptly shut those down\nbecause an error was triggered by someone else.</p>\n<p>The better approach is to send an error response to the request that\ntriggered the error, while letting the others finish in their normal\ntime, and stop listening for new requests in that worker.</p>\n<p>In this way, <code>domain</code> usage goes hand-in-hand with the cluster module,\nsince the master process can fork a new worker when a worker\nencounters an error.  For Node.js programs that scale to multiple\nmachines, the terminating proxy or service registry can take note of\nthe failure, and react accordingly.</p>\n<p>For example, this is not a good idea:</p>\n<pre><code class=\"lang-js\">// XXX WARNING!  BAD IDEA!\n\nvar d = require(&#39;domain&#39;).create();\nd.on(&#39;error&#39;, (er) =&gt; {\n  // The error won&#39;t crash the process, but what it does is worse!\n  // Though we&#39;ve prevented abrupt process restarting, we are leaking\n  // resources like crazy if this ever happens.\n  // This is no better than process.on(&#39;uncaughtException&#39;)!\n  console.log(&#39;error, but oh well&#39;, er.message);\n});\nd.run(() =&gt; {\n  require(&#39;http&#39;).createServer((req, res) =&gt; {\n    handleRequest(req, res);\n  }).listen(PORT);\n});\n</code></pre>\n<p>By using the context of a domain, and the resilience of separating our\nprogram into multiple worker processes, we can react more\nappropriately, and handle errors with much greater safety.</p>\n<pre><code class=\"lang-js\">// Much better!\n\nconst cluster = require(&#39;cluster&#39;);\nconst PORT = +process.env.PORT || 1337;\n\nif (cluster.isMaster) {\n  // In real life, you&#39;d probably use more than just 2 workers,\n  // and perhaps not put the master and worker in the same file.\n  //\n  // You can also of course get a bit fancier about logging, and\n  // implement whatever custom logic you need to prevent DoS\n  // attacks and other bad behavior.\n  //\n  // See the options in the cluster documentation.\n  //\n  // The important thing is that the master does very little,\n  // increasing our resilience to unexpected errors.\n\n  cluster.fork();\n  cluster.fork();\n\n  cluster.on(&#39;disconnect&#39;, (worker) =&gt; {\n    console.error(&#39;disconnect!&#39;);\n    cluster.fork();\n  });\n\n} else {\n  // the worker\n  //\n  // This is where we put our bugs!\n\n  const domain = require(&#39;domain&#39;);\n\n  // See the cluster documentation for more details about using\n  // worker processes to serve requests.  How it works, caveats, etc.\n\n  const server = require(&#39;http&#39;).createServer((req, res) =&gt; {\n    var d = domain.create();\n    d.on(&#39;error&#39;, (er) =&gt; {\n      console.error(&#39;error&#39;, er.stack);\n\n      // Note: we&#39;re in dangerous territory!\n      // By definition, something unexpected occurred,\n      // which we probably didn&#39;t want.\n      // Anything can happen now!  Be very careful!\n\n      try {\n        // make sure we close down within 30 seconds\n        var killtimer = setTimeout(() =&gt; {\n          process.exit(1);\n        }, 30000);\n        // But don&#39;t keep the process open just for that!\n        killtimer.unref();\n\n        // stop taking new requests.\n        server.close();\n\n        // Let the master know we&#39;re dead.  This will trigger a\n        // &#39;disconnect&#39; in the cluster master, and then it will fork\n        // a new worker.\n        cluster.worker.disconnect();\n\n        // try to send an error to the request that triggered the problem\n        res.statusCode = 500;\n        res.setHeader(&#39;content-type&#39;, &#39;text/plain&#39;);\n        res.end(&#39;Oops, there was a problem!\\n&#39;);\n      } catch (er2) {\n        // oh well, not much we can do at this point.\n        console.error(&#39;Error sending 500!&#39;, er2.stack);\n      }\n    });\n\n    // Because req and res were created before this domain existed,\n    // we need to explicitly add them.\n    // See the explanation of implicit vs explicit binding below.\n    d.add(req);\n    d.add(res);\n\n    // Now run the handler function in the domain.\n    d.run(() =&gt; {\n      handleRequest(req, res);\n    });\n  });\n  server.listen(PORT);\n}\n\n// This part isn&#39;t important.  Just an example routing thing.\n// You&#39;d put your fancy application logic here.\nfunction handleRequest(req, res) {\n  switch(req.url) {\n    case &#39;/error&#39;:\n      // We do some async stuff, and then...\n      setTimeout(() =&gt; {\n        // Whoops!\n        flerb.bark();\n      });\n      break;\n    default:\n      res.end(&#39;ok&#39;);\n  }\n}\n</code></pre>\n"
        },
        {
          "textRaw": "Additions to Error objects",
          "name": "Additions to Error objects",
          "type": "misc",
          "desc": "<p>Any time an <code>Error</code> object is routed through a domain, a few extra fields\nare added to it.</p>\n<ul>\n<li><code>error.domain</code> The domain that first handled the error.</li>\n<li><code>error.domainEmitter</code> The event emitter that emitted an <code>&#39;error&#39;</code> event\nwith the error object.</li>\n<li><code>error.domainBound</code> The callback function which was bound to the\ndomain, and passed an error as its first argument.</li>\n<li><code>error.domainThrown</code> A boolean indicating whether the error was\nthrown, emitted, or passed to a bound callback function.</li>\n</ul>\n"
        },
        {
          "textRaw": "Implicit Binding",
          "name": "Implicit Binding",
          "type": "misc",
          "desc": "<p>If domains are in use, then all <strong>new</strong> EventEmitter objects (including\nStream objects, requests, responses, etc.) will be implicitly bound to\nthe active domain at the time of their creation.</p>\n<p>Additionally, callbacks passed to lowlevel event loop requests (such as\nto fs.open, or other callback-taking methods) will automatically be\nbound to the active domain.  If they throw, then the domain will catch\nthe error.</p>\n<p>In order to prevent excessive memory usage, Domain objects themselves\nare not implicitly added as children of the active domain.  If they\nwere, then it would be too easy to prevent request and response objects\nfrom being properly garbage collected.</p>\n<p>If you <em>want</em> to nest Domain objects as children of a parent Domain,\nthen you must explicitly add them.</p>\n<p>Implicit binding routes thrown errors and <code>&#39;error&#39;</code> events to the\nDomain&#39;s <code>&#39;error&#39;</code> event, but does not register the EventEmitter on the\nDomain, so [<code>domain.dispose()</code>][] will not shut down the EventEmitter.\nImplicit binding only takes care of thrown errors and <code>&#39;error&#39;</code> events.</p>\n"
        },
        {
          "textRaw": "Explicit Binding",
          "name": "Explicit Binding",
          "type": "misc",
          "desc": "<p>Sometimes, the domain in use is not the one that ought to be used for a\nspecific event emitter.  Or, the event emitter could have been created\nin the context of one domain, but ought to instead be bound to some\nother domain.</p>\n<p>For example, there could be one domain in use for an HTTP server, but\nperhaps we would like to have a separate domain to use for each request.</p>\n<p>That is possible via explicit binding.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">// create a top-level domain for the server\nconst domain = require(&#39;domain&#39;);\nconst http = require(&#39;http&#39;);\nconst serverDomain = domain.create();\n\nserverDomain.run(() =&gt; {\n  // server is created in the scope of serverDomain\n  http.createServer((req, res) =&gt; {\n    // req and res are also created in the scope of serverDomain\n    // however, we&#39;d prefer to have a separate domain for each request.\n    // create it first thing, and add req and res to it.\n    var reqd = domain.create();\n    reqd.add(req);\n    reqd.add(res);\n    reqd.on(&#39;error&#39;, (er) =&gt; {\n      console.error(&#39;Error&#39;, er, req.url);\n      try {\n        res.writeHead(500);\n        res.end(&#39;Error occurred, sorry.&#39;);\n      } catch (er) {\n        console.error(&#39;Error sending 500&#39;, er, req.url);\n      }\n    });\n  }).listen(1337);\n});\n</code></pre>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "domain.create()",
          "type": "method",
          "name": "create",
          "signatures": [
            {
              "return": {
                "textRaw": "return: {Domain} ",
                "name": "return",
                "type": "Domain"
              },
              "params": []
            },
            {
              "params": []
            }
          ],
          "desc": "<p>Returns a new Domain object.</p>\n"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Domain",
          "type": "class",
          "name": "Domain",
          "desc": "<p>The Domain class encapsulates the functionality of routing errors and\nuncaught exceptions to the active Domain object.</p>\n<p>Domain is a child class of [<code>EventEmitter</code>][].  To handle the errors that it\ncatches, listen to its <code>&#39;error&#39;</code> event.</p>\n",
          "methods": [
            {
              "textRaw": "domain.run(fn[, arg][, ...])",
              "type": "method",
              "name": "run",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`fn` {Function} ",
                      "name": "fn",
                      "type": "Function"
                    },
                    {
                      "name": "arg",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "fn"
                    },
                    {
                      "name": "arg",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Run the supplied function in the context of the domain, implicitly\nbinding all event emitters, timers, and lowlevel requests that are\ncreated in that context. Optionally, arguments can be passed to\nthe function.</p>\n<p>This is the most basic way to use a domain.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const domain = require(&#39;domain&#39;);\nconst fs = require(&#39;fs&#39;);\nconst d = domain.create();\nd.on(&#39;error&#39;, (er) =&gt; {\n  console.error(&#39;Caught error!&#39;, er);\n});\nd.run(() =&gt; {\n  process.nextTick(() =&gt; {\n    setTimeout(() =&gt; { // simulating some various async stuff\n      fs.open(&#39;non-existent file&#39;, &#39;r&#39;, (er, fd) =&gt; {\n        if (er) throw er;\n        // proceed...\n      });\n    }, 100);\n  });\n});\n</code></pre>\n<p>In this example, the <code>d.on(&#39;error&#39;)</code> handler will be triggered, rather\nthan crashing the program.</p>\n"
            },
            {
              "textRaw": "domain.add(emitter)",
              "type": "method",
              "name": "add",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`emitter` {EventEmitter|Timer} emitter or timer to be added to the domain ",
                      "name": "emitter",
                      "type": "EventEmitter|Timer",
                      "desc": "emitter or timer to be added to the domain"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "emitter"
                    }
                  ]
                }
              ],
              "desc": "<p>Explicitly adds an emitter to the domain.  If any event handlers called by\nthe emitter throw an error, or if the emitter emits an <code>&#39;error&#39;</code> event, it\nwill be routed to the domain&#39;s <code>&#39;error&#39;</code> event, just like with implicit\nbinding.</p>\n<p>This also works with timers that are returned from [<code>setInterval()</code>][] and\n[<code>setTimeout()</code>][].  If their callback function throws, it will be caught by\nthe domain &#39;error&#39; handler.</p>\n<p>If the Timer or EventEmitter was already bound to a domain, it is removed\nfrom that one, and bound to this one instead.</p>\n"
            },
            {
              "textRaw": "domain.remove(emitter)",
              "type": "method",
              "name": "remove",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`emitter` {EventEmitter|Timer} emitter or timer to be removed from the domain ",
                      "name": "emitter",
                      "type": "EventEmitter|Timer",
                      "desc": "emitter or timer to be removed from the domain"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "emitter"
                    }
                  ]
                }
              ],
              "desc": "<p>The opposite of [<code>domain.add(emitter)</code>][].  Removes domain handling from the\nspecified emitter.</p>\n"
            },
            {
              "textRaw": "domain.bind(callback)",
              "type": "method",
              "name": "bind",
              "signatures": [
                {
                  "return": {
                    "textRaw": "return: {Function} The bound function ",
                    "name": "return",
                    "type": "Function",
                    "desc": "The bound function"
                  },
                  "params": [
                    {
                      "textRaw": "`callback` {Function} The callback function ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "The callback function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>The returned function will be a wrapper around the supplied callback\nfunction.  When the returned function is called, any errors that are\nthrown will be routed to the domain&#39;s <code>&#39;error&#39;</code> event.</p>\n<h4>Example</h4>\n<pre><code class=\"lang-js\">const d = domain.create();\n\nfunction readSomeFile(filename, cb) {\n  fs.readFile(filename, &#39;utf8&#39;, d.bind((er, data) =&gt; {\n    // if this throws, it will also be passed to the domain\n    return cb(er, data ? JSON.parse(data) : null);\n  }));\n}\n\nd.on(&#39;error&#39;, (er) =&gt; {\n  // an error occurred somewhere.\n  // if we throw it now, it will crash the program\n  // with the normal line number and stack message.\n});\n</code></pre>\n"
            },
            {
              "textRaw": "domain.intercept(callback)",
              "type": "method",
              "name": "intercept",
              "signatures": [
                {
                  "return": {
                    "textRaw": "return: {Function} The intercepted function ",
                    "name": "return",
                    "type": "Function",
                    "desc": "The intercepted function"
                  },
                  "params": [
                    {
                      "textRaw": "`callback` {Function} The callback function ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "The callback function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>This method is almost identical to [<code>domain.bind(callback)</code>][].  However, in\naddition to catching thrown errors, it will also intercept [<code>Error</code>][]\nobjects sent as the first argument to the function.</p>\n<p>In this way, the common <code>if (err) return callback(err);</code> pattern can be replaced\nwith a single error handler in a single place.</p>\n<h4>Example</h4>\n<pre><code class=\"lang-js\">const d = domain.create();\n\nfunction readSomeFile(filename, cb) {\n  fs.readFile(filename, &#39;utf8&#39;, d.intercept((data) =&gt; {\n    // note, the first argument is never passed to the\n    // callback since it is assumed to be the &#39;Error&#39; argument\n    // and thus intercepted by the domain.\n\n    // if this throws, it will also be passed to the domain\n    // so the error-handling logic can be moved to the &#39;error&#39;\n    // event on the domain instead of being repeated throughout\n    // the program.\n    return cb(null, JSON.parse(data));\n  }));\n}\n\nd.on(&#39;error&#39;, (er) =&gt; {\n  // an error occurred somewhere.\n  // if we throw it now, it will crash the program\n  // with the normal line number and stack message.\n});\n</code></pre>\n"
            },
            {
              "textRaw": "domain.enter()",
              "type": "method",
              "name": "enter",
              "desc": "<p>The <code>enter</code> method is plumbing used by the <code>run</code>, <code>bind</code>, and <code>intercept</code>\nmethods to set the active domain. It sets <code>domain.active</code> and <code>process.domain</code>\nto the domain, and implicitly pushes the domain onto the domain stack managed\nby the domain module (see [<code>domain.exit()</code>][] for details on the domain stack). The\ncall to <code>enter</code> delimits the beginning of a chain of asynchronous calls and I/O\noperations bound to a domain.</p>\n<p>Calling <code>enter</code> changes only the active domain, and does not alter the domain\nitself. <code>enter</code> and <code>exit</code> can be called an arbitrary number of times on a\nsingle domain.</p>\n<p>If the domain on which <code>enter</code> is called has been disposed, <code>enter</code> will return\nwithout setting the domain.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "domain.exit()",
              "type": "method",
              "name": "exit",
              "desc": "<p>The <code>exit</code> method exits the current domain, popping it off the domain stack.\nAny time execution is going to switch to the context of a different chain of\nasynchronous calls, it&#39;s important to ensure that the current domain is exited.\nThe call to <code>exit</code> delimits either the end of or an interruption to the chain\nof asynchronous calls and I/O operations bound to a domain.</p>\n<p>If there are multiple, nested domains bound to the current execution context,\n<code>exit</code> will exit any domains nested within this domain.</p>\n<p>Calling <code>exit</code> changes only the active domain, and does not alter the domain\nitself. <code>enter</code> and <code>exit</code> can be called an arbitrary number of times on a\nsingle domain.</p>\n<p>If the domain on which <code>exit</code> is called has been disposed, <code>exit</code> will return\nwithout exiting the domain.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "domain.dispose()",
              "type": "method",
              "name": "dispose",
              "desc": "<pre><code>Stability: 0 - Deprecated.  Please recover from failed IO actions\nexplicitly via error event handlers set on the domain.\n</code></pre><p>Once <code>dispose</code> has been called, the domain will no longer be used by callbacks\nbound into the domain via <code>run</code>, <code>bind</code>, or <code>intercept</code>, and a <code>&#39;dispose&#39;</code> event\nis emitted.</p>\n<!-- [end-include:domain.md] -->\n<!-- [start-include:errors.md] -->\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "`members` {Array} ",
              "type": "Array",
              "name": "members",
              "desc": "<p>An array of timers and event emitters that have been explicitly added\nto the domain.</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Domain"
    },
    {
      "textRaw": "Events",
      "name": "Events",
      "stability": 2,
      "stabilityText": "Stable",
      "type": "module",
      "desc": "<p>Much of the Node.js core API is built around an idiomatic asynchronous\nevent-driven architecture in which certain kinds of objects (called &quot;emitters&quot;)\nperiodically emit named events that cause Function objects (&quot;listeners&quot;) to be\ncalled.</p>\n<p>For instance: a [<code>net.Server</code>][] object emits an event each time a peer\nconnects to it; a [<code>fs.ReadStream</code>][] emits an event when the file is opened;\na [stream][] emits an event whenever data is available to be read.</p>\n<p>All objects that emit events are instances of the <code>EventEmitter</code> class. These\nobjects expose an <code>eventEmitter.on()</code> function that allows one or more\nFunctions to be attached to named events emitted by the object. Typically,\nevent names are camel-cased strings but any valid JavaScript property key\ncan be used.</p>\n<p>When the <code>EventEmitter</code> object emits an event, all of the Functions attached\nto that specific event are called <em>synchronously</em>. Any values returned by the\ncalled listeners are <em>ignored</em> and will be discarded.</p>\n<p>The following example shows a simple <code>EventEmitter</code> instance with a single\nlistener. The <code>eventEmitter.on()</code> method is used to register listeners, while\nthe <code>eventEmitter.emit()</code> method is used to trigger the event.</p>\n<pre><code class=\"lang-js\">const EventEmitter = require(&#39;events&#39;);\nconst util = require(&#39;util&#39;);\n\nfunction MyEmitter() {\n  EventEmitter.call(this);\n}\nutil.inherits(MyEmitter, EventEmitter);\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on(&#39;event&#39;, () =&gt; {\n  console.log(&#39;an event occurred!&#39;);\n});\nmyEmitter.emit(&#39;event&#39;);\n</code></pre>\n<p>Any object can become an <code>EventEmitter</code> through inheritance. The example above\nuses the traditional Node.js style prototypical inheritance using\nthe <code>util.inherits()</code> method. It is, however, possible to use ES6 classes as\nwell:</p>\n<pre><code class=\"lang-js\">const EventEmitter = require(&#39;events&#39;);\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on(&#39;event&#39;, () =&gt; {\n  console.log(&#39;an event occurred!&#39;);\n});\nmyEmitter.emit(&#39;event&#39;);\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "Passing arguments and `this` to listeners",
          "name": "passing_arguments_and_`this`_to_listeners",
          "desc": "<p>The <code>eventEmitter.emit()</code> method allows an arbitrary set of arguments to be\npassed to the listener functions. It is important to keep in mind that when an\nordinary listener function is called by the <code>EventEmitter</code>, the standard <code>this</code>\nkeyword is intentionally set to reference the <code>EventEmitter</code> to which the\nlistener is attached.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nmyEmitter.on(&#39;event&#39;, function(a, b) {\n  console.log(a, b, this);\n    // Prints:\n    //   a b MyEmitter {\n    //     domain: null,\n    //     _events: { event: [Function] },\n    //     _eventsCount: 1,\n    //     _maxListeners: undefined }\n});\nmyEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);\n</code></pre>\n<p>It is possible to use ES6 Arrow Functions as listeners, however, when doing so,\nthe <code>this</code> keyword will no longer reference the <code>EventEmitter</code> instance:</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nmyEmitter.on(&#39;event&#39;, (a, b) =&gt; {\n  console.log(a, b, this);\n    // Prints: a b {}\n});\nmyEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);\n</code></pre>\n",
          "type": "module",
          "displayName": "Passing arguments and `this` to listeners"
        },
        {
          "textRaw": "Asynchronous vs. Synchronous",
          "name": "asynchronous_vs._synchronous",
          "desc": "<p>The <code>EventListener</code> calls all listeners synchronously in the order in which\nthey were registered. This is important to ensure the proper sequencing of\nevents and to avoid race conditions or logic errors. When appropriate,\nlistener functions can switch to an asynchronous mode of operation using\nthe <code>setImmediate()</code> or <code>process.nextTick()</code> methods:</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nmyEmitter.on(&#39;event&#39;, (a, b) =&gt; {\n  setImmediate(() =&gt; {\n    console.log(&#39;this happens asynchronously&#39;);\n  });\n});\nmyEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);\n</code></pre>\n",
          "type": "module",
          "displayName": "Asynchronous vs. Synchronous"
        },
        {
          "textRaw": "Handling events only once",
          "name": "handling_events_only_once",
          "desc": "<p>When a listener is registered using the <code>eventEmitter.on()</code> method, that\nlistener will be invoked <em>every time</em> the named event is emitted.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nvar m = 0;\nmyEmitter.on(&#39;event&#39;, () =&gt; {\n  console.log(++m);\n});\nmyEmitter.emit(&#39;event&#39;);\n  // Prints: 1\nmyEmitter.emit(&#39;event&#39;);\n  // Prints: 2\n</code></pre>\n<p>Using the <code>eventEmitter.once()</code> method, it is possible to register a listener\nthat is unregistered before it is called.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nvar m = 0;\nmyEmitter.once(&#39;event&#39;, () =&gt; {\n  console.log(++m);\n});\nmyEmitter.emit(&#39;event&#39;);\n  // Prints: 1\nmyEmitter.emit(&#39;event&#39;);\n  // Ignored\n</code></pre>\n",
          "type": "module",
          "displayName": "Handling events only once"
        },
        {
          "textRaw": "Error events",
          "name": "error_events",
          "desc": "<p>When an error occurs within an <code>EventEmitter</code> instance, the typical action is\nfor an <code>&#39;error&#39;</code> event to be emitted. These are treated as a special case\nwithin Node.js.</p>\n<p>If an <code>EventEmitter</code> does <em>not</em> have at least one listener registered for the\n<code>&#39;error&#39;</code> event, and an <code>&#39;error&#39;</code> event is emitted, the error is thrown, a\nstack trace is printed, and the Node.js process exits.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nmyEmitter.emit(&#39;error&#39;, new Error(&#39;whoops!&#39;));\n  // Throws and crashes Node.js\n</code></pre>\n<p>To guard against crashing the Node.js process, developers can either register\na listener for the <code>process.on(&#39;uncaughtException&#39;)</code> event or use the\n[<code>domain</code>][] module (<em>Note, however, that the <code>domain</code> module has been\ndeprecated</em>).</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\n\nprocess.on(&#39;uncaughtException&#39;, (err) =&gt; {\n  console.log(&#39;whoops! there was an error&#39;);\n});\n\nmyEmitter.emit(&#39;error&#39;, new Error(&#39;whoops!&#39;));\n  // Prints: whoops! there was an error\n</code></pre>\n<p>As a best practice, developers should always register listeners for the\n<code>&#39;error&#39;</code> event:</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nmyEmitter.on(&#39;error&#39;, (err) =&gt; {\n  console.log(&#39;whoops! there was an error&#39;);\n});\nmyEmitter.emit(&#39;error&#39;, new Error(&#39;whoops!&#39;));\n  // Prints: whoops! there was an error\n</code></pre>\n",
          "type": "module",
          "displayName": "Error events"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: EventEmitter",
          "type": "class",
          "name": "EventEmitter",
          "desc": "<p>The <code>EventEmitter</code> class is defined and exposed by the <code>events</code> module:</p>\n<pre><code class=\"lang-js\">const EventEmitter = require(&#39;events&#39;);\n</code></pre>\n<p>All EventEmitters emit the event <code>&#39;newListener&#39;</code> when new listeners are\nadded and <code>&#39;removeListener&#39;</code> when a listener is removed.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'newListener'",
              "type": "event",
              "name": "newListener",
              "params": [],
              "desc": "<p>The <code>EventEmitter</code> instance will emit it&#39;s own <code>&#39;newListener&#39;</code> event <em>before</em>\na listener is added to it&#39;s internal array of listeners.</p>\n<p>Listeners registered for the <code>&#39;newListener&#39;</code> event will be passed the event\nname and a reference to the listener being added.</p>\n<p>The fact that the event is triggered before adding the listener has a subtle\nbut important side effect: any <em>additional</em> listeners registered to the same\n<code>name</code> <em>within</em> the <code>&#39;newListener&#39;</code> callback will be inserted <em>before</em> the\nlistener that is in the process of being added.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\n// Only do this once so we don&#39;t loop forever\nmyEmitter.once(&#39;newListener&#39;, (event, listener) =&gt; {\n  if (event === &#39;event&#39;) {\n    // Insert a new listener in front\n    myEmitter.on(&#39;event&#39;, () =&gt; {\n      console.log(&#39;B&#39;);\n    });\n  }\n});\nmyEmitter.on(&#39;event&#39;, () =&gt; {\n  console.log(&#39;A&#39;);\n});\nmyEmitter.emit(&#39;event&#39;);\n  // Prints:\n  //   B\n  //   A\n</code></pre>\n"
            },
            {
              "textRaw": "Event: 'removeListener'",
              "type": "event",
              "name": "removeListener",
              "params": [],
              "desc": "<p>The <code>&#39;removeListener&#39;</code> event is emitted <em>after</em> a listener is removed.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "EventEmitter.listenerCount(emitter, eventName)",
              "type": "method",
              "name": "listenerCount",
              "stability": 0,
              "stabilityText": "Deprecated: Use [`emitter.listenerCount()`][] instead.",
              "desc": "<p>A class method that returns the number of listeners for the given <code>eventName</code>\nregistered on the given <code>emitter</code>.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\nmyEmitter.on(&#39;event&#39;, () =&gt; {});\nmyEmitter.on(&#39;event&#39;, () =&gt; {});\nconsole.log(EventEmitter.listenerCount(myEmitter, &#39;event&#39;));\n  // Prints: 2\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "emitter"
                    },
                    {
                      "name": "eventName"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.addListener(eventName, listener)",
              "type": "method",
              "name": "addListener",
              "desc": "<p>Alias for <code>emitter.on(eventName, listener)</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.emit(eventName[, arg1][, arg2][, ...])",
              "type": "method",
              "name": "emit",
              "desc": "<p>Synchronously calls each of the listeners registered for the event named\n<code>eventName</code>, in the order they were registered, passing the supplied arguments\nto each.</p>\n<p>Returns <code>true</code> if the event had listeners, <code>false</code> otherwise.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    },
                    {
                      "name": "arg1",
                      "optional": true
                    },
                    {
                      "name": "arg2",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.getMaxListeners()",
              "type": "method",
              "name": "getMaxListeners",
              "desc": "<p>Returns the current max listener value for the <code>EventEmitter</code> which is either\nset by [<code>emitter.setMaxListeners(n)</code>][] or defaults to\n[<code>EventEmitter.defaultMaxListeners</code>][].</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "emitter.listenerCount(eventName)",
              "type": "method",
              "name": "listenerCount",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`eventName` {Value} The name of the event being listened for ",
                      "name": "eventName",
                      "type": "Value",
                      "desc": "The name of the event being listened for"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "eventName"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns the number of listeners listening to the event named <code>eventName</code>.</p>\n"
            },
            {
              "textRaw": "emitter.listeners(eventName)",
              "type": "method",
              "name": "listeners",
              "desc": "<p>Returns a copy of the array of listeners for the event named <code>eventName</code>.</p>\n<pre><code class=\"lang-js\">server.on(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;someone connected!&#39;);\n});\nconsole.log(util.inspect(server.listeners(&#39;connection&#39;)));\n  // Prints: [ [Function] ]\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.on(eventName, listener)",
              "type": "method",
              "name": "on",
              "desc": "<p>Adds the <code>listener</code> function to the end of the listeners array for the\nevent named <code>eventName</code>. No checks are made to see if the <code>listener</code> has\nalready been added. Multiple calls passing the same combination of <code>eventName</code>\nand <code>listener</code> will result in the <code>listener</code> being added, and called, multiple\ntimes.</p>\n<pre><code class=\"lang-js\">server.on(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;someone connected!&#39;);\n});\n</code></pre>\n<p>Returns a reference to the <code>EventEmitter</code> so calls can be chained.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.once(eventName, listener)",
              "type": "method",
              "name": "once",
              "desc": "<p>Adds a <strong>one time</strong> <code>listener</code> function for the event named <code>eventName</code>. The\nnext time <code>eventName</code> is triggered, this listener is removed and then invoked.</p>\n<pre><code class=\"lang-js\">server.once(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;Ah, we have our first user!&#39;);\n});\n</code></pre>\n<p>Returns a reference to the <code>EventEmitter</code> so calls can be chained.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.removeAllListeners([eventName])",
              "type": "method",
              "name": "removeAllListeners",
              "desc": "<p>Removes all listeners, or those of the specified <code>eventName</code>.</p>\n<p>Note that it is bad practice to remove listeners added elsewhere in the code,\nparticularly when the <code>EventEmitter</code> instance was created by some other\ncomponent or module (e.g. sockets or file streams).</p>\n<p>Returns a reference to the <code>EventEmitter</code> so calls can be chained.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.removeListener(eventName, listener)",
              "type": "method",
              "name": "removeListener",
              "desc": "<p>Removes the specified <code>listener</code> from the listener array for the event named\n<code>eventName</code>.</p>\n<pre><code class=\"lang-js\">var callback = (stream) =&gt; {\n  console.log(&#39;someone connected!&#39;);\n};\nserver.on(&#39;connection&#39;, callback);\n// ...\nserver.removeListener(&#39;connection&#39;, callback);\n</code></pre>\n<p><code>removeListener</code> will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified <code>eventName</code>, then <code>removeListener</code> must be\ncalled multiple times to remove each instance.</p>\n<p>Note that once an event has been emitted, all listeners attached to it at the\ntime of emitting will be called in order. This implies that any <code>removeListener()</code>\nor <code>removeAllListeners()</code> calls <em>after</em> emitting and <em>before</em> the last listener\nfinishes execution will not remove them from <code>emit()</code> in progress. Subsequent\nevents will behave as expected.</p>\n<pre><code class=\"lang-js\">const myEmitter = new MyEmitter();\n\nvar callbackA = () =&gt; {\n  console.log(&#39;A&#39;);\n  myEmitter.removeListener(&#39;event&#39;, callbackB);\n};\n\nvar callbackB = () =&gt; {\n  console.log(&#39;B&#39;);\n};\n\nmyEmitter.on(&#39;event&#39;, callbackA);\n\nmyEmitter.on(&#39;event&#39;, callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit(&#39;event&#39;);\n  // Prints:\n  //   A\n  //   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit(&#39;event&#39;);\n  // Prints:\n  //   A\n</code></pre>\n<p>Because listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered <em>after</em> the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it will means that any copies of the listener array as returned by\nthe <code>emitter.listeners()</code> method will need to be recreated.</p>\n<p>Returns a reference to the <code>EventEmitter</code> so calls can be chained.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "eventName"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.setMaxListeners(n)",
              "type": "method",
              "name": "setMaxListeners",
              "desc": "<p>By default EventEmitters will print a warning if more than <code>10</code> listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. Obviously, not all events should be limited to just 10 listeners.\nThe <code>emitter.setMaxListeners()</code> method allows the limit to be modified for this\nspecific <code>EventEmitter</code> instance. The value can be set to <code>Infinity</code> (or <code>0</code>)\nto indicate an unlimited number of listeners.</p>\n<p>Returns a reference to the <code>EventEmitter</code> so calls can be chained.</p>\n<!-- [end-include:events.md] -->\n<!-- [start-include:fs.md] -->\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "n"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "EventEmitter.defaultMaxListeners",
              "name": "defaultMaxListeners",
              "desc": "<p>By default, a maximum of <code>10</code> listeners can be registered for any single\nevent. This limit can be changed for individual <code>EventEmitter</code> instances\nusing the [<code>emitter.setMaxListeners(n)</code>][] method. To change the default\nfor <em>all</em> <code>EventEmitter</code> instances, the <code>EventEmitter.defaultMaxListeners</code>\nproperty can be used.</p>\n<p>Take caution when setting the <code>EventEmitter.defaultMaxListeners</code> because the\nchange effects <em>all</em> <code>EventEmitter</code> instances, including those created before\nthe change is made. However, calling [<code>emitter.setMaxListeners(n)</code>][] still has\nprecedence over <code>EventEmitter.defaultMaxListeners</code>.</p>\n<p>Note that this is not a hard limit. The <code>EventEmitter</code> instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a <code>possible EventEmitter memory leak</code> has been detected. For any single\n<code>EventEmitter</code>, the <code>emitter.getMaxListeners()</code> and <code>emitter.setMaxListeners()</code>\nmethods can be used to temporarily avoid this warning:</p>\n<pre><code class=\"lang-js\">emitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once(&#39;event&#39;, () =&gt; {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n</code></pre>\n"
            }
          ]
        }
      ]
    },
    {
      "textRaw": "File System",
      "name": "fs",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>File I/O is provided by simple wrappers around standard POSIX functions.  To\nuse this module do <code>require(&#39;fs&#39;)</code>. All the methods have asynchronous and\nsynchronous forms.</p>\n<p>The asynchronous form always takes a completion callback as its last argument.\nThe arguments passed to the completion callback depend on the method, but the\nfirst argument is always reserved for an exception. If the operation was\ncompleted successfully, then the first argument will be <code>null</code> or <code>undefined</code>.</p>\n<p>When using the synchronous form any exceptions are immediately thrown.\nYou can use try/catch to handle exceptions or allow them to bubble up.</p>\n<p>Here is an example of the asynchronous version:</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\n\nfs.unlink(&#39;/tmp/hello&#39;, (err) =&gt; {\n  if (err) throw err;\n  console.log(&#39;successfully deleted /tmp/hello&#39;);\n});\n</code></pre>\n<p>Here is the synchronous version:</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\n\nfs.unlinkSync(&#39;/tmp/hello&#39;);\nconsole.log(&#39;successfully deleted /tmp/hello&#39;);\n</code></pre>\n<p>With the asynchronous methods there is no guaranteed ordering. So the\nfollowing is prone to error:</p>\n<pre><code class=\"lang-js\">fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, (err) =&gt; {\n  if (err) throw err;\n  console.log(&#39;renamed complete&#39;);\n});\nfs.stat(&#39;/tmp/world&#39;, (err, stats) =&gt; {\n  if (err) throw err;\n  console.log(`stats: ${JSON.stringify(stats)}`);\n});\n</code></pre>\n<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.\nThe correct way to do this is to chain the callbacks.</p>\n<pre><code class=\"lang-js\">fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, (err) =&gt; {\n  if (err) throw err;\n  fs.stat(&#39;/tmp/world&#39;, (err, stats) =&gt; {\n    if (err) throw err;\n    console.log(`stats: ${JSON.stringify(stats)}`);\n  });\n});\n</code></pre>\n<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the\nasynchronous versions of these calls. The synchronous versions will block\nthe entire process until they complete--halting all connections.</p>\n<p>The relative path to a filename can be used. Remember, however, that this path\nwill be relative to <code>process.cwd()</code>.</p>\n<p>Most fs functions let you omit the callback argument. If you do, a default\ncallback is used that rethrows errors. To get a trace to the original call\nsite, set the <code>NODE_DEBUG</code> environment variable:</p>\n<pre><code>$ cat script.js\nfunction bad() {\n  require(&#39;fs&#39;).readFile(&#39;/&#39;);\n}\nbad();\n\n$ env NODE_DEBUG=fs node script.js\nfs.js:66\n        throw err;\n              ^\nError: EISDIR, read\n    at rethrow (fs.js:61:21)\n    at maybeCallback (fs.js:79:42)\n    at Object.fs.readFile (fs.js:153:18)\n    at bad (/path/to/script.js:2:17)\n    at Object.&lt;anonymous&gt; (/path/to/script.js:5:1)\n    &lt;etc.&gt;\n</code></pre>",
      "classes": [
        {
          "textRaw": "Class: fs.FSWatcher",
          "type": "class",
          "name": "fs.FSWatcher",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Objects returned from <code>fs.watch()</code> are of this type.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'change'",
              "type": "event",
              "name": "change",
              "meta": {
                "added": [
                  "v0.5.8"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when something changes in a watched directory or file.\nSee more details in [<code>fs.watch()</code>][].</p>\n"
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "meta": {
                "added": [
                  "v0.5.8"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when an error occurs.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "watcher.close()",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.5.8"
                ]
              },
              "desc": "<p>Stop watching for changes on the given <code>fs.FSWatcher</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: fs.ReadStream",
          "type": "class",
          "name": "fs.ReadStream",
          "meta": {
            "added": [
              "v0.1.93"
            ]
          },
          "desc": "<p><code>ReadStream</code> is a [Readable Stream][].</p>\n",
          "events": [
            {
              "textRaw": "Event: 'open'",
              "type": "event",
              "name": "open",
              "meta": {
                "added": [
                  "v0.1.93"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when the ReadStream&#39;s file is opened.</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.93"
                ]
              },
              "desc": "<p>Emitted when the <code>ReadStream</code>&#39;s underlying file descriptor has been closed\nusing the <code>fs.close()</code> method.</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "readStream.path",
              "name": "path",
              "meta": {
                "added": [
                  "v0.1.93"
                ]
              },
              "desc": "<p>The path to the file the stream is reading from.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: fs.Stats",
          "type": "class",
          "name": "fs.Stats",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Objects returned from [<code>fs.stat()</code>][], [<code>fs.lstat()</code>][] and [<code>fs.fstat()</code>][] and their\nsynchronous counterparts are of this type.</p>\n<ul>\n<li><code>stats.isFile()</code></li>\n<li><code>stats.isDirectory()</code></li>\n<li><code>stats.isBlockDevice()</code></li>\n<li><code>stats.isCharacterDevice()</code></li>\n<li><code>stats.isSymbolicLink()</code> (only valid with [<code>fs.lstat()</code>][])</li>\n<li><code>stats.isFIFO()</code></li>\n<li><code>stats.isSocket()</code></li>\n</ul>\n<p>For a regular file [<code>util.inspect(stats)</code>][] would return a string very\nsimilar to this:</p>\n<pre><code class=\"lang-js\">{\n  dev: 2114,\n  ino: 48064969,\n  mode: 33188,\n  nlink: 1,\n  uid: 85,\n  gid: 100,\n  rdev: 0,\n  size: 527,\n  blksize: 4096,\n  blocks: 8,\n  atime: Mon, 10 Oct 2011 23:24:11 GMT,\n  mtime: Mon, 10 Oct 2011 23:24:11 GMT,\n  ctime: Mon, 10 Oct 2011 23:24:11 GMT,\n  birthtime: Mon, 10 Oct 2011 23:24:11 GMT\n}\n</code></pre>\n<p>Please note that <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> are\ninstances of [<code>Date</code>][MDN-Date] object and to compare the values of\nthese objects you should use appropriate methods. For most general\nuses [<code>getTime()</code>][MDN-Date-getTime] will return the number of\nmilliseconds elapsed since <em>1 January 1970 00:00:00 UTC</em> and this\ninteger should be sufficient for any comparison, however there are\nadditional methods which can be used for displaying fuzzy information.\nMore details can be found in the [MDN JavaScript Reference][MDN-Date]\npage.</p>\n",
          "modules": [
            {
              "textRaw": "Stat Time Values",
              "name": "stat_time_values",
              "desc": "<p>The times in the stat object have the following semantics:</p>\n<ul>\n<li><code>atime</code> &quot;Access Time&quot; - Time when file data last accessed.  Changed\nby the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> system calls.</li>\n<li><code>mtime</code> &quot;Modified Time&quot; - Time when file data last modified.\nChanged by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> system calls.</li>\n<li><code>ctime</code> &quot;Change Time&quot; - Time when file status was last changed\n(inode data modification).  Changed by the <code>chmod(2)</code>, <code>chown(2)</code>,\n<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,\n<code>read(2)</code>, and <code>write(2)</code> system calls.</li>\n<li><code>birthtime</code> &quot;Birth Time&quot; -  Time of file creation. Set once when the\nfile is created.  On filesystems where birthtime is not available,\nthis field may instead hold either the <code>ctime</code> or\n<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>). Note that this\nvalue may be greater than <code>atime</code> or <code>mtime</code> in this case. On Darwin\nand other FreeBSD variants, also set if the <code>atime</code> is explicitly\nset to an earlier value than the current <code>birthtime</code> using the\n<code>utimes(2)</code> system call.</li>\n</ul>\n<p>Prior to Node v0.12, the <code>ctime</code> held the <code>birthtime</code> on Windows\nsystems.  Note that as of v0.12, <code>ctime</code> is not &quot;creation time&quot;, and\non Unix systems, it never was.</p>\n",
              "type": "module",
              "displayName": "Stat Time Values"
            }
          ]
        },
        {
          "textRaw": "Class: fs.WriteStream",
          "type": "class",
          "name": "fs.WriteStream",
          "meta": {
            "added": [
              "v0.1.93"
            ]
          },
          "desc": "<p><code>WriteStream</code> is a [Writable Stream][].</p>\n",
          "events": [
            {
              "textRaw": "Event: 'open'",
              "type": "event",
              "name": "open",
              "meta": {
                "added": [
                  "v0.1.93"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when the WriteStream&#39;s file is opened.</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.93"
                ]
              },
              "desc": "<p>Emitted when the <code>WriteStream</code>&#39;s underlying file descriptor has been closed\nusing the <code>fs.close()</code> method.</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "writeStream.bytesWritten",
              "name": "bytesWritten",
              "meta": {
                "added": [
                  "v0.4.7"
                ]
              },
              "desc": "<p>The number of bytes written so far. Does not include data that is still queued\nfor writing.</p>\n"
            },
            {
              "textRaw": "writeStream.path",
              "name": "path",
              "meta": {
                "added": [
                  "v0.1.93"
                ]
              },
              "desc": "<p>The path to the file the stream is writing to.</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "fs.access(path[, mode], callback)",
          "type": "method",
          "name": "access",
          "meta": {
            "added": [
              "v0.11.15"
            ]
          },
          "desc": "<p>Tests a user&#39;s permissions for the file specified by <code>path</code>. <code>mode</code> is an\noptional integer that specifies the accessibility checks to be performed. The\nfollowing constants define the possible values of <code>mode</code>. It is possible to\ncreate a mask consisting of the bitwise OR of two or more values.</p>\n<ul>\n<li><code>fs.F_OK</code> - File is visible to the calling process. This is useful for\ndetermining if a file exists, but says nothing about <code>rwx</code> permissions.\nDefault if no <code>mode</code> is specified.</li>\n<li><code>fs.R_OK</code> - File can be read by the calling process.</li>\n<li><code>fs.W_OK</code> - File can be written by the calling process.</li>\n<li><code>fs.X_OK</code> - File can be executed by the calling process. This has no effect\non Windows (will behave like <code>fs.F_OK</code>).</li>\n</ul>\n<p>The final argument, <code>callback</code>, is a callback function that is invoked with\na possible error argument. If any of the accessibility checks fail, the error\nargument will be populated. The following example checks if the file\n<code>/etc/passwd</code> can be read and written by the current process.</p>\n<pre><code class=\"lang-js\">fs.access(&#39;/etc/passwd&#39;, fs.R_OK | fs.W_OK, (err) =&gt; {\n  console.log(err ? &#39;no access!&#39; : &#39;can read/write&#39;);\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.accessSync(path[, mode])",
          "type": "method",
          "name": "accessSync",
          "meta": {
            "added": [
              "v0.11.15"
            ]
          },
          "desc": "<p>Synchronous version of [<code>fs.access()</code>][]. This throws if any accessibility checks\nfail, and does nothing otherwise.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.appendFile(file, data[, options], callback)",
          "type": "method",
          "name": "appendFile",
          "meta": {
            "added": [
              "v0.6.7"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`file` {String} filename ",
                  "name": "file",
                  "type": "String",
                  "desc": "filename"
                },
                {
                  "textRaw": "`data` {String|Buffer} ",
                  "name": "data",
                  "type": "String|Buffer"
                },
                {
                  "textRaw": "`options` {Object|String} ",
                  "options": [
                    {
                      "textRaw": "`encoding` {String|Null} default = `'utf8'` ",
                      "name": "encoding",
                      "type": "String|Null",
                      "desc": "default = `'utf8'`"
                    },
                    {
                      "textRaw": "`mode` {Number} default = `0o666` ",
                      "name": "mode",
                      "type": "Number",
                      "desc": "default = `0o666`"
                    },
                    {
                      "textRaw": "`flag` {String} default = `'a'` ",
                      "name": "flag",
                      "type": "String",
                      "desc": "default = `'a'`"
                    }
                  ],
                  "name": "options",
                  "type": "Object|String",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Asynchronously append data to a file, creating the file if it does not yet exist.\n<code>data</code> can be a string or a buffer.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, (err) =&gt; {\n  if (err) throw err;\n  console.log(&#39;The &quot;data to append&quot; was appended to file!&#39;);\n});\n</code></pre>\n<p>If <code>options</code> is a string, then it specifies the encoding. Example:</p>\n<pre><code class=\"lang-js\">fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, &#39;utf8&#39;, callback);\n</code></pre>\n"
        },
        {
          "textRaw": "fs.appendFileSync(file, data[, options])",
          "type": "method",
          "name": "appendFileSync",
          "meta": {
            "added": [
              "v0.6.7"
            ]
          },
          "desc": "<p>The synchronous version of [<code>fs.appendFile()</code>][]. Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmod(path, mode, callback)",
          "type": "method",
          "name": "chmod",
          "meta": {
            "added": [
              "v0.1.30"
            ]
          },
          "desc": "<p>Asynchronous chmod(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmodSync(path, mode)",
          "type": "method",
          "name": "chmodSync",
          "meta": {
            "added": [
              "v0.6.7"
            ]
          },
          "desc": "<p>Synchronous chmod(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chown(path, uid, gid, callback)",
          "type": "method",
          "name": "chown",
          "meta": {
            "added": [
              "v0.1.97"
            ]
          },
          "desc": "<p>Asynchronous chown(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chownSync(path, uid, gid)",
          "type": "method",
          "name": "chownSync",
          "meta": {
            "added": [
              "v0.1.97"
            ]
          },
          "desc": "<p>Synchronous chown(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.close(fd, callback)",
          "type": "method",
          "name": "close",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Asynchronous close(2).  No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.closeSync(fd)",
          "type": "method",
          "name": "closeSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous close(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createReadStream(path[, options])",
          "type": "method",
          "name": "createReadStream",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Returns a new [<code>ReadStream</code>][] object. (See [Readable Stream][]).</p>\n<p>Be aware that, unlike the default value set for <code>highWaterMark</code> on a\nreadable stream (16 kb), the stream returned by this method has a\ndefault value of 64 kb for the same parameter.</p>\n<p><code>options</code> is an object or string with the following defaults:</p>\n<pre><code class=\"lang-js\">{\n  flags: &#39;r&#39;,\n  encoding: null,\n  fd: null,\n  mode: 0o666,\n  autoClose: true\n}\n</code></pre>\n<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from\nthe file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and\nstart at 0. The <code>encoding</code> can be any one of those accepted by [<code>Buffer</code>][].</p>\n<p>If <code>fd</code> is specified, <code>ReadStream</code> will ignore the <code>path</code> argument and will use\nthe specified file descriptor. This means that no <code>&#39;open&#39;</code> event will be emitted.\nNote that <code>fd</code> should be blocking; non-blocking <code>fd</code>s should be passed to\n[<code>net.Socket</code>][].</p>\n<p>If <code>autoClose</code> is false, then the file descriptor won&#39;t be closed, even if\nthere&#39;s an error.  It is your responsibility to close it and make sure\nthere&#39;s no file descriptor leak.  If <code>autoClose</code> is set to true (default\nbehavior), on <code>error</code> or <code>end</code> the file descriptor will be closed\nautomatically.</p>\n<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the\nfile was created.</p>\n<p>An example to read the last 10 bytes of a file which is 100 bytes long:</p>\n<pre><code class=\"lang-js\">fs.createReadStream(&#39;sample.txt&#39;, {start: 90, end: 99});\n</code></pre>\n<p>If <code>options</code> is a string, then it specifies the encoding.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createWriteStream(path[, options])",
          "type": "method",
          "name": "createWriteStream",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Returns a new [<code>WriteStream</code>][] object. (See [Writable Stream][]).</p>\n<p><code>options</code> is an object or string with the following defaults:</p>\n<pre><code class=\"lang-js\">{\n  flags: &#39;w&#39;,\n  defaultEncoding: &#39;utf8&#39;,\n  fd: null,\n  mode: 0o666\n}\n</code></pre>\n<p><code>options</code> may also include a <code>start</code> option to allow writing data at\nsome position past the beginning of the file.  Modifying a file rather\nthan replacing it may require a <code>flags</code> mode of <code>r+</code> rather than the\ndefault mode <code>w</code>. The <code>defaultEncoding</code> can be any one of those accepted by [<code>Buffer</code>][].</p>\n<p>Like [<code>ReadStream</code>][], if <code>fd</code> is specified, <code>WriteStream</code> will ignore the\n<code>path</code> argument and will use the specified file descriptor. This means that no\n<code>&#39;open&#39;</code> event will be emitted. Note that <code>fd</code> should be blocking; non-blocking\n<code>fd</code>s should be passed to [<code>net.Socket</code>][].</p>\n<p>If <code>options</code> is a string, then it specifies the encoding.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.exists(path, callback)",
          "type": "method",
          "name": "exists",
          "meta": {
            "added": [
              "v0.0.2"
            ],
            "deprecated": [
              "v1.0.0"
            ]
          },
          "stability": 0,
          "stabilityText": "Deprecated: Use [`fs.stat()`][] or [`fs.access()`][] instead.",
          "desc": "<p>Test whether or not the given path exists by checking with the file system.\nThen call the <code>callback</code> argument with either true or false.  Example:</p>\n<pre><code class=\"lang-js\">fs.exists(&#39;/etc/passwd&#39;, (exists) =&gt; {\n  console.log(exists ? &#39;it\\&#39;s there&#39; : &#39;no passwd!&#39;);\n});\n</code></pre>\n<p><code>fs.exists()</code> should not be used to check if a file exists before calling\n<code>fs.open()</code>. Doing so introduces a race condition since other processes may\nchange the file&#39;s state between the two calls. Instead, user code should\ncall <code>fs.open()</code> directly and handle the error raised if the file is\nnon-existent.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.existsSync(path)",
          "type": "method",
          "name": "existsSync",
          "meta": {
            "added": [
              "v0.1.21"
            ],
            "deprecated": [
              "v1.0.0"
            ]
          },
          "stability": 0,
          "stabilityText": "Deprecated: Use [`fs.statSync()`][] or [`fs.accessSync()`][] instead.",
          "desc": "<p>Synchronous version of [<code>fs.exists()</code>][].\nReturns <code>true</code> if the file exists, <code>false</code> otherwise.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchmod(fd, mode, callback)",
          "type": "method",
          "name": "fchmod",
          "meta": {
            "added": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Asynchronous fchmod(2). No arguments other than a possible exception\nare given to the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchmodSync(fd, mode)",
          "type": "method",
          "name": "fchmodSync",
          "meta": {
            "added": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Synchronous fchmod(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchown(fd, uid, gid, callback)",
          "type": "method",
          "name": "fchown",
          "meta": {
            "added": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Asynchronous fchown(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchownSync(fd, uid, gid)",
          "type": "method",
          "name": "fchownSync",
          "meta": {
            "added": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Synchronous fchown(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fdatasync(fd, callback)",
          "type": "method",
          "name": "fdatasync",
          "meta": {
            "added": [
              "v0.1.96"
            ]
          },
          "desc": "<p>Asynchronous fdatasync(2). No arguments other than a possible exception are\ngiven to the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fdatasyncSync(fd)",
          "type": "method",
          "name": "fdatasyncSync",
          "meta": {
            "added": [
              "v0.1.96"
            ]
          },
          "desc": "<p>Synchronous fdatasync(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstat(fd, callback)",
          "type": "method",
          "name": "fstat",
          "meta": {
            "added": [
              "v0.1.95"
            ]
          },
          "desc": "<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where\n<code>stats</code> is a [<code>fs.Stats</code>][] object. <code>fstat()</code> is identical to [<code>stat()</code>][],\nexcept that the file to be stat-ed is specified by the file descriptor <code>fd</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstatSync(fd)",
          "type": "method",
          "name": "fstatSync",
          "meta": {
            "added": [
              "v0.1.95"
            ]
          },
          "desc": "<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fsync(fd, callback)",
          "type": "method",
          "name": "fsync",
          "meta": {
            "added": [
              "v0.1.96"
            ]
          },
          "desc": "<p>Asynchronous fsync(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fsyncSync(fd)",
          "type": "method",
          "name": "fsyncSync",
          "meta": {
            "added": [
              "v0.1.96"
            ]
          },
          "desc": "<p>Synchronous fsync(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.ftruncate(fd, len, callback)",
          "type": "method",
          "name": "ftruncate",
          "meta": {
            "added": [
              "v0.8.6"
            ]
          },
          "desc": "<p>Asynchronous ftruncate(2). No arguments other than a possible exception are\ngiven to the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "len"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.ftruncateSync(fd, len)",
          "type": "method",
          "name": "ftruncateSync",
          "meta": {
            "added": [
              "v0.8.6"
            ]
          },
          "desc": "<p>Synchronous ftruncate(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "len"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.futimes(fd, atime, mtime, callback)",
          "type": "method",
          "name": "futimes",
          "meta": {
            "added": [
              "v0.4.2"
            ]
          },
          "desc": "<p>Change the file timestamps of a file referenced by the supplied file\ndescriptor.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.futimesSync(fd, atime, mtime)",
          "type": "method",
          "name": "futimesSync",
          "meta": {
            "added": [
              "v0.4.2"
            ]
          },
          "desc": "<p>Synchronous version of [<code>fs.futimes()</code>][]. Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchmod(path, mode, callback)",
          "type": "method",
          "name": "lchmod",
          "meta": {
            "deprecated": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Asynchronous lchmod(2). No arguments other than a possible exception\nare given to the completion callback.</p>\n<p>Only available on Mac OS X.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchmodSync(path, mode)",
          "type": "method",
          "name": "lchmodSync",
          "meta": {
            "deprecated": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Synchronous lchmod(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchown(path, uid, gid, callback)",
          "type": "method",
          "name": "lchown",
          "meta": {
            "deprecated": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Asynchronous lchown(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchownSync(path, uid, gid)",
          "type": "method",
          "name": "lchownSync",
          "meta": {
            "deprecated": [
              "v0.4.7"
            ]
          },
          "desc": "<p>Synchronous lchown(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.link(srcpath, dstpath, callback)",
          "type": "method",
          "name": "link",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Asynchronous link(2). No arguments other than a possible exception are given to\nthe completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.linkSync(srcpath, dstpath)",
          "type": "method",
          "name": "linkSync",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Synchronous link(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstat(path, callback)",
          "type": "method",
          "name": "lstat",
          "meta": {
            "added": [
              "v0.1.30"
            ]
          },
          "desc": "<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where\n<code>stats</code> is a [<code>fs.Stats</code>][] object. <code>lstat()</code> is identical to <code>stat()</code>,\nexcept that if <code>path</code> is a symbolic link, then the link itself is stat-ed,\nnot the file that it refers to.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstatSync(path)",
          "type": "method",
          "name": "lstatSync",
          "meta": {
            "added": [
              "v0.1.30"
            ]
          },
          "desc": "<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdir(path[, mode], callback)",
          "type": "method",
          "name": "mkdir",
          "meta": {
            "added": [
              "v0.1.8"
            ]
          },
          "desc": "<p>Asynchronous mkdir(2). No arguments other than a possible exception are given\nto the completion callback. <code>mode</code> defaults to <code>0o777</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdirSync(path[, mode])",
          "type": "method",
          "name": "mkdirSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous mkdir(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.open(path, flags[, mode], callback)",
          "type": "method",
          "name": "open",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Asynchronous file open. See open(2). <code>flags</code> can be:</p>\n<ul>\n<li><p><code>&#39;r&#39;</code> - Open file for reading.\nAn exception occurs if the file does not exist.</p>\n</li>\n<li><p><code>&#39;r+&#39;</code> - Open file for reading and writing.\nAn exception occurs if the file does not exist.</p>\n</li>\n<li><p><code>&#39;rs&#39;</code> - Open file for reading in synchronous mode. Instructs the operating\nsystem to bypass the local file system cache.</p>\n<p>This is primarily useful for opening files on NFS mounts as it allows you to\nskip the potentially stale local cache. It has a very real impact on I/O\nperformance so don&#39;t use this flag unless you need it.</p>\n<p>Note that this doesn&#39;t turn <code>fs.open()</code> into a synchronous blocking call.\nIf that&#39;s what you want then you should be using <code>fs.openSync()</code></p>\n</li>\n<li><p><code>&#39;rs+&#39;</code> - Open file for reading and writing, telling the OS to open it\nsynchronously. See notes for <code>&#39;rs&#39;</code> about using this with caution.</p>\n</li>\n<li><p><code>&#39;w&#39;</code> - Open file for writing.\nThe file is created (if it does not exist) or truncated (if it exists).</p>\n</li>\n<li><p><code>&#39;wx&#39;</code> - Like <code>&#39;w&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n<li><p><code>&#39;w+&#39;</code> - Open file for reading and writing.\nThe file is created (if it does not exist) or truncated (if it exists).</p>\n</li>\n<li><p><code>&#39;wx+&#39;</code> - Like <code>&#39;w+&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n<li><p><code>&#39;a&#39;</code> - Open file for appending.\nThe file is created if it does not exist.</p>\n</li>\n<li><p><code>&#39;ax&#39;</code> - Like <code>&#39;a&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n<li><p><code>&#39;a+&#39;</code> - Open file for reading and appending.\nThe file is created if it does not exist.</p>\n</li>\n<li><p><code>&#39;ax+&#39;</code> - Like <code>&#39;a+&#39;</code> but fails if <code>path</code> exists.</p>\n</li>\n</ul>\n<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was\ncreated. It defaults to <code>0666</code>, readable and writable.</p>\n<p>The callback gets two arguments <code>(err, fd)</code>.</p>\n<p>The exclusive flag <code>&#39;x&#39;</code> (<code>O_EXCL</code> flag in open(2)) ensures that <code>path</code> is newly\ncreated. On POSIX systems, <code>path</code> is considered to exist even if it is a symlink\nto a non-existent file. The exclusive flag may or may not work with network file\nsystems.</p>\n<p><code>flags</code> can also be a number as documented by open(2); commonly used constants\nare available from <code>require(&#39;constants&#39;)</code>.  On Windows, flags are translated to\ntheir equivalent ones where applicable, e.g. <code>O_WRONLY</code> to <code>FILE_GENERIC_WRITE</code>,\nor <code>O_EXCL|O_CREAT</code> to <code>CREATE_NEW</code>, as accepted by CreateFileW.</p>\n<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.openSync(path, flags[, mode])",
          "type": "method",
          "name": "openSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous version of [<code>fs.open()</code>][]. Returns an integer representing the file\ndescriptor.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.read(fd, buffer, offset, length, position, callback)",
          "type": "method",
          "name": "read",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Read data from the file specified by <code>fd</code>.</p>\n<p><code>buffer</code> is the buffer that the data will be written to.</p>\n<p><code>offset</code> is the offset in the buffer to start writing at.</p>\n<p><code>length</code> is an integer specifying the number of bytes to read.</p>\n<p><code>position</code> is an integer specifying where to begin reading from in the file.\nIf <code>position</code> is <code>null</code>, data will be read from the current file position.</p>\n<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdir(path, callback)",
          "type": "method",
          "name": "readdir",
          "meta": {
            "added": [
              "v0.1.8"
            ]
          },
          "desc": "<p>Asynchronous readdir(3).  Reads the contents of a directory.\nThe callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of\nthe names of the files in the directory excluding <code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdirSync(path)",
          "type": "method",
          "name": "readdirSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&#39;.&#39;</code> and\n<code>&#39;..&#39;</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readFile(file[, options], callback)",
          "type": "method",
          "name": "readFile",
          "meta": {
            "added": [
              "v0.1.29"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`file` {String} filename ",
                  "name": "file",
                  "type": "String",
                  "desc": "filename"
                },
                {
                  "textRaw": "`options` {Object | String} ",
                  "options": [
                    {
                      "textRaw": "`encoding` {String | Null} default = `null` ",
                      "name": "encoding",
                      "type": "String | Null",
                      "desc": "default = `null`"
                    },
                    {
                      "textRaw": "`flag` {String} default = `'r'` ",
                      "name": "flag",
                      "type": "String",
                      "desc": "default = `'r'`"
                    }
                  ],
                  "name": "options",
                  "type": "Object | String",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Asynchronously reads the entire contents of a file. Example:</p>\n<pre><code class=\"lang-js\">fs.readFile(&#39;/etc/passwd&#39;, (err, data) =&gt; {\n  if (err) throw err;\n  console.log(data);\n});\n</code></pre>\n<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the\ncontents of the file.</p>\n<p>If no encoding is specified, then the raw buffer is returned.</p>\n<p>If <code>options</code> is a string, then it specifies the encoding. Example:</p>\n<pre><code class=\"lang-js\">fs.readFile(&#39;/etc/passwd&#39;, &#39;utf8&#39;, callback);\n</code></pre>\n"
        },
        {
          "textRaw": "fs.readFileSync(file[, options])",
          "type": "method",
          "name": "readFileSync",
          "meta": {
            "added": [
              "v0.1.8"
            ]
          },
          "desc": "<p>Synchronous version of [<code>fs.readFile</code>][]. Returns the contents of the <code>file</code>.</p>\n<p>If the <code>encoding</code> option is specified then this function returns a\nstring. Otherwise it returns a buffer.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlink(path, callback)",
          "type": "method",
          "name": "readlink",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,\nlinkString)</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlinkSync(path)",
          "type": "method",
          "name": "readlinkSync",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Synchronous readlink(2). Returns the symbolic link&#39;s string value.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.realpath(path[, cache], callback)",
          "type": "method",
          "name": "realpath",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Asynchronous realpath(2). The <code>callback</code> gets two arguments <code>(err,\nresolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an\nobject literal of mapped paths that can be used to force a specific path\nresolution or avoid additional <code>fs.stat</code> calls for known real paths.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var cache = {&#39;/etc&#39;:&#39;/private/etc&#39;};\nfs.realpath(&#39;/etc/passwd&#39;, cache, (err, resolvedPath) =&gt; {\n  if (err) throw err;\n  console.log(resolvedPath);\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "cache",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readSync(fd, buffer, offset, length, position)",
          "type": "method",
          "name": "readSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous version of [<code>fs.read()</code>][]. Returns the number of <code>bytesRead</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.realpathSync(path[, cache])",
          "type": "method",
          "name": "realpathSync",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Synchronous realpath(2). Returns the resolved path. <code>cache</code> is an\nobject literal of mapped paths that can be used to force a specific path\nresolution or avoid additional <code>fs.stat</code> calls for known real paths.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "cache",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rename(oldPath, newPath, callback)",
          "type": "method",
          "name": "rename",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Asynchronous rename(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "oldPath"
                },
                {
                  "name": "newPath"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.renameSync(oldPath, newPath)",
          "type": "method",
          "name": "renameSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous rename(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "oldPath"
                },
                {
                  "name": "newPath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdir(path, callback)",
          "type": "method",
          "name": "rmdir",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Asynchronous rmdir(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdirSync(path)",
          "type": "method",
          "name": "rmdirSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous rmdir(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.stat(path, callback)",
          "type": "method",
          "name": "stat",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where\n<code>stats</code> is a [<code>fs.Stats</code>][] object.  See the [<code>fs.Stats</code>][] section for more\ninformation.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.statSync(path)",
          "type": "method",
          "name": "statSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous stat(2). Returns an instance of [<code>fs.Stats</code>][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlink(target, path[, type], callback)",
          "type": "method",
          "name": "symlink",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Asynchronous symlink(2). No arguments other than a possible exception are given\nto the completion callback.\nThe <code>type</code> argument can be set to <code>&#39;dir&#39;</code>, <code>&#39;file&#39;</code>, or <code>&#39;junction&#39;</code> (default\nis <code>&#39;file&#39;</code>) and is only available on Windows (ignored on other platforms).\nNote that Windows junction points require the destination path to be absolute.  When using\n<code>&#39;junction&#39;</code>, the <code>target</code> argument will automatically be normalized to absolute path.</p>\n<p>Here is an example below:</p>\n<pre><code class=\"lang-js\">fs.symlink(&#39;./foo&#39;, &#39;./new-port&#39;);\n</code></pre>\n<p>It creates a symbolic link named &quot;new-port&quot; that points to &quot;foo&quot;.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "target"
                },
                {
                  "name": "path"
                },
                {
                  "name": "type",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlinkSync(target, path[, type])",
          "type": "method",
          "name": "symlinkSync",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Synchronous symlink(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "target"
                },
                {
                  "name": "path"
                },
                {
                  "name": "type",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.truncate(path, len, callback)",
          "type": "method",
          "name": "truncate",
          "meta": {
            "added": [
              "v0.8.6"
            ]
          },
          "desc": "<p>Asynchronous truncate(2). No arguments other than a possible exception are\ngiven to the completion callback. A file descriptor can also be passed as the\nfirst argument. In this case, <code>fs.ftruncate()</code> is called.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "len"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.truncateSync(path, len)",
          "type": "method",
          "name": "truncateSync",
          "meta": {
            "added": [
              "v0.8.6"
            ]
          },
          "desc": "<p>Synchronous truncate(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "len"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlink(path, callback)",
          "type": "method",
          "name": "unlink",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Asynchronous unlink(2). No arguments other than a possible exception are given\nto the completion callback.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlinkSync(path)",
          "type": "method",
          "name": "unlinkSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous unlink(2). Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unwatchFile(filename[, listener])",
          "type": "method",
          "name": "unwatchFile",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Stop watching for changes on <code>filename</code>. If <code>listener</code> is specified, only that\nparticular listener is removed. Otherwise, <em>all</em> listeners are removed and you\nhave effectively stopped watching <code>filename</code>.</p>\n<p>Calling <code>fs.unwatchFile()</code> with a filename that is not being watched is a\nno-op, not an error.</p>\n<p><em>Note: [<code>fs.watch()</code>][] is more efficient than <code>fs.watchFile()</code> and <code>fs.unwatchFile()</code>.\n<code>fs.watch()</code> should be used instead of <code>fs.watchFile()</code> and <code>fs.unwatchFile()</code>\nwhen possible.</em></p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "listener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.utimes(path, atime, mtime, callback)",
          "type": "method",
          "name": "utimes",
          "meta": {
            "added": [
              "v0.4.2"
            ]
          },
          "desc": "<p>Change file timestamps of the file referenced by the supplied path.</p>\n<p>Note: the arguments <code>atime</code> and <code>mtime</code> of the following related functions does\nfollow the below rules:</p>\n<ul>\n<li>If the value is a numberable string like <code>&#39;123456789&#39;</code>, the value would get\nconverted to corresponding number.</li>\n<li>If the value is <code>NaN</code> or <code>Infinity</code>, the value would get converted to\n<code>Date.now()</code>.</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.utimesSync(path, atime, mtime)",
          "type": "method",
          "name": "utimesSync",
          "meta": {
            "added": [
              "v0.4.2"
            ]
          },
          "desc": "<p>Synchronous version of [<code>fs.utimes()</code>][]. Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.watch(filename[, options][, listener])",
          "type": "method",
          "name": "watch",
          "meta": {
            "added": [
              "v0.5.10"
            ]
          },
          "desc": "<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a\ndirectory.  The returned object is a [<code>fs.FSWatcher</code>][].</p>\n<p>The second argument is optional. The <code>options</code> if provided should be an object.\nThe supported boolean members are <code>persistent</code> and <code>recursive</code>. <code>persistent</code>\nindicates whether the process should continue to run as long as files are being\nwatched. <code>recursive</code> indicates whether all subdirectories should be watched, or\nonly the current directory. This applies when a directory is specified, and only\non supported platforms (See [Caveats][]).</p>\n<p>The default is <code>{ persistent: true, recursive: false }</code>.</p>\n<p>The listener callback gets two arguments <code>(event, filename)</code>.  <code>event</code> is either\n<code>&#39;rename&#39;</code> or <code>&#39;change&#39;</code>, and <code>filename</code> is the name of the file which triggered\nthe event.</p>\n",
          "miscs": [
            {
              "textRaw": "Caveats",
              "name": "Caveats",
              "type": "misc",
              "desc": "<p>The <code>fs.watch</code> API is not 100% consistent across platforms, and is\nunavailable in some situations.</p>\n<p>The recursive option is only supported on OS X and Windows.</p>\n",
              "miscs": [
                {
                  "textRaw": "Availability",
                  "name": "Availability",
                  "type": "misc",
                  "desc": "<p>This feature depends on the underlying operating system providing a way\nto be notified of filesystem changes.</p>\n<ul>\n<li>On Linux systems, this uses <code>inotify</code>.</li>\n<li>On BSD systems, this uses <code>kqueue</code>.</li>\n<li>On OS X, this uses <code>kqueue</code> for files and &#39;FSEvents&#39; for directories.</li>\n<li>On SunOS systems (including Solaris and SmartOS), this uses <code>event ports</code>.</li>\n<li>On Windows systems, this feature depends on <code>ReadDirectoryChangesW</code>.</li>\n<li>On Aix systems, this feature depends on <code>AHAFS</code>, which must be enabled.</li>\n</ul>\n<p>If the underlying functionality is not available for some reason, then\n<code>fs.watch</code> will not be able to function. For example, watching files or\ndirectories can be unreliable, and in some cases impossible, on network file\nsystems (NFS, SMB, etc), or host file systems when using virtualization software\nsuch as Vagrant, Docker, etc.</p>\n<p>You can still use <code>fs.watchFile</code>, which uses stat polling, but it is slower and\nless reliable.</p>\n"
                },
                {
                  "textRaw": "Inodes",
                  "name": "Inodes",
                  "type": "misc",
                  "desc": "<p>On Linux and OS X systems, <code>fs.watch()</code> resolves the path to an [inode][] and\nwatches the inode. If the watched path is deleted and recreated, it is assigned\na new inode. The watch will emit an event for the delete but will continue\nwatching the <em>original</em> inode. Events for the new inode will not be emitted.\nThis is expected behavior.</p>\n"
                },
                {
                  "textRaw": "Filename Argument",
                  "name": "Filename Argument",
                  "type": "misc",
                  "desc": "<p>Providing <code>filename</code> argument in the callback is only supported on Linux and\nWindows.  Even on supported platforms, <code>filename</code> is not always guaranteed to\nbe provided. Therefore, don&#39;t assume that <code>filename</code> argument is always\nprovided in the callback, and have some fallback logic if it is null.</p>\n<pre><code class=\"lang-js\">fs.watch(&#39;somedir&#39;, (event, filename) =&gt; {\n  console.log(`event is: ${event}`);\n  if (filename) {\n    console.log(`filename provided: ${filename}`);\n  } else {\n    console.log(&#39;filename not provided&#39;);\n  }\n});\n</code></pre>\n"
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "listener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.watchFile(filename[, options], listener)",
          "type": "method",
          "name": "watchFile",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each\ntime the file is accessed.</p>\n<p>The <code>options</code> argument may be omitted. If provided, it should be an object. The\n<code>options</code> object may contain a boolean named <code>persistent</code> that indicates\nwhether the process should continue to run as long as files are being watched.\nThe <code>options</code> object may specify an <code>interval</code> property indicating how often the\ntarget should be polled in milliseconds. The default is\n<code>{ persistent: true, interval: 5007 }</code>.</p>\n<p>The <code>listener</code> gets two arguments the current stat object and the previous\nstat object:</p>\n<pre><code class=\"lang-js\">fs.watchFile(&#39;message.text&#39;, (curr, prev) =&gt; {\n  console.log(`the current mtime is: ${curr.mtime}`);\n  console.log(`the previous mtime was: ${prev.mtime}`);\n});\n</code></pre>\n<p>These stat objects are instances of <code>fs.Stat</code>.</p>\n<p>If you want to be notified when the file was modified, not just accessed,\nyou need to compare <code>curr.mtime</code> and <code>prev.mtime</code>.</p>\n<p><em>Note: when an <code>fs.watchFile</code> operation results in an <code>ENOENT</code> error, it will\n invoke the listener once, with all the fields zeroed (or, for dates, the Unix\n Epoch). In Windows, <code>blksize</code> and <code>blocks</code> fields will be <code>undefined</code>, instead\n of zero. If the file is created later on, the listener will be called again,\n with the latest stat objects. This is a change in functionality since v0.10.</em></p>\n<p><em>Note: [<code>fs.watch()</code>][] is more efficient than <code>fs.watchFile</code> and <code>fs.unwatchFile</code>.\n<code>fs.watch</code> should be used instead of <code>fs.watchFile</code> and <code>fs.unwatchFile</code>\nwhen possible.</em></p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.write(fd, buffer, offset, length[, position], callback)",
          "type": "method",
          "name": "write",
          "meta": {
            "added": [
              "v0.0.2"
            ]
          },
          "desc": "<p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>\n<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.</p>\n<p><code>position</code> refers to the offset from the beginning of the file where this data\nshould be written. If <code>typeof position !== &#39;number&#39;</code>, the data will be written\nat the current position. See pwrite(2).</p>\n<p>The callback will be given three arguments <code>(err, written, buffer)</code> where\n<code>written</code> specifies how many <em>bytes</em> were written from <code>buffer</code>.</p>\n<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file\nwithout waiting for the callback. For this scenario,\n<code>fs.createWriteStream</code> is strongly recommended.</p>\n<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.write(fd, data[, position[, encoding]], callback)",
          "type": "method",
          "name": "write",
          "meta": {
            "added": [
              "v0.11.5"
            ]
          },
          "desc": "<p>Write <code>data</code> to the file specified by <code>fd</code>.  If <code>data</code> is not a Buffer instance\nthen the value will be coerced to a string.</p>\n<p><code>position</code> refers to the offset from the beginning of the file where this data\nshould be written. If <code>typeof position !== &#39;number&#39;</code> the data will be written at\nthe current position. See pwrite(2).</p>\n<p><code>encoding</code> is the expected string encoding.</p>\n<p>The callback will receive the arguments <code>(err, written, string)</code> where <code>written</code>\nspecifies how many <em>bytes</em> the passed string required to be written. Note that\nbytes written is not the same as string characters. See [<code>Buffer.byteLength</code>][].</p>\n<p>Unlike when writing <code>buffer</code>, the entire string must be written. No substring\nmay be specified. This is because the byte offset of the resulting data may not\nbe the same as the string offset.</p>\n<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file\nwithout waiting for the callback. For this scenario,\n<code>fs.createWriteStream</code> is strongly recommended.</p>\n<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "data"
                },
                {
                  "name": "position",
                  "optional": true
                },
                {
                  "name": "encoding",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeFile(file, data[, options], callback)",
          "type": "method",
          "name": "writeFile",
          "meta": {
            "added": [
              "v0.1.29"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`file` {String} filename ",
                  "name": "file",
                  "type": "String",
                  "desc": "filename"
                },
                {
                  "textRaw": "`data` {String | Buffer} ",
                  "name": "data",
                  "type": "String | Buffer"
                },
                {
                  "textRaw": "`options` {Object | String} ",
                  "options": [
                    {
                      "textRaw": "`encoding` {String | Null} default = `'utf8'` ",
                      "name": "encoding",
                      "type": "String | Null",
                      "desc": "default = `'utf8'`"
                    },
                    {
                      "textRaw": "`mode` {Number} default = `0o666` ",
                      "name": "mode",
                      "type": "Number",
                      "desc": "default = `0o666`"
                    },
                    {
                      "textRaw": "`flag` {String} default = `'w'` ",
                      "name": "flag",
                      "type": "String",
                      "desc": "default = `'w'`"
                    }
                  ],
                  "name": "options",
                  "type": "Object | String",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Asynchronously writes data to a file, replacing the file if it already exists.\n<code>data</code> can be a string or a buffer.</p>\n<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer. It defaults\nto <code>&#39;utf8&#39;</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node.js&#39;, (err) =&gt; {\n  if (err) throw err;\n  console.log(&#39;It\\&#39;s saved!&#39;);\n});\n</code></pre>\n<p>If <code>options</code> is a string, then it specifies the encoding. Example:</p>\n<pre><code class=\"lang-js\">fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node.js&#39;, &#39;utf8&#39;, callback);\n</code></pre>\n<p>Note that it is unsafe to use <code>fs.writeFile</code> multiple times on the same file\nwithout waiting for the callback. For this scenario,\n<code>fs.createWriteStream</code> is strongly recommended.</p>\n"
        },
        {
          "textRaw": "fs.writeFileSync(file, data[, options])",
          "type": "method",
          "name": "writeFileSync",
          "meta": {
            "added": [
              "v0.1.29"
            ]
          },
          "desc": "<p>The synchronous version of [<code>fs.writeFile()</code>][]. Returns <code>undefined</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeSync(fd, buffer, offset, length[, position])",
          "type": "method",
          "name": "writeSync",
          "meta": {
            "added": [
              "v0.1.21"
            ]
          },
          "desc": "<p>Synchronous versions of [<code>fs.write()</code>][]. Returns the number of bytes written.</p>\n<!-- [end-include:fs.md] -->\n<!-- [start-include:globals.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "data"
                },
                {
                  "name": "position",
                  "optional": true
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeSync(fd, data[, position[, encoding]])",
          "type": "method",
          "name": "writeSync",
          "meta": {
            "added": [
              "v0.11.5"
            ]
          },
          "desc": "<p>Synchronous versions of [<code>fs.write()</code>][]. Returns the number of bytes written.</p>\n<!-- [end-include:fs.md] -->\n<!-- [start-include:globals.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "data"
                },
                {
                  "name": "position",
                  "optional": true
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "fs"
    },
    {
      "textRaw": "HTTP",
      "name": "http",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>To use the HTTP server and client one must <code>require(&#39;http&#39;)</code>.</p>\n<p>The HTTP interfaces in Node.js are designed to support many features\nof the protocol which have been traditionally difficult to use.\nIn particular, large, possibly chunk-encoded, messages. The interface is\ncareful to never buffer entire requests or responses--the\nuser is able to stream data.</p>\n<p>HTTP message headers are represented by an object like this:</p>\n<pre><code>{ &#39;content-length&#39;: &#39;123&#39;,\n  &#39;content-type&#39;: &#39;text/plain&#39;,\n  &#39;connection&#39;: &#39;keep-alive&#39;,\n  &#39;host&#39;: &#39;mysite.com&#39;,\n  &#39;accept&#39;: &#39;*/*&#39; }\n</code></pre><p>Keys are lowercased. Values are not modified.</p>\n<p>In order to support the full spectrum of possible HTTP applications, Node.js&#39;s\nHTTP API is very low-level. It deals with stream handling and message\nparsing only. It parses a message into headers and body but it does not\nparse the actual headers or the body.</p>\n<p>See [<code>message.headers</code>][] for details on how duplicate headers are handled.</p>\n<p>The raw headers as they were received are retained in the <code>rawHeaders</code>\nproperty, which is an array of <code>[key, value, key2, value2, ...]</code>.  For\nexample, the previous message header object might have a <code>rawHeaders</code>\nlist like the following:</p>\n<pre><code>[ &#39;ConTent-Length&#39;, &#39;123456&#39;,\n  &#39;content-LENGTH&#39;, &#39;123&#39;,\n  &#39;content-type&#39;, &#39;text/plain&#39;,\n  &#39;CONNECTION&#39;, &#39;keep-alive&#39;,\n  &#39;Host&#39;, &#39;mysite.com&#39;,\n  &#39;accepT&#39;, &#39;*/*&#39; ]\n</code></pre>",
      "classes": [
        {
          "textRaw": "Class: http.Agent",
          "type": "class",
          "name": "http.Agent",
          "meta": {
            "added": [
              "v0.3.4"
            ]
          },
          "desc": "<p>The HTTP Agent is used for pooling sockets used in HTTP client\nrequests.</p>\n<p>The HTTP Agent also defaults client requests to using\nConnection:keep-alive. If no pending HTTP requests are waiting on a\nsocket to become free the socket is closed. This means that Node.js&#39;s\npool has the benefit of keep-alive when under load but still does not\nrequire developers to manually close the HTTP clients using\nKeepAlive.</p>\n<p>If you opt into using HTTP KeepAlive, you can create an Agent object\nwith that flag set to <code>true</code>.  (See the [constructor options][].)\nThen, the Agent will keep unused sockets in a pool for later use.  They\nwill be explicitly marked so as to not keep the Node.js process running.\nHowever, it is still a good idea to explicitly [<code>destroy()</code>][] KeepAlive\nagents when they are no longer in use, so that the Sockets will be shut\ndown.</p>\n<p>Sockets are removed from the agent&#39;s pool when the socket emits either\na <code>&#39;close&#39;</code> event or a special <code>&#39;agentRemove&#39;</code> event. This means that if\nyou intend to keep one HTTP request open for a long time and don&#39;t\nwant it to stay in the pool you can do something along the lines of:</p>\n<pre><code class=\"lang-js\">http.get(options, (res) =&gt; {\n  // Do stuff\n}).on(&#39;socket&#39;, (socket) =&gt; {\n  socket.emit(&#39;agentRemove&#39;);\n});\n</code></pre>\n<p>Alternatively, you could just opt out of pooling entirely using\n<code>agent:false</code>:</p>\n<pre><code class=\"lang-js\">http.get({\n  hostname: &#39;localhost&#39;,\n  port: 80,\n  path: &#39;/&#39;,\n  agent: false  // create a new agent just for this one request\n}, (res) =&gt; {\n  // Do stuff with response\n})\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "agent.destroy()",
              "type": "method",
              "name": "destroy",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Destroy any sockets that are currently in use by the agent.</p>\n<p>It is usually not necessary to do this.  However, if you are using an\nagent with KeepAlive enabled, then it is best to explicitly shut down\nthe agent when you know that it will no longer be used.  Otherwise,\nsockets may hang open for quite a long time before the server\nterminates them.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "agent.getName(options)",
              "type": "method",
              "name": "getName",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Get a unique name for a set of request options, to determine whether a\nconnection can be reused.  In the http agent, this returns\n<code>host:port:localAddress</code>.  In the https agent, the name includes the\nCA, cert, ciphers, and other HTTPS/TLS-specific options that determine\nsocket reusability.</p>\n<p>Options:</p>\n<ul>\n<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>\n<li><code>port</code>: Port of remote server.</li>\n<li><code>localAddress</code>: Local interface to bind for network connections when issuing\nthe request.</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "agent.freeSockets",
              "name": "freeSockets",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>An object which contains arrays of sockets currently awaiting use by\nthe Agent when HTTP KeepAlive is used.  Do not modify.</p>\n"
            },
            {
              "textRaw": "agent.maxFreeSockets",
              "name": "maxFreeSockets",
              "meta": {
                "added": [
                  "v0.11.7"
                ]
              },
              "desc": "<p>By default set to 256.  For Agents supporting HTTP KeepAlive, this\nsets the maximum number of sockets that will be left open in the free\nstate.</p>\n"
            },
            {
              "textRaw": "agent.maxSockets",
              "name": "maxSockets",
              "meta": {
                "added": [
                  "v0.3.6"
                ]
              },
              "desc": "<p>By default set to Infinity. Determines how many concurrent sockets the agent\ncan have open per origin. Origin is either a &#39;host:port&#39; or\n&#39;host:port:localAddress&#39; combination.</p>\n"
            },
            {
              "textRaw": "agent.requests",
              "name": "requests",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "desc": "<p>An object which contains queues of requests that have not yet been assigned to\nsockets. Do not modify.</p>\n"
            },
            {
              "textRaw": "agent.sockets",
              "name": "sockets",
              "meta": {
                "added": [
                  "v0.3.6"
                ]
              },
              "desc": "<p>An object which contains arrays of sockets currently in use by the\nAgent.  Do not modify.</p>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} Set of configurable options to set on the agent. Can have the following fields: ",
                  "options": [
                    {
                      "textRaw": "`keepAlive` {Boolean} Keep sockets around in a pool to be used by other requests in the future. Default = `false` ",
                      "name": "keepAlive",
                      "type": "Boolean",
                      "desc": "Keep sockets around in a pool to be used by other requests in the future. Default = `false`"
                    },
                    {
                      "textRaw": "`keepAliveMsecs` {Integer} When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = `1000`.  Only relevant if `keepAlive` is set to `true`. ",
                      "name": "keepAliveMsecs",
                      "type": "Integer",
                      "desc": "When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = `1000`.  Only relevant if `keepAlive` is set to `true`."
                    },
                    {
                      "textRaw": "`maxSockets` {Number} Maximum number of sockets to allow per host.  Default = `Infinity`. ",
                      "name": "maxSockets",
                      "type": "Number",
                      "desc": "Maximum number of sockets to allow per host.  Default = `Infinity`."
                    },
                    {
                      "textRaw": "`maxFreeSockets` {Number} Maximum number of sockets to leave open in a free state.  Only relevant if `keepAlive` is set to `true`. Default = `256`. ",
                      "name": "maxFreeSockets",
                      "type": "Number",
                      "desc": "Maximum number of sockets to leave open in a free state.  Only relevant if `keepAlive` is set to `true`. Default = `256`."
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "desc": "Set of configurable options to set on the agent. Can have the following fields:",
                  "optional": true
                }
              ],
              "desc": "<p>The default [<code>http.globalAgent</code>][] that is used by [<code>http.request()</code>][] has all\nof these values set to their respective defaults.</p>\n<p>To configure any of them, you must create your own [<code>http.Agent</code>][] object.</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\nvar keepAliveAgent = new http.Agent({ keepAlive: true });\noptions.agent = keepAliveAgent;\nhttp.request(options, onResponseCallback);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ],
              "desc": "<p>The default [<code>http.globalAgent</code>][] that is used by [<code>http.request()</code>][] has all\nof these values set to their respective defaults.</p>\n<p>To configure any of them, you must create your own [<code>http.Agent</code>][] object.</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\nvar keepAliveAgent = new http.Agent({ keepAlive: true });\noptions.agent = keepAliveAgent;\nhttp.request(options, onResponseCallback);\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.ClientRequest",
          "type": "class",
          "name": "http.ClientRequest",
          "meta": {
            "added": [
              "v0.1.17"
            ]
          },
          "desc": "<p>This object is created internally and returned from [<code>http.request()</code>][].  It\nrepresents an <em>in-progress</em> request whose header has already been queued.  The\nheader is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,\n<code>removeHeader(name)</code> API.  The actual header will be sent along with the first\ndata chunk or when closing the connection.</p>\n<p>To get the response, add a listener for <code>&#39;response&#39;</code> to the request object.\n<code>&#39;response&#39;</code> will be emitted from the request object when the response\nheaders have been received.  The <code>&#39;response&#39;</code> event is executed with one\nargument which is an instance of [<code>http.IncomingMessage</code>][].</p>\n<p>During the <code>&#39;response&#39;</code> event, one can add listeners to the\nresponse object; particularly to listen for the <code>&#39;data&#39;</code> event.</p>\n<p>If no <code>&#39;response&#39;</code> handler is added, then the response will be\nentirely discarded.  However, if you add a <code>&#39;response&#39;</code> event handler,\nthen you <strong>must</strong> consume the data from the response object, either by\ncalling <code>response.read()</code> whenever there is a <code>&#39;readable&#39;</code> event, or\nby adding a <code>&#39;data&#39;</code> handler, or by calling the <code>.resume()</code> method.\nUntil the data is consumed, the <code>&#39;end&#39;</code> event will not fire.  Also, until\nthe data is read it will consume memory that can eventually lead to a\n&#39;process out of memory&#39; error.</p>\n<p>Note: Node.js does not check whether Content-Length and the length of the body\nwhich has been transmitted are equal or not.</p>\n<p>The request implements the [Writable Stream][] interface. This is an\n[<code>EventEmitter</code>][] with the following events:</p>\n",
          "events": [
            {
              "textRaw": "Event: 'abort'",
              "type": "event",
              "name": "abort",
              "meta": {
                "added": [
                  "v1.4.1"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Emitted when the request has been aborted by the client. This event is only\nemitted on the first call to <code>abort()</code>.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'aborted'",
              "type": "event",
              "name": "aborted",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Emitted when the request has been aborted by the server and the network\nsocket has closed.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p><code>function (response, socket, head) { }</code></p>\n<p>Emitted each time a server responds to a request with a <code>CONNECT</code> method. If this\nevent isn&#39;t being listened for, clients receiving a <code>CONNECT</code> method will have\ntheir connections closed.</p>\n<p>A client server pair that show you how to listen for the <code>&#39;connect&#39;</code> event.</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\nconst net = require(&#39;net&#39;);\nconst url = require(&#39;url&#39;);\n\n// Create an HTTP tunneling proxy\nvar proxy = http.createServer( (req, res) =&gt; {\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;okay&#39;);\n});\nproxy.on(&#39;connect&#39;, (req, cltSocket, head) =&gt; {\n  // connect to an origin server\n  var srvUrl = url.parse(`http://${req.url}`);\n  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; {\n    cltSocket.write(&#39;HTTP/1.1 200 Connection Established\\r\\n&#39; +\n                    &#39;Proxy-agent: Node.js-Proxy\\r\\n&#39; +\n                    &#39;\\r\\n&#39;);\n    srvSocket.write(head);\n    srvSocket.pipe(cltSocket);\n    cltSocket.pipe(srvSocket);\n  });\n});\n\n// now that proxy is running\nproxy.listen(1337, &#39;127.0.0.1&#39;, () =&gt; {\n\n  // make a request to a tunneling proxy\n  var options = {\n    port: 1337,\n    hostname: &#39;127.0.0.1&#39;,\n    method: &#39;CONNECT&#39;,\n    path: &#39;www.google.com:80&#39;\n  };\n\n  var req = http.request(options);\n  req.end();\n\n  req.on(&#39;connect&#39;, (res, socket, head) =&gt; {\n    console.log(&#39;got connected!&#39;);\n\n    // make a request over an HTTP tunnel\n    socket.write(&#39;GET / HTTP/1.1\\r\\n&#39; +\n                 &#39;Host: www.google.com:80\\r\\n&#39; +\n                 &#39;Connection: close\\r\\n&#39; +\n                 &#39;\\r\\n&#39;);\n    socket.on(&#39;data&#39;, (chunk) =&gt; {\n      console.log(chunk.toString());\n    });\n    socket.on(&#39;end&#39;, () =&gt; {\n      proxy.close();\n    });\n  });\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'continue'",
              "type": "event",
              "name": "continue",
              "meta": {
                "added": [
                  "v0.3.2"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Emitted when the server sends a &#39;100 Continue&#39; HTTP response, usually because\nthe request contained &#39;Expect: 100-continue&#39;. This is an instruction that\nthe client should send the request body.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'response'",
              "type": "event",
              "name": "response",
              "meta": {
                "added": [
                  "v0.1.0"
                ]
              },
              "desc": "<p><code>function (response) { }</code></p>\n<p>Emitted when a response is received to this request. This event is emitted only\nonce. The <code>response</code> argument will be an instance of [<code>http.IncomingMessage</code>][].</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'socket'",
              "type": "event",
              "name": "socket",
              "meta": {
                "added": [
                  "v0.5.3"
                ]
              },
              "desc": "<p><code>function (socket) { }</code></p>\n<p>Emitted after a socket is assigned to this request.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p><code>function (response, socket, head) { }</code></p>\n<p>Emitted each time a server responds to a request with an upgrade. If this\nevent isn&#39;t being listened for, clients receiving an upgrade header will have\ntheir connections closed.</p>\n<p>A client server pair that show you how to listen for the <code>&#39;upgrade&#39;</code> event.</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\n\n// Create an HTTP server\nvar srv = http.createServer( (req, res) =&gt; {\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;okay&#39;);\n});\nsrv.on(&#39;upgrade&#39;, (req, socket, head) =&gt; {\n  socket.write(&#39;HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n&#39; +\n               &#39;Upgrade: WebSocket\\r\\n&#39; +\n               &#39;Connection: Upgrade\\r\\n&#39; +\n               &#39;\\r\\n&#39;);\n\n  socket.pipe(socket); // echo back\n});\n\n// now that server is running\nsrv.listen(1337, &#39;127.0.0.1&#39;, () =&gt; {\n\n  // make a request\n  var options = {\n    port: 1337,\n    hostname: &#39;127.0.0.1&#39;,\n    headers: {\n      &#39;Connection&#39;: &#39;Upgrade&#39;,\n      &#39;Upgrade&#39;: &#39;websocket&#39;\n    }\n  };\n\n  var req = http.request(options);\n  req.end();\n\n  req.on(&#39;upgrade&#39;, (res, socket, upgradeHead) =&gt; {\n    console.log(&#39;got upgraded!&#39;);\n    socket.end();\n    process.exit(0);\n  });\n});\n</code></pre>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "request.abort()",
              "type": "method",
              "name": "abort",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p>Marks the request as aborting. Calling this will cause remaining data\nin the response to be dropped and the socket to be destroyed.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "request.end([data][, encoding][, callback])",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Finishes sending the request. If any parts of the body are\nunsent, it will flush them to the stream. If the request is\nchunked, this will send the terminating <code>&#39;0\\r\\n\\r\\n&#39;</code>.</p>\n<p>If <code>data</code> is specified, it is equivalent to calling\n[<code>response.write(data, encoding)</code>][] followed by <code>request.end(callback)</code>.</p>\n<p>If <code>callback</code> is specified, it will be called when the request stream\nis finished.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.flushHeaders()",
              "type": "method",
              "name": "flushHeaders",
              "meta": {
                "added": [
                  "v1.6.0"
                ]
              },
              "desc": "<p>Flush the request headers.</p>\n<p>For efficiency reasons, Node.js normally buffers the request headers until you\ncall <code>request.end()</code> or write the first chunk of request data.  It then tries\nhard to pack the request headers and data into a single TCP packet.</p>\n<p>That&#39;s usually what you want (it saves a TCP round-trip) but not when the first\ndata isn&#39;t sent until possibly much later.  <code>request.flushHeaders()</code> lets you bypass\nthe optimization and kickstart the request.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "request.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "desc": "<p>Once a socket is assigned to this request and is connected\n[<code>socket.setNoDelay()</code>][] will be called.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.setSocketKeepAlive([enable][, initialDelay])",
              "type": "method",
              "name": "setSocketKeepAlive",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "desc": "<p>Once a socket is assigned to this request and is connected\n[<code>socket.setKeepAlive()</code>][] will be called.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.setTimeout(timeout[, callback])",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "desc": "<p>Once a socket is assigned to this request and is connected\n[<code>socket.setTimeout()</code>][] will be called.</p>\n<ul>\n<li><code>timeout</code> {Number} Milliseconds before a request is considered to be timed out.</li>\n<li><code>callback</code> {Function} Optional function to be called when a timeout occurs. Same as binding to the <code>timeout</code> event.</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.write(chunk[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.29"
                ]
              },
              "desc": "<p>Sends a chunk of the body.  By calling this method\nmany times, the user can stream a request body to a\nserver--in that case it is suggested to use the\n<code>[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code> header line when\ncreating the request.</p>\n<p>The <code>chunk</code> argument should be a [<code>Buffer</code>][] or a string.</p>\n<p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string.\nDefaults to <code>&#39;utf8&#39;</code>.</p>\n<p>The <code>callback</code> argument is optional and will be called when this chunk of data\nis flushed.</p>\n<p>Returns <code>request</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: http.Server",
          "type": "class",
          "name": "http.Server",
          "meta": {
            "added": [
              "v0.1.17"
            ]
          },
          "desc": "<p>This class inherits from [<code>net.Server</code>][] and has the following additional events:</p>\n",
          "events": [
            {
              "textRaw": "Event: 'checkContinue'",
              "type": "event",
              "name": "checkContinue",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p><code>function (request, response) { }</code></p>\n<p>Emitted each time a request with an http Expect: 100-continue is received.\nIf this event isn&#39;t listened for, the server will automatically respond\nwith a 100 Continue as appropriate.</p>\n<p>Handling this event involves calling [<code>response.writeContinue()</code>][] if the client\nshould continue to send the request body, or generating an appropriate HTTP\nresponse (e.g., 400 Bad Request) if the client should not continue to send the\nrequest body.</p>\n<p>Note that when this event is emitted and handled, the <code>&#39;request&#39;</code> event will\nnot be emitted.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'clientError'",
              "type": "event",
              "name": "clientError",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p><code>function (exception, socket) { }</code></p>\n<p>If a client connection emits an <code>&#39;error&#39;</code> event, it will be forwarded here.</p>\n<p><code>socket</code> is the [<code>net.Socket</code>][] object that the error originated from.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.4"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Emitted when the server closes.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p><code>function (request, socket, head) { }</code></p>\n<p>Emitted each time a client requests a http <code>CONNECT</code> method. If this event isn&#39;t\nlistened for, then clients requesting a <code>CONNECT</code> method will have their\nconnections closed.</p>\n<ul>\n<li><code>request</code> is the arguments for the http request, as it is in the request\nevent.</li>\n<li><code>socket</code> is the network socket between the server and client.</li>\n<li><code>head</code> is an instance of Buffer, the first packet of the tunneling stream,\nthis may be empty.</li>\n</ul>\n<p>After this event is emitted, the request&#39;s socket will not have a <code>&#39;data&#39;</code>\nevent listener, meaning you will need to bind to it in order to handle data\nsent to the server on that socket.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "meta": {
                "added": [
                  "v0.1.0"
                ]
              },
              "desc": "<p><code>function (socket) { }</code></p>\n<p>When a new TCP stream is established. <code>socket</code> is an object of type\n[<code>net.Socket</code>][]. Usually users will not want to access this event. In\nparticular, the socket will not emit <code>&#39;readable&#39;</code> events because of how\nthe protocol parser attaches to the socket. The <code>socket</code> can also be\naccessed at <code>request.connection</code>.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'request'",
              "type": "event",
              "name": "request",
              "meta": {
                "added": [
                  "v0.1.0"
                ]
              },
              "desc": "<p><code>function (request, response) { }</code></p>\n<p>Emitted each time there is a request. Note that there may be multiple requests\nper connection (in the case of keep-alive connections).\n <code>request</code> is an instance of [<code>http.IncomingMessage</code>][] and <code>response</code> is\nan instance of [<code>http.ServerResponse</code>][].</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p><code>function (request, socket, head) { }</code></p>\n<p>Emitted each time a client requests a http upgrade. If this event isn&#39;t\nlistened for, then clients requesting an upgrade will have their connections\nclosed.</p>\n<ul>\n<li><code>request</code> is the arguments for the http request, as it is in the request\nevent.</li>\n<li><code>socket</code> is the network socket between the server and client.</li>\n<li><code>head</code> is an instance of Buffer, the first packet of the upgraded stream,\nthis may be empty.</li>\n</ul>\n<p>After this event is emitted, the request&#39;s socket will not have a <code>&#39;data&#39;</code>\nevent listener, meaning you will need to bind to it in order to handle data\nsent to the server on that socket.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Stops the server from accepting new connections.  See [<code>net.Server.close()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(handle[, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.5.10"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`handle` {Object} ",
                      "name": "handle",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>handle</code> object can be set to either a server or socket (anything\nwith an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.</p>\n<p>This will cause the server to accept connections on the specified\nhandle, but it is presumed that the file descriptor or handle has\nalready been bound to a port or domain socket.</p>\n<p>Listening on a file descriptor is not supported on Windows.</p>\n<p>This function is asynchronous. <code>callback</code> will be added as a listener for the\n<code>&#39;listening&#39;</code> event. See also [<code>net.Server.listen()</code>][].</p>\n<p>Returns <code>server</code>.</p>\n"
            },
            {
              "textRaw": "server.listen(path[, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>\n<p>This function is asynchronous. <code>callback</code> will be added as a listener for the\n<code>&#39;listening&#39;</code> event.  See also [<code>net.Server.listen(path)</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(port[, hostname][, backlog][, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Begin accepting connections on the specified <code>port</code> and <code>hostname</code>. If the\n<code>hostname</code> is omitted, the server will accept connections on any IPv6 address\n(<code>::</code>) when IPv6 is available, or any IPv4 address (<code>0.0.0.0</code>) otherwise. Use a\nport value of <code>0</code> to have the operating system assign an available port.</p>\n<p>To listen to a unix socket, supply a filename instead of port and hostname.</p>\n<p>Backlog is the maximum length of the queue of pending connections.\nThe actual length will be determined by your OS through sysctl settings such as\n<code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on linux. The default value of this\nparameter is 511 (not 512).</p>\n<p>This function is asynchronous. <code>callback</code> will be added as a listener for the\n<code>&#39;listening&#39;</code> event.  See also [<code>net.Server.listen(port)</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "hostname",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.9.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the timeout value for sockets, and emits a <code>&#39;timeout&#39;</code> event on\nthe Server object, passing the socket as an argument, if a timeout\noccurs.</p>\n<p>If there is a <code>&#39;timeout&#39;</code> event listener on the Server object, then it\nwill be called with the timed-out socket as an argument.</p>\n<p>By default, the Server&#39;s timeout value is 2 minutes, and sockets are\ndestroyed automatically if they time out.  However, if you assign a\ncallback to the Server&#39;s <code>&#39;timeout&#39;</code> event, then you are responsible\nfor handling socket timeouts.</p>\n<p>Returns <code>server</code>.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "server.maxHeadersCount",
              "name": "maxHeadersCount",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p>Limits maximum incoming headers count, equal to 1000 by default. If set to 0 -\nno limit will be applied.</p>\n"
            },
            {
              "textRaw": "`timeout` {Number} Default = 120000 (2 minutes) ",
              "type": "Number",
              "name": "timeout",
              "meta": {
                "added": [
                  "v0.9.12"
                ]
              },
              "desc": "<p>The number of milliseconds of inactivity before a socket is presumed\nto have timed out.</p>\n<p>Note that the socket timeout logic is set up on connection, so\nchanging this value only affects <em>new</em> connections to the server, not\nany existing connections.</p>\n<p>Set to 0 to disable any kind of automatic timeout behavior on incoming\nconnections.</p>\n",
              "shortDesc": "Default = 120000 (2 minutes)"
            }
          ]
        },
        {
          "textRaw": "Class: http.ServerResponse",
          "type": "class",
          "name": "http.ServerResponse",
          "meta": {
            "added": [
              "v0.1.17"
            ]
          },
          "desc": "<p>This object is created internally by a HTTP server--not by the user. It is\npassed as the second parameter to the <code>&#39;request&#39;</code> event.</p>\n<p>The response implements, but does not inherit from, the [Writable Stream][]\ninterface. This is an [<code>EventEmitter</code>][] with the following events:</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.6.7"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Indicates that the underlying connection was terminated before\n[<code>response.end()</code>][] was called or able to flush.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'finish'",
              "type": "event",
              "name": "finish",
              "meta": {
                "added": [
                  "v0.3.6"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Emitted when the response has been sent. More specifically, this event is\nemitted when the last segment of the response headers and body have been\nhanded off to the operating system for transmission over the network. It\ndoes not imply that the client has received anything yet.</p>\n<p>After this event, no more events will be emitted on the response object.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "response.addTrailers(headers)",
              "type": "method",
              "name": "addTrailers",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>This method adds HTTP trailing headers (a header but at the end of the\nmessage) to the response.</p>\n<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the\nresponse; if it is not (e.g., if the request was HTTP/1.0), they will\nbe silently discarded.</p>\n<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to\nemit trailers, with a list of the header fields in its value. E.g.,</p>\n<pre><code class=\"lang-js\">response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39;,\n                          &#39;Trailer&#39;: &#39;Content-MD5&#39; });\nresponse.write(fileData);\nresponse.addTrailers({&#39;Content-MD5&#39;: &#39;7895bf4b8828b55ceaf47747b4bca667&#39;});\nresponse.end();\n</code></pre>\n<p>Attempting to set a header field name or value that contains invalid characters\nwill result in a [<code>TypeError</code>][] being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "headers"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.end([data][, encoding][, callback])",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>This method signals to the server that all of the response headers and body\nhave been sent; that server should consider this message complete.\nThe method, <code>response.end()</code>, MUST be called on each response.</p>\n<p>If <code>data</code> is specified, it is equivalent to calling\n[<code>response.write(data, encoding)</code>][] followed by <code>response.end(callback)</code>.</p>\n<p>If <code>callback</code> is specified, it will be called when the response stream\nis finished.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.getHeader(name)",
              "type": "method",
              "name": "getHeader",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "desc": "<p>Reads out a header that&#39;s already been queued but not sent to the client.  Note\nthat the name is case insensitive.  This can only be called before headers get\nimplicitly flushed.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var contentType = response.getHeader(&#39;content-type&#39;);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.removeHeader(name)",
              "type": "method",
              "name": "removeHeader",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "desc": "<p>Removes a header that&#39;s queued for implicit sending.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">response.removeHeader(&#39;Content-Encoding&#39;);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.setHeader(name, value)",
              "type": "method",
              "name": "setHeader",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "desc": "<p>Sets a single header value for implicit headers.  If this header already exists\nin the to-be-sent headers, its value will be replaced.  Use an array of strings\nhere if you need to send multiple headers with the same name.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">response.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n</code></pre>\n<p>or</p>\n<pre><code class=\"lang-js\">response.setHeader(&#39;Set-Cookie&#39;, [&#39;type=ninja&#39;, &#39;language=javascript&#39;]);\n</code></pre>\n<p>Attempting to set a header field name or value that contains invalid characters\nwill result in a [<code>TypeError</code>][] being thrown.</p>\n<p>When headers have been set with [<code>response.setHeader()</code>][], they will be merged with\nany headers passed to [<code>response.writeHead()</code>][], with the headers passed to\n[<code>response.writeHead()</code>][] given precedence.</p>\n<pre><code class=\"lang-js\">// returns content-type = text/plain\nconst server = http.createServer((req,res) =&gt; {\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n  res.setHeader(&#39;X-Foo&#39;, &#39;bar&#39;);\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;ok&#39;);\n});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "value"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.9.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the Socket&#39;s timeout value to <code>msecs</code>.  If a callback is\nprovided, then it is added as a listener on the <code>&#39;timeout&#39;</code> event on\nthe response object.</p>\n<p>If no <code>&#39;timeout&#39;</code> listener is added to the request, the response, or\nthe server, then sockets are destroyed when they time out.  If you\nassign a handler on the request, the response, or the server&#39;s\n<code>&#39;timeout&#39;</code> events, then it is your responsibility to handle timed out\nsockets.</p>\n<p>Returns <code>response</code>.</p>\n"
            },
            {
              "textRaw": "response.write(chunk[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.29"
                ]
              },
              "desc": "<p>If this method is called and [<code>response.writeHead()</code>][] has not been called,\nit will switch to implicit header mode and flush the implicit headers.</p>\n<p>This sends a chunk of the response body. This method may\nbe called multiple times to provide successive parts of the body.</p>\n<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,\nthe second parameter specifies how to encode it into a byte stream.\nBy default the <code>encoding</code> is <code>&#39;utf8&#39;</code>. <code>callback</code> will be called when this chunk\nof data is flushed.</p>\n<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with\nhigher-level multi-part body encodings that may be used.</p>\n<p>The first time [<code>response.write()</code>][] is called, it will send the buffered\nheader information and the first body to the client. The second time\n[<code>response.write()</code>][] is called, Node.js assumes you&#39;re going to be streaming\ndata, and sends that separately. That is, the response is buffered up to the\nfirst chunk of body.</p>\n<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel\nbuffer. Returns <code>false</code> if all or part of the data was queued in user memory.\n<code>&#39;drain&#39;</code> will be emitted when the buffer is free again.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.writeContinue()",
              "type": "method",
              "name": "writeContinue",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the [<code>&#39;checkContinue&#39;</code>][] event on <code>Server</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "response.writeHead(statusCode[, statusMessage][, headers])",
              "type": "method",
              "name": "writeHead",
              "meta": {
                "added": [
                  "v0.1.30"
                ]
              },
              "desc": "<p>Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.\nOptionally one can give a human-readable <code>statusMessage</code> as the second\nargument.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var body = &#39;hello world&#39;;\nresponse.writeHead(200, {\n  &#39;Content-Length&#39;: Buffer.byteLength(body),\n  &#39;Content-Type&#39;: &#39;text/plain&#39; });\n</code></pre>\n<p>This method must only be called once on a message and it must\nbe called before [<code>response.end()</code>][] is called.</p>\n<p>If you call [<code>response.write()</code>][] or [<code>response.end()</code>][] before calling this,\nthe implicit/mutable headers will be calculated and call this function for you.</p>\n<p>When headers have been set with [<code>response.setHeader()</code>][], they will be merged with\nany headers passed to [<code>response.writeHead()</code>][], with the headers passed to\n[<code>response.writeHead()</code>][] given precedence.</p>\n<pre><code class=\"lang-js\">// returns content-type = text/plain\nconst server = http.createServer((req,res) =&gt; {\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n  res.setHeader(&#39;X-Foo&#39;, &#39;bar&#39;);\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;ok&#39;);\n});\n</code></pre>\n<p>Note that Content-Length is given in bytes not characters. The above example\nworks because the string <code>&#39;hello world&#39;</code> contains only single byte characters.\nIf the body contains higher coded characters then <code>Buffer.byteLength()</code>\nshould be used to determine the number of bytes in a given encoding.\nAnd Node.js does not check whether Content-Length and the length of the body\nwhich has been transmitted are equal or not.</p>\n<p>Attempting to set a header field name or value that contains invalid characters\nwill result in a [<code>TypeError</code>][] being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "statusCode"
                    },
                    {
                      "name": "statusMessage",
                      "optional": true
                    },
                    {
                      "name": "headers",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "response.finished",
              "name": "finished",
              "meta": {
                "added": [
                  "v0.0.2"
                ]
              },
              "desc": "<p>Boolean value that indicates whether the response has completed. Starts\nas <code>false</code>. After [<code>response.end()</code>][] executes, the value will be <code>true</code>.</p>\n"
            },
            {
              "textRaw": "response.headersSent",
              "name": "headersSent",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>Boolean (read-only). True if headers were sent, false otherwise.</p>\n"
            },
            {
              "textRaw": "response.sendDate",
              "name": "sendDate",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p>When true, the Date header will be automatically generated and sent in\nthe response if it is not already present in the headers. Defaults to true.</p>\n<p>This should only be disabled for testing; HTTP requires the Date header\nin responses.</p>\n"
            },
            {
              "textRaw": "response.statusCode",
              "name": "statusCode",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "desc": "<p>When using implicit headers (not calling [<code>response.writeHead()</code>][] explicitly),\nthis property controls the status code that will be sent to the client when\nthe headers get flushed.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">response.statusCode = 404;\n</code></pre>\n<p>After response header was sent to the client, this property indicates the\nstatus code which was sent out.</p>\n"
            },
            {
              "textRaw": "response.statusMessage",
              "name": "statusMessage",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>When using implicit headers (not calling [<code>response.writeHead()</code>][] explicitly), this property\ncontrols the status message that will be sent to the client when the headers get\nflushed. If this is left as <code>undefined</code> then the standard message for the status\ncode will be used.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">response.statusMessage = &#39;Not found&#39;;\n</code></pre>\n<p>After response header was sent to the client, this property indicates the\nstatus message which was sent out.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.IncomingMessage",
          "type": "class",
          "name": "http.IncomingMessage",
          "meta": {
            "added": [
              "v0.1.17"
            ]
          },
          "desc": "<p>An <code>IncomingMessage</code> object is created by [<code>http.Server</code>][] or\n[<code>http.ClientRequest</code>][] and passed as the first argument to the <code>&#39;request&#39;</code>\nand <code>&#39;response&#39;</code> event respectively. It may be used to access response status,\nheaders and data.</p>\n<p>It implements the [Readable Stream][] interface, as well as the\nfollowing additional events, methods, and properties.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'aborted'",
              "type": "event",
              "name": "aborted",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Emitted when the request has been aborted by the client and the network\nsocket has closed.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.4.2"
                ]
              },
              "desc": "<p><code>function () { }</code></p>\n<p>Indicates that the underlying connection was closed.\nJust like <code>&#39;end&#39;</code>, this event occurs only once per response.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "message.destroy([error])",
              "type": "method",
              "name": "destroy",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`error` {Error} ",
                      "name": "error",
                      "type": "Error",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "error",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Calls <code>destroy()</code> on the socket that received the <code>IncomingMessage</code>. If <code>error</code>\nis provided, an <code>&#39;error&#39;</code> event is emitted and <code>error</code> is passed as an argument\nto any listeners on the event.</p>\n"
            },
            {
              "textRaw": "message.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>Calls <code>message.connection.setTimeout(msecs, callback)</code>.</p>\n<p>Returns <code>message</code>.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "message.headers",
              "name": "headers",
              "meta": {
                "added": [
                  "v0.1.5"
                ]
              },
              "desc": "<p>The request/response headers object.</p>\n<p>Key-value pairs of header names and values. Header names are lower-cased.\nExample:</p>\n<pre><code class=\"lang-js\">// Prints something like:\n//\n// { &#39;user-agent&#39;: &#39;curl/7.22.0&#39;,\n//   host: &#39;127.0.0.1:8000&#39;,\n//   accept: &#39;*/*&#39; }\nconsole.log(request.headers);\n</code></pre>\n<p>Duplicates in raw headers are handled in the following ways, depending on the\nheader name:</p>\n<ul>\n<li>Duplicates of <code>age</code>, <code>authorization</code>, <code>content-length</code>, <code>content-type</code>,\n<code>etag</code>, <code>expires</code>, <code>from</code>, <code>host</code>, <code>if-modified-since</code>, <code>if-unmodified-since</code>,\n<code>last-modified</code>, <code>location</code>, <code>max-forwards</code>, <code>proxy-authorization</code>, <code>referer</code>,\n<code>retry-after</code>, or <code>user-agent</code> are discarded.</li>\n<li><code>set-cookie</code> is always an array. Duplicates are added to the array.</li>\n<li>For all other headers, the values are joined together with &#39;, &#39;.</li>\n</ul>\n"
            },
            {
              "textRaw": "message.httpVersion",
              "name": "httpVersion",
              "meta": {
                "added": [
                  "v0.1.1"
                ]
              },
              "desc": "<p>In case of server request, the HTTP version sent by the client. In the case of\nclient response, the HTTP version of the connected-to server.\nProbably either <code>&#39;1.1&#39;</code> or <code>&#39;1.0&#39;</code>.</p>\n<p>Also <code>message.httpVersionMajor</code> is the first integer and\n<code>message.httpVersionMinor</code> is the second.</p>\n"
            },
            {
              "textRaw": "message.method",
              "name": "method",
              "meta": {
                "added": [
                  "v0.1.1"
                ]
              },
              "desc": "<p><strong>Only valid for request obtained from [<code>http.Server</code>][].</strong></p>\n<p>The request method as a string. Read only. Example:\n<code>&#39;GET&#39;</code>, <code>&#39;DELETE&#39;</code>.</p>\n"
            },
            {
              "textRaw": "message.rawHeaders",
              "name": "rawHeaders",
              "meta": {
                "added": [
                  "v0.11.6"
                ]
              },
              "desc": "<p>The raw request/response headers list exactly as they were received.</p>\n<p>Note that the keys and values are in the same list.  It is <em>not</em> a\nlist of tuples.  So, the even-numbered offsets are key values, and the\nodd-numbered offsets are the associated values.</p>\n<p>Header names are not lowercased, and duplicates are not merged.</p>\n<pre><code class=\"lang-js\">// Prints something like:\n//\n// [ &#39;user-agent&#39;,\n//   &#39;this is invalid because there can be only one&#39;,\n//   &#39;User-Agent&#39;,\n//   &#39;curl/7.22.0&#39;,\n//   &#39;Host&#39;,\n//   &#39;127.0.0.1:8000&#39;,\n//   &#39;ACCEPT&#39;,\n//   &#39;*/*&#39; ]\nconsole.log(request.rawHeaders);\n</code></pre>\n"
            },
            {
              "textRaw": "message.rawTrailers",
              "name": "rawTrailers",
              "meta": {
                "added": [
                  "v0.11.6"
                ]
              },
              "desc": "<p>The raw request/response trailer keys and values exactly as they were\nreceived.  Only populated at the <code>&#39;end&#39;</code> event.</p>\n"
            },
            {
              "textRaw": "message.statusCode",
              "name": "statusCode",
              "meta": {
                "added": [
                  "v0.1.1"
                ]
              },
              "desc": "<p><strong>Only valid for response obtained from [<code>http.ClientRequest</code>][].</strong></p>\n<p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>\n"
            },
            {
              "textRaw": "message.statusMessage",
              "name": "statusMessage",
              "meta": {
                "added": [
                  "v0.11.10"
                ]
              },
              "desc": "<p><strong>Only valid for response obtained from [<code>http.ClientRequest</code>][].</strong></p>\n<p>The HTTP response status message (reason phrase). E.G. <code>OK</code> or <code>Internal Server Error</code>.</p>\n"
            },
            {
              "textRaw": "message.socket",
              "name": "socket",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>The [<code>net.Socket</code>][] object associated with the connection.</p>\n<p>With HTTPS support, use [<code>request.socket.getPeerCertificate()</code>][] to obtain the\nclient&#39;s authentication details.</p>\n"
            },
            {
              "textRaw": "message.trailers",
              "name": "trailers",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>The request/response trailers object. Only populated at the <code>&#39;end&#39;</code> event.</p>\n"
            },
            {
              "textRaw": "message.url",
              "name": "url",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p><strong>Only valid for request obtained from [<code>http.Server</code>][].</strong></p>\n<p>Request URL string. This contains only the URL that is\npresent in the actual HTTP request. If the request is:</p>\n<pre><code>GET /status?name=ryan HTTP/1.1\\r\\n\nAccept: text/plain\\r\\n\n\\r\\n\n</code></pre><p>Then <code>request.url</code> will be:</p>\n<pre><code>&#39;/status?name=ryan&#39;\n</code></pre><p>If you would like to parse the URL into its parts, you can use\n<code>require(&#39;url&#39;).parse(request.url)</code>.  Example:</p>\n<pre><code>$ node\n&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;)\n{\n  href: &#39;/status?name=ryan&#39;,\n  search: &#39;?name=ryan&#39;,\n  query: &#39;name=ryan&#39;,\n  pathname: &#39;/status&#39;\n}\n</code></pre><p>If you would like to extract the parameters from the query string,\nyou can use the <code>require(&#39;querystring&#39;).parse</code> function, or pass\n<code>true</code> as the second argument to <code>require(&#39;url&#39;).parse</code>.  Example:</p>\n<pre><code>$ node\n&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;, true)\n{\n  href: &#39;/status?name=ryan&#39;,\n  search: &#39;?name=ryan&#39;,\n  query: {name: &#39;ryan&#39;},\n  pathname: &#39;/status&#39;\n}\n</code></pre>"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`METHODS` {Array} ",
          "type": "Array",
          "name": "METHODS",
          "meta": {
            "added": [
              "v0.11.8"
            ]
          },
          "desc": "<p>A list of the HTTP methods that are supported by the parser.</p>\n"
        },
        {
          "textRaw": "`STATUS_CODES` {Object} ",
          "type": "Object",
          "name": "STATUS_CODES",
          "meta": {
            "added": [
              "v0.1.22"
            ]
          },
          "desc": "<p>A collection of all the standard HTTP response status codes, and the\nshort description of each.  For example, <code>http.STATUS_CODES[404] === &#39;Not\nFound&#39;</code>.</p>\n"
        },
        {
          "textRaw": "http.globalAgent",
          "name": "globalAgent",
          "meta": {
            "added": [
              "v0.5.9"
            ]
          },
          "desc": "<p>Global instance of Agent which is used as the default for all http client\nrequests.</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "http.createClient([port][, host])",
          "type": "method",
          "name": "createClient",
          "meta": {
            "added": [
              "v0.1.13"
            ],
            "deprecated": [
              "v0.3.6"
            ]
          },
          "stability": 0,
          "stabilityText": "Deprecated: Use [`http.request()`][] instead.",
          "desc": "<p>Constructs a new HTTP client. <code>port</code> and <code>host</code> refer to the server to be\nconnected to.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port",
                  "optional": true
                },
                {
                  "name": "host",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.createServer([requestListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "v0.1.13"
            ]
          },
          "desc": "<p>Returns a new instance of [<code>http.Server</code>][].</p>\n<p>The <code>requestListener</code> is a function which is automatically\nadded to the <code>&#39;request&#39;</code> event.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "requestListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.get(options[, callback])",
          "type": "method",
          "name": "get",
          "meta": {
            "added": [
              "v0.3.6"
            ]
          },
          "desc": "<p>Since most requests are GET requests without bodies, Node.js provides this\nconvenience method. The only difference between this method and [<code>http.request()</code>][]\nis that it sets the method to GET and calls <code>req.end()</code> automatically.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">http.get(&#39;http://www.google.com/index.html&#39;, (res) =&gt; {\n  console.log(`Got response: ${res.statusCode}`);\n  // consume response body\n  res.resume();\n}).on(&#39;error&#39;, (e) =&gt; {\n  console.log(`Got error: ${e.message}`);\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.request(options[, callback])",
          "type": "method",
          "name": "request",
          "meta": {
            "added": [
              "v0.3.6"
            ]
          },
          "desc": "<p>Node.js maintains several connections per server to make HTTP requests.\nThis function allows one to transparently issue requests.</p>\n<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is\nautomatically parsed with [<code>url.parse()</code>][].</p>\n<p>Options:</p>\n<ul>\n<li><code>protocol</code>: Protocol to use. Defaults to <code>&#39;http:&#39;</code>.</li>\n<li><code>host</code>: A domain name or IP address of the server to issue the request to.\nDefaults to <code>&#39;localhost&#39;</code>.</li>\n<li><code>hostname</code>: Alias for <code>host</code>. To support [<code>url.parse()</code>][] <code>hostname</code> is\npreferred over <code>host</code>.</li>\n<li><code>family</code>: IP address family to use when resolving <code>host</code> and <code>hostname</code>.\nValid values are <code>4</code> or <code>6</code>. When unspecified, both IP v4 and v6 will be\nused.</li>\n<li><code>port</code>: Port of remote server. Defaults to 80.</li>\n<li><code>localAddress</code>: Local interface to bind for network connections.</li>\n<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath).</li>\n<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&#39;GET&#39;</code>.</li>\n<li><code>path</code>: Request path. Defaults to <code>&#39;/&#39;</code>. Should include query string if any.\nE.G. <code>&#39;/index.html?page=12&#39;</code>. An exception is thrown when the request path\ncontains illegal characters. Currently, only spaces are rejected but that\nmay change in the future.</li>\n<li><code>headers</code>: An object containing request headers.</li>\n<li><code>auth</code>: Basic authentication i.e. <code>&#39;user:password&#39;</code> to compute an\nAuthorization header.</li>\n<li><code>agent</code>: Controls [<code>Agent</code>][] behavior. When an Agent is used request will\ndefault to <code>Connection: keep-alive</code>. Possible values:<ul>\n<li><code>undefined</code> (default): use [<code>http.globalAgent</code>][] for this host and port.</li>\n<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>\n<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to\n<code>Connection: close</code>.</li>\n</ul>\n</li>\n</ul>\n<p>The optional <code>callback</code> parameter will be added as a one time listener for\nthe <code>&#39;response&#39;</code> event.</p>\n<p><code>http.request()</code> returns an instance of the [<code>http.ClientRequest</code>][]\nclass. The <code>ClientRequest</code> instance is a writable stream. If one needs to\nupload a file with a POST request, then write to the <code>ClientRequest</code> object.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var postData = querystring.stringify({\n  &#39;msg&#39; : &#39;Hello World!&#39;\n});\n\nvar options = {\n  hostname: &#39;www.google.com&#39;,\n  port: 80,\n  path: &#39;/upload&#39;,\n  method: &#39;POST&#39;,\n  headers: {\n    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,\n    &#39;Content-Length&#39;: Buffer.byteLength(postData)\n  }\n};\n\nvar req = http.request(options, (res) =&gt; {\n  console.log(`STATUS: ${res.statusCode}`);\n  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n  res.setEncoding(&#39;utf8&#39;);\n  res.on(&#39;data&#39;, (chunk) =&gt; {\n    console.log(`BODY: ${chunk}`);\n  });\n  res.on(&#39;end&#39;, () =&gt; {\n    console.log(&#39;No more data in response.&#39;)\n  })\n});\n\nreq.on(&#39;error&#39;, (e) =&gt; {\n  console.log(`problem with request: ${e.message}`);\n});\n\n// write data to request body\nreq.write(postData);\nreq.end();\n</code></pre>\n<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one\nmust always call <code>req.end()</code> to signify that you&#39;re done with the request -\neven if there is no data being written to the request body.</p>\n<p>If any error is encountered during the request (be that with DNS resolution,\nTCP level errors, or actual HTTP parse errors) an <code>&#39;error&#39;</code> event is emitted\non the returned request object. As with all <code>&#39;error&#39;</code> events, if no listeners\nare registered the error will be thrown.</p>\n<p>There are a few special headers that should be noted.</p>\n<ul>\n<li><p>Sending a &#39;Connection: keep-alive&#39; will notify Node.js that the connection to\nthe server should be persisted until the next request.</p>\n</li>\n<li><p>Sending a &#39;Content-length&#39; header will disable the default chunked encoding.</p>\n</li>\n<li><p>Sending an &#39;Expect&#39; header will immediately send the request headers.\nUsually, when sending &#39;Expect: 100-continue&#39;, you should both set a timeout\nand listen for the <code>&#39;continue&#39;</code> event. See RFC2616 Section 8.2.3 for more\ninformation.</p>\n</li>\n<li><p>Sending an Authorization header will override using the <code>auth</code> option\nto compute basic authentication.</p>\n</li>\n</ul>\n<!-- [end-include:http.md] -->\n<!-- [start-include:https.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "HTTP"
    },
    {
      "textRaw": "HTTPS",
      "name": "https",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a\nseparate module.</p>\n",
      "classes": [
        {
          "textRaw": "Class: https.Agent",
          "type": "class",
          "name": "https.Agent",
          "meta": {
            "added": [
              "v0.4.5"
            ]
          },
          "desc": "<p>An Agent object for HTTPS similar to [<code>http.Agent</code>][].  See [<code>https.request()</code>][]\nfor more information.</p>\n"
        },
        {
          "textRaw": "Class: https.Server",
          "type": "class",
          "name": "https.Server",
          "meta": {
            "added": [
              "v0.3.4"
            ]
          },
          "desc": "<p>This class is a subclass of <code>tls.Server</code> and emits events same as\n[<code>http.Server</code>][]. See [<code>http.Server</code>][] for more information.</p>\n",
          "methods": [
            {
              "textRaw": "server.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.11.2"
                ]
              },
              "desc": "<p>See [<code>http.Server#setTimeout()</code>][].</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "server.timeout",
              "name": "timeout",
              "meta": {
                "added": [
                  "v0.11.2"
                ]
              },
              "desc": "<p>See [<code>http.Server#timeout</code>][].</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "https.createServer(options[, requestListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "v0.3.4"
            ]
          },
          "desc": "<p>Returns a new HTTPS web server object. The <code>options</code> is similar to\n[<code>tls.createServer()</code>][].  The <code>requestListener</code> is a function which is\nautomatically added to the <code>&#39;request&#39;</code> event.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// curl -k https://localhost:8000/\nconst https = require(&#39;https&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),\n  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)\n};\n\nhttps.createServer(options, (req, res) =&gt; {\n  res.writeHead(200);\n  res.end(&#39;hello world\\n&#39;);\n}).listen(8000);\n</code></pre>\n<p>Or</p>\n<pre><code class=\"lang-js\">const https = require(&#39;https&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  pfx: fs.readFileSync(&#39;server.pfx&#39;)\n};\n\nhttps.createServer(options, (req, res) =&gt; {\n  res.writeHead(200);\n  res.end(&#39;hello world\\n&#39;);\n}).listen(8000);\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>See [<code>http.close()</code>][] for details.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(path[, callback])",
              "type": "method",
              "name": "listen",
              "desc": "<p>See [<code>http.listen()</code>][] for details.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(port[, host][, backlog][, callback])",
              "type": "method",
              "name": "listen",
              "desc": "<p>See [<code>http.listen()</code>][] for details.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "requestListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.get(options, callback)",
          "type": "method",
          "name": "get",
          "meta": {
            "added": [
              "v0.3.6"
            ]
          },
          "desc": "<p>Like [<code>http.get()</code>][] but for HTTPS.</p>\n<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is\nautomatically parsed with [<code>url.parse()</code>][].</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const https = require(&#39;https&#39;);\n\nhttps.get(&#39;https://encrypted.google.com/&#39;, (res) =&gt; {\n  console.log(&#39;statusCode: &#39;, res.statusCode);\n  console.log(&#39;headers: &#39;, res.headers);\n\n  res.on(&#39;data&#39;, (d) =&gt; {\n    process.stdout.write(d);\n  });\n\n}).on(&#39;error&#39;, (e) =&gt; {\n  console.error(e);\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.request(options, callback)",
          "type": "method",
          "name": "request",
          "meta": {
            "added": [
              "v0.3.6"
            ]
          },
          "desc": "<p>Makes a request to a secure web server.</p>\n<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is\nautomatically parsed with [<code>url.parse()</code>][].</p>\n<p>All options from [<code>http.request()</code>][] are valid.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const https = require(&#39;https&#39;);\n\nvar options = {\n  hostname: &#39;encrypted.google.com&#39;,\n  port: 443,\n  path: &#39;/&#39;,\n  method: &#39;GET&#39;\n};\n\nvar req = https.request(options, (res) =&gt; {\n  console.log(&#39;statusCode: &#39;, res.statusCode);\n  console.log(&#39;headers: &#39;, res.headers);\n\n  res.on(&#39;data&#39;, (d) =&gt; {\n    process.stdout.write(d);\n  });\n});\nreq.end();\n\nreq.on(&#39;error&#39;, (e) =&gt; {\n  console.error(e);\n});\n</code></pre>\n<p>The options argument has the following options</p>\n<ul>\n<li><code>host</code>: A domain name or IP address of the server to issue the request to.\nDefaults to <code>&#39;localhost&#39;</code>.</li>\n<li><code>hostname</code>: Alias for <code>host</code>. To support <code>url.parse()</code> <code>hostname</code> is\npreferred over <code>host</code>.</li>\n<li><code>family</code>: IP address family to use when resolving <code>host</code> and <code>hostname</code>.\nValid values are <code>4</code> or <code>6</code>. When unspecified, both IP v4 and v6 will be\nused.</li>\n<li><code>port</code>: Port of remote server. Defaults to 443.</li>\n<li><code>localAddress</code>: Local interface to bind for network connections.</li>\n<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath).</li>\n<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&#39;GET&#39;</code>.</li>\n<li><code>path</code>: Request path. Defaults to <code>&#39;/&#39;</code>. Should include query string if any.\nE.G. <code>&#39;/index.html?page=12&#39;</code>. An exception is thrown when the request path\ncontains illegal characters. Currently, only spaces are rejected but that\nmay change in the future.</li>\n<li><code>headers</code>: An object containing request headers.</li>\n<li><code>auth</code>: Basic authentication i.e. <code>&#39;user:password&#39;</code> to compute an\nAuthorization header.</li>\n<li><code>agent</code>: Controls [<code>Agent</code>][] behavior. When an Agent is used request will\ndefault to <code>Connection: keep-alive</code>. Possible values:<ul>\n<li><code>undefined</code> (default): use [<code>globalAgent</code>][] for this host and port.</li>\n<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>\n<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to\n<code>Connection: close</code>.</li>\n</ul>\n</li>\n</ul>\n<p>The following options from [<code>tls.connect()</code>][] can also be specified. However, a\n[<code>globalAgent</code>][] silently ignores these.</p>\n<ul>\n<li><code>pfx</code>: Certificate, Private key and CA certificates to use for SSL. Default <code>null</code>.</li>\n<li><code>key</code>: Private key to use for SSL. Default <code>null</code>.</li>\n<li><code>passphrase</code>: A string of passphrase for the private key or pfx. Default <code>null</code>.</li>\n<li><code>cert</code>: Public x509 certificate to use. Default <code>null</code>.</li>\n<li><code>ca</code>: A string, [<code>Buffer</code>][] or array of strings or [<code>Buffer</code>][]s of trusted\ncertificates in PEM format. If this is omitted several well known &quot;root&quot;\nCAs will be used, like VeriSign. These are used to authorize connections.</li>\n<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult\n<a href=\"https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT\">https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT</a> for\ndetails on the format.</li>\n<li><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against\nthe list of supplied CAs. An <code>&#39;error&#39;</code> event is emitted if verification\nfails. Verification happens at the connection level, <em>before</em> the HTTP\nrequest is sent. Default <code>true</code>.</li>\n<li><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force\nSSL version 3. The possible values depend on your installation of\nOpenSSL and are defined in the constant [<code>SSL_METHODS</code>][].</li>\n<li><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</li>\n</ul>\n<p>In order to specify these options, use a custom [<code>Agent</code>][].</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var options = {\n  hostname: &#39;encrypted.google.com&#39;,\n  port: 443,\n  path: &#39;/&#39;,\n  method: &#39;GET&#39;,\n  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),\n  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)\n};\noptions.agent = new https.Agent(options);\n\nvar req = https.request(options, (res) =&gt; {\n  ...\n}\n</code></pre>\n<p>Alternatively, opt out of connection pooling by not using an <code>Agent</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var options = {\n  hostname: &#39;encrypted.google.com&#39;,\n  port: 443,\n  path: &#39;/&#39;,\n  method: &#39;GET&#39;,\n  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),\n  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;),\n  agent: false\n};\n\nvar req = https.request(options, (res) =&gt; {\n  ...\n}\n</code></pre>\n<!-- [end-include:https.md] -->\n<!-- [start-include:modules.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "https.globalAgent",
          "name": "globalAgent",
          "meta": {
            "added": [
              "v0.5.9"
            ]
          },
          "desc": "<p>Global instance of [<code>https.Agent</code>][] for all HTTPS client requests.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "HTTPS"
    },
    {
      "textRaw": "Modules",
      "name": "module",
      "stability": 3,
      "stabilityText": "Locked",
      "desc": "<p>Node.js has a simple module loading system.  In Node.js, files and modules are\nin one-to-one correspondence.  As an example, <code>foo.js</code> loads the module\n<code>circle.js</code> in the same directory.</p>\n<p>The contents of <code>foo.js</code>:</p>\n<pre><code class=\"lang-js\">const circle = require(&#39;./circle.js&#39;);\nconsole.log( `The area of a circle of radius 4 is ${circle.area(4)}`);\n</code></pre>\n<p>The contents of <code>circle.js</code>:</p>\n<pre><code class=\"lang-js\">const PI = Math.PI;\n\nexports.area = (r) =&gt; PI * r * r;\n\nexports.circumference = (r) =&gt; 2 * PI * r;\n</code></pre>\n<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and\n<code>circumference()</code>.  To add functions and objects to the root of your module,\nyou can add them to the special <code>exports</code> object.</p>\n<p>Variables local to the module will be private, because the module is wrapped\nin a function by Node.js (see <a href=\"#modules_the_module_wrapper\">module wrapper</a>).\nIn this example, the variable <code>PI</code> is private to <code>circle.js</code>.</p>\n<p>If you want the root of your module&#39;s export to be a function (such as a\nconstructor) or if you want to export a complete object in one assignment\ninstead of building it one property at a time, assign it to <code>module.exports</code>\ninstead of <code>exports</code>.</p>\n<p>Below, <code>bar.js</code> makes use of the <code>square</code> module, which exports a constructor:</p>\n<pre><code class=\"lang-js\">const square = require(&#39;./square.js&#39;);\nvar mySquare = square(2);\nconsole.log(`The area of my square is ${mySquare.area()}`);\n</code></pre>\n<p>The <code>square</code> module is defined in <code>square.js</code>:</p>\n<pre><code class=\"lang-js\">// assigning to exports will not modify module, must use module.exports\nmodule.exports = (width) =&gt; {\n  return {\n    area: () =&gt; width * width\n  };\n}\n</code></pre>\n<p>The module system is implemented in the <code>require(&quot;module&quot;)</code> module.</p>\n",
      "miscs": [
        {
          "textRaw": "Accessing the main module",
          "name": "Accessing the main module",
          "type": "misc",
          "desc": "<p>When a file is run directly from Node.js, <code>require.main</code> is set to its\n<code>module</code>. That means that you can determine whether a file has been run\ndirectly by testing</p>\n<pre><code class=\"lang-js\">require.main === module\n</code></pre>\n<p>For a file <code>foo.js</code>, this will be <code>true</code> if run via <code>node foo.js</code>, but\n<code>false</code> if run by <code>require(&#39;./foo&#39;)</code>.</p>\n<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to\n<code>__filename</code>), the entry point of the current application can be obtained\nby checking <code>require.main.filename</code>.</p>\n"
        },
        {
          "textRaw": "Addenda: Package Manager Tips",
          "name": "Addenda: Package Manager Tips",
          "type": "misc",
          "desc": "<p>The semantics of Node.js&#39;s <code>require()</code> function were designed to be general\nenough to support a number of reasonable directory structures. Package manager\nprograms such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to\nbuild native packages from Node.js modules without modification.</p>\n<p>Below we give a suggested directory structure that could work:</p>\n<p>Let&#39;s say that we wanted to have the folder at\n<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a\nspecific version of a package.</p>\n<p>Packages can depend on one another. In order to install package <code>foo</code>, you\nmay have to install a specific version of package <code>bar</code>.  The <code>bar</code> package\nmay itself have dependencies, and in some cases, these dependencies may even\ncollide or form cycles.</p>\n<p>Since Node.js looks up the <code>realpath</code> of any modules it loads (that is,\nresolves symlinks), and then looks for their dependencies in the <code>node_modules</code>\nfolders as described <a href=\"#modules_loading_from_node_modules_folders\">here</a>, this\nsituation is very simple to resolve with the following architecture:</p>\n<ul>\n<li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li>\n<li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>\ndepends on.</li>\n<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to\n<code>/usr/lib/node/bar/4.3.2/</code>.</li>\n<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages\nthat <code>bar</code> depends on.</li>\n</ul>\n<p>Thus, even if a cycle is encountered, or if there are dependency\nconflicts, every module will be able to get a version of its dependency\nthat it can use.</p>\n<p>When the code in the <code>foo</code> package does <code>require(&#39;bar&#39;)</code>, it will get the\nversion that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.\nThen, when the code in the <code>bar</code> package calls <code>require(&#39;quux&#39;)</code>, it&#39;ll get\nthe version that is symlinked into\n<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>\n<p>Furthermore, to make the module lookup process even more optimal, rather\nthan putting packages directly in <code>/usr/lib/node</code>, we could put them in\n<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then Node.js will not bother\nlooking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p>\n<p>In order to make modules available to the Node.js REPL, it might be useful to\nalso add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment\nvariable.  Since the module lookups using <code>node_modules</code> folders are all\nrelative, and based on the real path of the files making the calls to\n<code>require()</code>, the packages themselves can be anywhere.</p>\n"
        },
        {
          "textRaw": "All Together...",
          "name": "All Together...",
          "type": "misc",
          "desc": "<p>To get the exact filename that will be loaded when <code>require()</code> is called, use\nthe <code>require.resolve()</code> function.</p>\n<p>Putting together all of the above, here is the high-level algorithm\nin pseudocode of what require.resolve does:</p>\n<pre><code>require(X) from module at path Y\n1. If X is a core module,\n   a. return the core module\n   b. STOP\n2. If X begins with &#39;./&#39; or &#39;/&#39; or &#39;../&#39;\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n3. LOAD_NODE_MODULES(X, dirname(Y))\n4. THROW &quot;not found&quot;\n\nLOAD_AS_FILE(X)\n1. If X is a file, load X as JavaScript text.  STOP\n2. If X.js is a file, load X.js as JavaScript text.  STOP\n3. If X.json is a file, parse X.json to a JavaScript Object.  STOP\n4. If X.node is a file, load X.node as binary addon.  STOP\n\nLOAD_AS_DIRECTORY(X)\n1. If X/package.json is a file,\n   a. Parse X/package.json, and look for &quot;main&quot; field.\n   b. let M = X + (json main field)\n   c. LOAD_AS_FILE(M)\n2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP\n3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n4. If X/index.node is a file, load X/index.node as binary addon.  STOP\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = []\n4. while I &gt;= 0,\n   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE\n   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)\n   b. DIRS = DIRS + DIR\n   c. let I = I - 1\n5. return DIRS\n</code></pre>"
        },
        {
          "textRaw": "Caching",
          "name": "Caching",
          "type": "misc",
          "desc": "<p>Modules are cached after the first time they are loaded.  This means\n(among other things) that every call to <code>require(&#39;foo&#39;)</code> will get\nexactly the same object returned, if it would resolve to the same file.</p>\n<p>Multiple calls to <code>require(&#39;foo&#39;)</code> may not cause the module code to be\nexecuted multiple times.  This is an important feature.  With it,\n&quot;partially done&quot; objects can be returned, thus allowing transitive\ndependencies to be loaded even when they would cause cycles.</p>\n<p>If you want to have a module execute code multiple times, then export a\nfunction, and call that function.</p>\n",
          "miscs": [
            {
              "textRaw": "Module Caching Caveats",
              "name": "Module Caching Caveats",
              "type": "misc",
              "desc": "<p>Modules are cached based on their resolved filename.  Since modules may\nresolve to a different filename based on the location of the calling\nmodule (loading from <code>node_modules</code> folders), it is not a <em>guarantee</em>\nthat <code>require(&#39;foo&#39;)</code> will always return the exact same object, if it\nwould resolve to different files.</p>\n<p>Additionally, on case-insensitive file systems or operating systems, different\nresolved filenames can point to the same file, but the cache will still treat\nthem as different modules and will reload the file multiple times. For example,\n<code>require(&#39;./foo&#39;)</code> and <code>require(&#39;./FOO&#39;)</code> return two different objects,\nirrespective of whether or not <code>./foo</code> and <code>./FOO</code> are the same file.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Core Modules",
          "name": "Core Modules",
          "type": "misc",
          "desc": "<p>Node.js has several modules compiled into the binary.  These modules are\ndescribed in greater detail elsewhere in this documentation.</p>\n<p>The core modules are defined within Node.js&#39;s source and are located in the\n<code>lib/</code> folder.</p>\n<p>Core modules are always preferentially loaded if their identifier is\npassed to <code>require()</code>.  For instance, <code>require(&#39;http&#39;)</code> will always\nreturn the built in HTTP module, even if there is a file by that name.</p>\n"
        },
        {
          "textRaw": "Cycles",
          "name": "Cycles",
          "type": "misc",
          "desc": "<p>When there are circular <code>require()</code> calls, a module might not have finished\nexecuting when it is returned.</p>\n<p>Consider this situation:</p>\n<p><code>a.js</code>:</p>\n<pre><code>console.log(&#39;a starting&#39;);\nexports.done = false;\nconst b = require(&#39;./b.js&#39;);\nconsole.log(&#39;in a, b.done = %j&#39;, b.done);\nexports.done = true;\nconsole.log(&#39;a done&#39;);\n</code></pre><p><code>b.js</code>:</p>\n<pre><code>console.log(&#39;b starting&#39;);\nexports.done = false;\nconst a = require(&#39;./a.js&#39;);\nconsole.log(&#39;in b, a.done = %j&#39;, a.done);\nexports.done = true;\nconsole.log(&#39;b done&#39;);\n</code></pre><p><code>main.js</code>:</p>\n<pre><code>console.log(&#39;main starting&#39;);\nconst a = require(&#39;./a.js&#39;);\nconst b = require(&#39;./b.js&#39;);\nconsole.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done);\n</code></pre><p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>.  At that\npoint, <code>b.js</code> tries to load <code>a.js</code>.  In order to prevent an infinite\nloop, an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the\n<code>b.js</code> module.  <code>b.js</code> then finishes loading, and its <code>exports</code> object is\nprovided to the <code>a.js</code> module.</p>\n<p>By the time <code>main.js</code> has loaded both modules, they&#39;re both finished.\nThe output of this program would thus be:</p>\n<pre><code>$ node main.js\nmain starting\na starting\nb starting\nin b, a.done = false\nb done\nin a, b.done = true\na done\nin main, a.done=true, b.done=true\n</code></pre><p>If you have cyclic module dependencies in your program, make sure to\nplan accordingly.</p>\n"
        },
        {
          "textRaw": "File Modules",
          "name": "File Modules",
          "type": "misc",
          "desc": "<p>If the exact filename is not found, then Node.js will attempt to load the\nrequired filename with the added extensions: <code>.js</code>, <code>.json</code>, and finally\n<code>.node</code>.</p>\n<p><code>.js</code> files are interpreted as JavaScript text files, and <code>.json</code> files are\nparsed as JSON text files. <code>.node</code> files are interpreted as compiled addon\nmodules loaded with <code>dlopen</code>.</p>\n<p>A required module prefixed with <code>&#39;/&#39;</code> is an absolute path to the file.  For\nexample, <code>require(&#39;/home/marco/foo.js&#39;)</code> will load the file at\n<code>/home/marco/foo.js</code>.</p>\n<p>A required module prefixed with <code>&#39;./&#39;</code> is relative to the file calling\n<code>require()</code>. That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for\n<code>require(&#39;./circle&#39;)</code> to find it.</p>\n<p>Without a leading &#39;/&#39;, &#39;./&#39;, or &#39;../&#39; to indicate a file, the module must\neither be a core module or is loaded from a <code>node_modules</code> folder.</p>\n<p>If the given path does not exist, <code>require()</code> will throw an [<code>Error</code>][] with its\n<code>code</code> property set to <code>&#39;MODULE_NOT_FOUND&#39;</code>.</p>\n"
        },
        {
          "textRaw": "Folders as Modules",
          "name": "Folders as Modules",
          "type": "misc",
          "desc": "<p>It is convenient to organize programs and libraries into self-contained\ndirectories, and then provide a single entry point to that library.\nThere are three ways in which a folder may be passed to <code>require()</code> as\nan argument.</p>\n<p>The first is to create a <code>package.json</code> file in the root of the folder,\nwhich specifies a <code>main</code> module.  An example package.json file might\nlook like this:</p>\n<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,\n  &quot;main&quot; : &quot;./lib/some-library.js&quot; }\n</code></pre><p>If this was in a folder at <code>./some-library</code>, then\n<code>require(&#39;./some-library&#39;)</code> would attempt to load\n<code>./some-library/lib/some-library.js</code>.</p>\n<p>This is the extent of Node.js&#39;s awareness of package.json files.</p>\n<p>Note: If the file specified by the <code>&quot;main&quot;</code> entry of <code>package.json</code> is missing\nand can not be resolved, Node.js will report the entire module as missing with\nthe default error:</p>\n<pre><code>Error: Cannot find module &#39;some-library&#39;\n</code></pre><p>If there is no package.json file present in the directory, then Node.js\nwill attempt to load an <code>index.js</code> or <code>index.node</code> file out of that\ndirectory.  For example, if there was no package.json file in the above\nexample, then <code>require(&#39;./some-library&#39;)</code> would attempt to load:</p>\n<ul>\n<li><code>./some-library/index.js</code></li>\n<li><code>./some-library/index.node</code></li>\n</ul>\n"
        },
        {
          "textRaw": "Loading from `node_modules` Folders",
          "name": "Loading from `node_modules` Folders",
          "type": "misc",
          "desc": "<p>If the module identifier passed to <code>require()</code> is not a native module,\nand does not begin with <code>&#39;/&#39;</code>, <code>&#39;../&#39;</code>, or <code>&#39;./&#39;</code>, then Node.js starts at the\nparent directory of the current module, and adds <code>/node_modules</code>, and\nattempts to load the module from that location. Node will not append\n<code>node_modules</code> to a path already ending in <code>node_modules</code>.</p>\n<p>If it is not found there, then it moves to the parent directory, and so\non, until the root of the file system is reached.</p>\n<p>For example, if the file at <code>&#39;/home/ry/projects/foo.js&#39;</code> called\n<code>require(&#39;bar.js&#39;)</code>, then Node.js would look in the following locations, in\nthis order:</p>\n<ul>\n<li><code>/home/ry/projects/node_modules/bar.js</code></li>\n<li><code>/home/ry/node_modules/bar.js</code></li>\n<li><code>/home/node_modules/bar.js</code></li>\n<li><code>/node_modules/bar.js</code></li>\n</ul>\n<p>This allows programs to localize their dependencies, so that they do not\nclash.</p>\n<p>You can require specific files or sub modules distributed with a module by\nincluding a path suffix after the module name. For instance\n<code>require(&#39;example-module/path/to/file&#39;)</code> would resolve <code>path/to/file</code>\nrelative to where <code>example-module</code> is located. The suffixed path follows the\nsame module resolution semantics.</p>\n"
        },
        {
          "textRaw": "Loading from the global folders",
          "name": "Loading from the global folders",
          "type": "misc",
          "desc": "<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list\nof absolute paths, then Node.js will search those paths for modules if they\nare not found elsewhere.  (Note: On Windows, <code>NODE_PATH</code> is delimited by\nsemicolons instead of colons.)</p>\n<p><code>NODE_PATH</code> was originally created to support loading modules from\nvarying paths before the current [module resolution][] algorithm was frozen.</p>\n<p><code>NODE_PATH</code> is still supported, but is less necessary now that the Node.js\necosystem has settled on a convention for locating dependent modules.\nSometimes deployments that rely on <code>NODE_PATH</code> show surprising behavior\nwhen people are unaware that <code>NODE_PATH</code> must be set.  Sometimes a\nmodule&#39;s dependencies change, causing a different version (or even a\ndifferent module) to be loaded as the <code>NODE_PATH</code> is searched.</p>\n<p>Additionally, Node.js will search in the following locations:</p>\n<ul>\n<li>1: <code>$HOME/.node_modules</code></li>\n<li>2: <code>$HOME/.node_libraries</code></li>\n<li>3: <code>$PREFIX/lib/node</code></li>\n</ul>\n<p>Where <code>$HOME</code> is the user&#39;s home directory, and <code>$PREFIX</code> is Node.js&#39;s\nconfigured <code>node_prefix</code>.</p>\n<p>These are mostly for historic reasons.  <strong>You are highly encouraged\nto place your dependencies locally in <code>node_modules</code> folders.</strong>  They\nwill be loaded faster, and more reliably.</p>\n"
        },
        {
          "textRaw": "The module wrapper",
          "name": "The module wrapper",
          "type": "misc",
          "desc": "<p>Before a module&#39;s code is executed, Node.js will wrap it with a function\nwrapper that looks like the following:</p>\n<pre><code class=\"lang-js\">(function (exports, require, module, __filename, __dirname) {\n// Your module code actually lives in here\n});\n</code></pre>\n<p>By doing this, Node.js achieves a few things:</p>\n<ul>\n<li>It keeps top-level variables (defined with <code>var</code>, <code>const</code> or <code>let</code>) scoped to\nthe module rather than the global object.</li>\n<li>It helps to provide some global-looking variables that are actually specific\nto the module, such as:<ul>\n<li>The <code>module</code> and <code>exports</code> objects that the implementor can use to export\nvalues from the module.</li>\n<li>The convenience variables <code>__filename</code> and <code>__dirname</code>, containing the\nmodule&#39;s absolute filename and directory path.</li>\n</ul>\n</li>\n</ul>\n"
        }
      ],
      "vars": [
        {
          "textRaw": "The `module` Object",
          "name": "module",
          "type": "var",
          "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>In each module, the <code>module</code> free variable is a reference to the object\nrepresenting the current module.  For convenience, <code>module.exports</code> is\nalso accessible via the <code>exports</code> module-global. <code>module</code> isn&#39;t actually\na global but rather local to each module.</p>\n",
          "properties": [
            {
              "textRaw": "`children` {Array} ",
              "type": "Array",
              "name": "children",
              "desc": "<p>The module objects required by this one.</p>\n"
            },
            {
              "textRaw": "`exports` {Object} ",
              "type": "Object",
              "name": "exports",
              "desc": "<p>The <code>module.exports</code> object is created by the Module system. Sometimes this is\nnot acceptable; many want their module to be an instance of some class. To do\nthis, assign the desired export object to <code>module.exports</code>. Note that assigning\nthe desired object to <code>exports</code> will simply rebind the local <code>exports</code> variable,\nwhich is probably not what you want to do.</p>\n<p>For example suppose we were making a module called <code>a.js</code></p>\n<pre><code class=\"lang-js\">const EventEmitter = require(&#39;events&#39;);\n\nmodule.exports = new EventEmitter();\n\n// Do some work, and after some time emit\n// the &#39;ready&#39; event from the module itself.\nsetTimeout(() =&gt; {\n  module.exports.emit(&#39;ready&#39;);\n}, 1000);\n</code></pre>\n<p>Then in another file we could do</p>\n<pre><code class=\"lang-js\">const a = require(&#39;./a&#39;);\na.on(&#39;ready&#39;, () =&gt; {\n  console.log(&#39;module a is ready&#39;);\n});\n</code></pre>\n<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be\ndone in any callbacks.  This does not work:</p>\n<p>x.js:</p>\n<pre><code class=\"lang-js\">setTimeout(() =&gt; {\n  module.exports = { a: &#39;hello&#39; };\n}, 0);\n</code></pre>\n<p>y.js:</p>\n<pre><code class=\"lang-js\">const x = require(&#39;./x&#39;);\nconsole.log(x.a);\n</code></pre>\n",
              "modules": [
                {
                  "textRaw": "exports alias",
                  "name": "exports_alias",
                  "desc": "<p>The <code>exports</code> variable that is available within a module starts as a reference\nto <code>module.exports</code>. As with any variable, if you assign a new value to it, it\nis no longer bound to the previous value.</p>\n<p>To illustrate the behavior, imagine this hypothetical implementation of\n<code>require()</code>:</p>\n<pre><code class=\"lang-js\">function require(...) {\n  // ...\n  ((module, exports) =&gt; {\n    // Your module code here\n    exports = some_func;        // re-assigns exports, exports is no longer\n                                // a shortcut, and nothing is exported.\n    module.exports = some_func; // makes your module export 0\n  })(module, module.exports);\n  return module;\n}\n</code></pre>\n<p>As a guideline, if the relationship between <code>exports</code> and <code>module.exports</code>\nseems like magic to you, ignore <code>exports</code> and only use <code>module.exports</code>.</p>\n",
                  "type": "module",
                  "displayName": "exports alias"
                }
              ]
            },
            {
              "textRaw": "`filename` {String} ",
              "type": "String",
              "name": "filename",
              "desc": "<p>The fully resolved filename to the module.</p>\n"
            },
            {
              "textRaw": "`id` {String} ",
              "type": "String",
              "name": "id",
              "desc": "<p>The identifier for the module.  Typically this is the fully resolved\nfilename.</p>\n"
            },
            {
              "textRaw": "`loaded` {Boolean} ",
              "type": "Boolean",
              "name": "loaded",
              "desc": "<p>Whether or not the module is done loading, or is in the process of\nloading.</p>\n"
            },
            {
              "textRaw": "`parent` {Object} Module object ",
              "type": "Object",
              "name": "parent",
              "desc": "<p>The module that first required this one.</p>\n",
              "shortDesc": "Module object"
            }
          ],
          "methods": [
            {
              "textRaw": "module.require(id)",
              "type": "method",
              "name": "require",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Object} `module.exports` from the resolved module ",
                    "name": "return",
                    "type": "Object",
                    "desc": "`module.exports` from the resolved module"
                  },
                  "params": [
                    {
                      "textRaw": "`id` {String} ",
                      "name": "id",
                      "type": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>module.require</code> method provides a way to load a module as if\n<code>require()</code> was called from the original module.</p>\n<p>Note that in order to do this, you must get a reference to the <code>module</code>\nobject.  Since <code>require()</code> returns the <code>module.exports</code>, and the <code>module</code> is\ntypically <em>only</em> available within a specific module&#39;s code, it must be\nexplicitly exported in order to be used.</p>\n<!-- [end-include:modules.md] -->\n<!-- [start-include:net.md] -->\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "module"
    },
    {
      "textRaw": "net",
      "name": "net",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains\nfunctions for creating both servers and clients (called streams). You can include\nthis module with <code>require(&#39;net&#39;);</code>.</p>\n",
      "classes": [
        {
          "textRaw": "Class: net.Server",
          "type": "class",
          "name": "net.Server",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>This class is used to create a TCP or local server.</p>\n<p><code>net.Server</code> is an [<code>EventEmitter</code>][] with the following events:</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Emitted when the server closes. Note that if connections exist, this\nevent is not emitted until all connections are ended.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when a new connection is made. <code>socket</code> is an instance of\n<code>net.Socket</code>.</p>\n"
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when an error occurs.  The [<code>&#39;close&#39;</code>][] event will be called directly\nfollowing this event.  See example in discussion of <code>server.listen</code>.</p>\n"
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Emitted when the server has been bound after calling <code>server.listen</code>.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Returns the bound address, the address family name, and port of the server\nas reported by the operating system.\nUseful to find which port was assigned when getting an OS-assigned address.\nReturns an object with <code>port</code>, <code>family</code>, and <code>address</code> properties:\n<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var server = net.createServer((socket) =&gt; {\n  socket.end(&#39;goodbye\\n&#39;);\n}).on(&#39;error&#39;, (err) =&gt; {\n  // handle errors here\n  throw err;\n});\n\n// grab a random port.\nserver.listen(() =&gt; {\n  address = server.address();\n  console.log(&#39;opened server on %j&#39;, address);\n});\n</code></pre>\n<p>Don&#39;t call <code>server.address()</code> until the <code>&#39;listening&#39;</code> event has been emitted.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Stops the server from accepting new connections and keeps existing\nconnections. This function is asynchronous, the server is finally\nclosed when all connections are ended and the server emits a [<code>&#39;close&#39;</code>][] event.\nThe optional <code>callback</code> will be called once the <code>&#39;close&#39;</code> event occurs. Unlike\nthat event, it will be called with an Error as its only argument if the server\nwas not open when it was closed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.getConnections(callback)",
              "type": "method",
              "name": "getConnections",
              "meta": {
                "added": [
                  "v0.9.7"
                ]
              },
              "desc": "<p>Asynchronously get the number of concurrent connections on the server. Works\nwhen sockets were sent to forks.</p>\n<p>Callback should take two arguments <code>err</code> and <code>count</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(handle[, backlog][, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.5.10"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`handle` {Object} ",
                      "name": "handle",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`backlog` {Number} ",
                      "name": "backlog",
                      "type": "Number",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>handle</code> object can be set to either a server or socket (anything\nwith an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.</p>\n<p>This will cause the server to accept connections on the specified\nhandle, but it is presumed that the file descriptor or handle has\nalready been bound to a port or domain socket.</p>\n<p>Listening on a file descriptor is not supported on Windows.</p>\n<p>This function is asynchronous.  When the server has been bound,\n[<code>&#39;listening&#39;</code>][] event will be emitted.\nThe last parameter <code>callback</code> will be added as a listener for the\n[<code>&#39;listening&#39;</code>][] event.</p>\n<p>The parameter <code>backlog</code> behaves the same as in\n[<code>server.listen(port[, hostname][, backlog][, callback])</code>][<code>server.listen(port, host, backlog, callback)</code>].</p>\n"
            },
            {
              "textRaw": "server.listen(options[, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} - Required. Supports the following properties: ",
                      "options": [
                        {
                          "textRaw": "`port` {Number} - Optional. ",
                          "name": "port",
                          "type": "Number",
                          "desc": "Optional."
                        },
                        {
                          "textRaw": "`host` {String} - Optional. ",
                          "name": "host",
                          "type": "String",
                          "desc": "Optional."
                        },
                        {
                          "textRaw": "`backlog` {Number} - Optional. ",
                          "name": "backlog",
                          "type": "Number",
                          "desc": "Optional."
                        },
                        {
                          "textRaw": "`path` {String} - Optional. ",
                          "name": "path",
                          "type": "String",
                          "desc": "Optional."
                        },
                        {
                          "textRaw": "`exclusive` {Boolean} - Optional. ",
                          "name": "exclusive",
                          "type": "Boolean",
                          "desc": "Optional."
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "Required. Supports the following properties:"
                    },
                    {
                      "textRaw": "`callback` {Function} - Optional. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Optional.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>port</code>, <code>host</code>, and <code>backlog</code> properties of <code>options</code>, as well as the\noptional callback function, behave as they do on a call to\n[<code>server.listen(port[, hostname][, backlog][, callback])</code>][<code>server.listen(port, host, backlog, callback)</code>].\nAlternatively, the <code>path</code> option can be used to specify a UNIX socket.</p>\n<p>If <code>exclusive</code> is <code>false</code> (default), then cluster workers will use the same\nunderlying handle, allowing connection handling duties to be shared. When\n<code>exclusive</code> is <code>true</code>, the handle is not shared, and attempted port sharing\nresults in an error. An example which listens on an exclusive port is\nshown below.</p>\n<pre><code class=\"lang-js\">server.listen({\n  host: &#39;localhost&#39;,\n  port: 80,\n  exclusive: true\n});\n</code></pre>\n"
            },
            {
              "textRaw": "server.listen(path[, backlog][, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`path` {String} ",
                      "name": "path",
                      "type": "String"
                    },
                    {
                      "textRaw": "`backlog` {Number} ",
                      "name": "backlog",
                      "type": "Number",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Start a local socket server listening for connections on the given <code>path</code>.</p>\n<p>This function is asynchronous.  When the server has been bound,\n[<code>&#39;listening&#39;</code>][] event will be emitted.  The last parameter <code>callback</code>\nwill be added as a listener for the [<code>&#39;listening&#39;</code>][] event.</p>\n<p>On UNIX, the local domain is usually known as the UNIX domain. The path is a\nfilesystem path name. It gets truncated to <code>sizeof(sockaddr_un.sun_path)</code>\nbytes, decreased by 1. It varies on different operating system between 91 and\n107 bytes. The typical values are 107 on Linux and 103 on OS X. The path is\nsubject to the same naming conventions and permissions checks as would be done\non file creation, will be visible in the filesystem, and will <em>persist until\nunlinked</em>.</p>\n<p>On Windows, the local domain is implemented using a named pipe. The path <em>must</em>\nrefer to an entry in <code>\\\\?\\pipe\\</code> or <code>\\\\.\\pipe\\</code>. Any characters are permitted,\nbut the latter may do some processing of pipe names, such as resolving <code>..</code>\nsequences. Despite appearances, the pipe name space is flat.  Pipes will <em>not\npersist</em>, they are removed when the last reference to them is closed. Do not\nforget JavaScript string escaping requires paths to be specified with\ndouble-backslashes, such as:</p>\n<pre><code>net.createServer().listen(\n    path.join(&#39;\\\\\\\\?\\\\pipe&#39;, process.cwd(), &#39;myctl&#39;))\n</code></pre><p>The parameter <code>backlog</code> behaves the same as in\n[<code>server.listen(port[, hostname][, backlog][, callback])</code>][<code>server.listen(port, host, backlog, callback)</code>].</p>\n"
            },
            {
              "textRaw": "server.listen(port[, hostname][, backlog][, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Begin accepting connections on the specified <code>port</code> and <code>hostname</code>. If the\n<code>hostname</code> is omitted, the server will accept connections on any IPv6 address\n(<code>::</code>) when IPv6 is available, or any IPv4 address (<code>0.0.0.0</code>) otherwise. Use a\nport value of <code>0</code> to have the operating system assign an available port.</p>\n<p>Backlog is the maximum length of the queue of pending connections.\nThe actual length will be determined by the OS through sysctl settings such as\n<code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on Linux. The default value of this\nparameter is 511 (not 512).</p>\n<p>This function is asynchronous.  When the server has been bound,\n[<code>&#39;listening&#39;</code>][] event will be emitted.  The last parameter <code>callback</code>\nwill be added as a listener for the [<code>&#39;listening&#39;</code>][] event.</p>\n<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that\nanother server is already running on the requested port. One way of handling this\nwould be to wait a second and then try again:</p>\n<pre><code class=\"lang-js\">server.on(&#39;error&#39;, (e) =&gt; {\n  if (e.code == &#39;EADDRINUSE&#39;) {\n    console.log(&#39;Address in use, retrying...&#39;);\n    setTimeout(() =&gt; {\n      server.close();\n      server.listen(PORT, HOST);\n    }, 1000);\n  }\n});\n</code></pre>\n<p>(Note: All sockets in Node.js are set <code>SO_REUSEADDR</code>.)</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "hostname",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.ref()",
              "type": "method",
              "name": "ref",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "desc": "<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d server will <em>not</em>\nlet the program exit if it&#39;s the only server left (the default behavior). If\nthe server is <code>ref</code>d calling <code>ref</code> again will have no effect.</p>\n<p>Returns <code>server</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.unref()",
              "type": "method",
              "name": "unref",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "desc": "<p>Calling <code>unref</code> on a server will allow the program to exit if this is the only\nactive server in the event system. If the server is already <code>unref</code>d calling\n<code>unref</code> again will have no effect.</p>\n<p>Returns <code>server</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "server.connections",
              "name": "connections",
              "meta": {
                "added": [
                  "v0.2.0"
                ],
                "deprecated": [
                  "v0.9.7"
                ]
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`server.getConnections()`][] instead.",
              "desc": "<p>The number of concurrent connections on the server.</p>\n<p>This becomes <code>null</code> when sending a socket to a child with\n[<code>child_process.fork()</code>][]. To poll forks and get current number of active\nconnections use asynchronous <code>server.getConnections</code> instead.</p>\n"
            },
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "meta": {
                "added": [
                  "v0.2.0"
                ]
              },
              "desc": "<p>Set this property to reject connections when the server&#39;s connection count gets\nhigh.</p>\n<p>It is not recommended to use this option once a socket has been sent to a child\nwith [<code>child_process.fork()</code>][].</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: net.Socket",
          "type": "class",
          "name": "net.Socket",
          "meta": {
            "added": [
              "v0.3.4"
            ]
          },
          "desc": "<p>This object is an abstraction of a TCP or local socket.  <code>net.Socket</code>\ninstances implement a duplex Stream interface.  They can be created by the\nuser and used as a client (with [<code>connect()</code>][]) or they can be created by Node.js\nand passed to the user through the <code>&#39;connection&#39;</code> event of a server.</p>\n",
          "methods": [
            {
              "textRaw": "new net.Socket([options])",
              "type": "method",
              "name": "Socket",
              "meta": {
                "added": [
                  "v0.3.4"
                ]
              },
              "desc": "<p>Construct a new socket object.</p>\n<p><code>options</code> is an object with the following defaults:</p>\n<pre><code class=\"lang-js\">{\n  fd: null,\n  allowHalfOpen: false,\n  readable: false,\n  writable: false\n}\n</code></pre>\n<p><code>fd</code> allows you to specify the existing file descriptor of socket.\nSet <code>readable</code> and/or <code>writable</code> to <code>true</code> to allow reads and/or writes on this\nsocket (NOTE: Works only when <code>fd</code> is passed).\nAbout <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>&#39;end&#39;</code> event.</p>\n<p><code>net.Socket</code> instances are [<code>EventEmitter</code>][] with the following events:</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Returns the bound address, the address family name and port of the\nsocket as reported by the operating system. Returns an object with\nthree properties, e.g.\n<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.connect(options[, connectListener])",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Opens the connection for a given socket.</p>\n<p>For TCP sockets, <code>options</code> argument should be an object which specifies:</p>\n<ul>\n<li><p><code>port</code>: Port the client should connect to (Required).</p>\n</li>\n<li><p><code>host</code>: Host the client should connect to. Defaults to <code>&#39;localhost&#39;</code>.</p>\n</li>\n<li><p><code>localAddress</code>: Local interface to bind to for network connections.</p>\n</li>\n<li><p><code>localPort</code>: Local port to bind to for network connections.</p>\n</li>\n<li><p><code>family</code> : Version of IP stack. Defaults to <code>4</code>.</p>\n</li>\n<li><p><code>lookup</code> : Custom lookup function. Defaults to <code>dns.lookup</code>.</p>\n</li>\n</ul>\n<p>For local domain sockets, <code>options</code> argument should be an object which\nspecifies:</p>\n<ul>\n<li><code>path</code>: Path the client should connect to (Required).</li>\n</ul>\n<p>Normally this method is not needed, as <code>net.createConnection</code> opens the\nsocket. Use this only if you are implementing a custom Socket.</p>\n<p>This function is asynchronous. When the [<code>&#39;connect&#39;</code>][] event is emitted the\nsocket is established. If there is a problem connecting, the <code>&#39;connect&#39;</code> event\nwill not be emitted, the [<code>&#39;error&#39;</code>][] event will be emitted with the exception.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.connect(path[, connectListener])",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>As [<code>socket.connect(options\\[, connectListener\\])</code>][<code>socket.connect(options, connectListener)</code>],\nwith options either as either <code>{port: port, host: host}</code> or <code>{path: path}</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.connect(port[, host][, connectListener])",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>As [<code>socket.connect(options\\[, connectListener\\])</code>][<code>socket.connect(options, connectListener)</code>],\nwith options either as either <code>{port: port, host: host}</code> or <code>{path: path}</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.destroy()",
              "type": "method",
              "name": "destroy",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Ensures that no more I/O activity happens on this socket. Only necessary in\ncase of errors (parse error or so).</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.end([data][, encoding])",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.</p>\n<p>If <code>data</code> is specified, it is equivalent to calling\n<code>socket.write(data, encoding)</code> followed by <code>socket.end()</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<p>Pauses the reading of data. That is, [<code>&#39;data&#39;</code>][] events will not be emitted.\nUseful to throttle back an upload.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.ref()",
              "type": "method",
              "name": "ref",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "desc": "<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d socket will <em>not</em>\nlet the program exit if it&#39;s the only socket left (the default behavior). If\nthe socket is <code>ref</code>d calling <code>ref</code> again will have no effect.</p>\n<p>Returns <code>socket</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<p>Resumes reading after a call to [<code>pause()</code>][].</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.setEncoding([encoding])",
              "type": "method",
              "name": "setEncoding",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Set the encoding for the socket as a [Readable Stream][]. See\n[<code>stream.setEncoding()</code>][] for more information.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setKeepAlive([enable][, initialDelay])",
              "type": "method",
              "name": "setKeepAlive",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n<code>enable</code> defaults to <code>false</code>.</p>\n<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting 0 for\ninitialDelay will leave the value unchanged from the default\n(or previous) setting. Defaults to <code>0</code>.</p>\n<p>Returns <code>socket</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Disables the Nagle algorithm. By default TCP connections use the Nagle\nalgorithm, they buffer data before sending it off. Setting <code>true</code> for\n<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.\n<code>noDelay</code> defaults to <code>true</code>.</p>\n<p>Returns <code>socket</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setTimeout(timeout[, callback])",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on\nthe socket. By default <code>net.Socket</code> do not have a timeout.</p>\n<p>When an idle timeout is triggered the socket will receive a [<code>&#39;timeout&#39;</code>][]\nevent but the connection will not be severed. The user must manually [<code>end()</code>][]\nor [<code>destroy()</code>][] the socket.</p>\n<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>\n<p>The optional <code>callback</code> parameter will be added as a one time listener for the\n[<code>&#39;timeout&#39;</code>][] event.</p>\n<p>Returns <code>socket</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.unref()",
              "type": "method",
              "name": "unref",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "desc": "<p>Calling <code>unref</code> on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already <code>unref</code>d calling\n<code>unref</code> again will have no effect.</p>\n<p>Returns <code>socket</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.write(data[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string--it defaults to UTF8 encoding.</p>\n<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel\nbuffer. Returns <code>false</code> if all or part of the data was queued in user memory.\n[<code>&#39;drain&#39;</code>][] will be emitted when the buffer is again free.</p>\n<p>The optional <code>callback</code> parameter will be executed when the data is finally\nwritten out - this may not be immediately.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean\nwhich says if the socket was closed due to a transmission error.</p>\n"
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Emitted when a socket connection is successfully established.\nSee [<code>connect()</code>][].</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or\n<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.\n(See the [Readable Stream][] section for more information.)</p>\n<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code>Socket</code>\nemits a <code>&#39;data&#39;</code> event.</p>\n"
            },
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>\n<p>See also: the return values of <code>socket.write()</code></p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Emitted when the other end of the socket sends a FIN packet.</p>\n<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file\ndescriptor  once it has written out its pending write queue.  However, by\nsetting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>\nits side allowing the user to write arbitrary amounts of data, with the\ncaveat that the user is required to <code>end()</code> their side now.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>Emitted when an error occurs.  The <code>&#39;close&#39;</code> event will be called directly\nfollowing this event.</p>\n"
            },
            {
              "textRaw": "Event: 'lookup'",
              "type": "event",
              "name": "lookup",
              "meta": {
                "added": [
                  "v0.11.3"
                ]
              },
              "desc": "<p>Emitted after resolving the hostname but before connecting.\nNot applicable to UNIX sockets.</p>\n<ul>\n<li><code>err</code> {Error|Null} The error object.  See [<code>dns.lookup()</code>][].</li>\n<li><code>address</code> {String} The IP address.</li>\n<li><code>family</code> {String|Null} The address type.  See [<code>dns.lookup()</code>][].</li>\n</ul>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'timeout'",
              "type": "event",
              "name": "timeout",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Emitted if the socket times out from inactivity. This is only to notify that\nthe socket has been idle. The user must manually close the connection.</p>\n<p>See also: [<code>socket.setTimeout()</code>][]</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "socket.bufferSize",
              "name": "bufferSize",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket - the network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible. (Internally it is\npolling on the socket&#39;s file descriptor for being writable).</p>\n<p>The consequence of this internal buffering is that memory may grow. This\nproperty shows the number of characters currently buffered to be written.\n(Number of characters is approximately equal to the number of bytes to be\nwritten, but the buffer may contain strings, and the strings are lazily\nencoded, so the exact number of bytes is not known.)</p>\n<p>Users who experience large or growing <code>bufferSize</code> should attempt to\n&quot;throttle&quot; the data flows in their program with [<code>pause()</code>][] and [<code>resume()</code>][].</p>\n"
            },
            {
              "textRaw": "socket.bytesRead",
              "name": "bytesRead",
              "meta": {
                "added": [
                  "v0.5.3"
                ]
              },
              "desc": "<p>The amount of received bytes.</p>\n"
            },
            {
              "textRaw": "socket.bytesWritten",
              "name": "bytesWritten",
              "meta": {
                "added": [
                  "v0.5.3"
                ]
              },
              "desc": "<p>The amount of bytes sent.</p>\n"
            },
            {
              "textRaw": "socket.destroyed",
              "name": "destroyed",
              "desc": "<p>A Boolean value that indicates if the connection is destroyed or not. Once a\nconnection is destroyed no further data can be transferred using it.</p>\n"
            },
            {
              "textRaw": "socket.localAddress",
              "name": "localAddress",
              "meta": {
                "added": [
                  "v0.9.6"
                ]
              },
              "desc": "<p>The string representation of the local IP address the remote client is\nconnecting on. For example, if you are listening on <code>&#39;0.0.0.0&#39;</code> and the\nclient connects on <code>&#39;192.168.1.1&#39;</code>, the value would be <code>&#39;192.168.1.1&#39;</code>.</p>\n"
            },
            {
              "textRaw": "socket.localPort",
              "name": "localPort",
              "meta": {
                "added": [
                  "v0.9.6"
                ]
              },
              "desc": "<p>The numeric representation of the local port. For example,\n<code>80</code> or <code>21</code>.</p>\n"
            },
            {
              "textRaw": "socket.remoteAddress",
              "name": "remoteAddress",
              "meta": {
                "added": [
                  "v0.5.10"
                ]
              },
              "desc": "<p>The string representation of the remote IP address. For example,\n<code>&#39;74.125.127.100&#39;</code> or <code>&#39;2001:4860:a005::68&#39;</code>. Value may be <code>undefined</code> if\nthe socket is destroyed (for example, if the client disconnected).</p>\n"
            },
            {
              "textRaw": "socket.remoteFamily",
              "name": "remoteFamily",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>The string representation of the remote IP family. <code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>.</p>\n"
            },
            {
              "textRaw": "socket.remotePort",
              "name": "remotePort",
              "meta": {
                "added": [
                  "v0.5.10"
                ]
              },
              "desc": "<p>The numeric representation of the remote port. For example,\n<code>80</code> or <code>21</code>.</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "net.connect(options[, connectListener])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.7.0"
            ]
          },
          "desc": "<p>A factory function, which returns a new [<code>net.Socket</code>][] and automatically\nconnects with the supplied <code>options</code>.</p>\n<p>The options are passed to both the [<code>net.Socket</code>][] constructor and the\n[<code>socket.connect</code>][] method.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event once.</p>\n<p>Here is an example of a client of the previously described echo server:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst client = net.connect({port: 8124}, () =&gt; {\n  // &#39;connect&#39; listener\n  console.log(&#39;connected to server!&#39;);\n  client.write(&#39;world!\\r\\n&#39;);\n});\nclient.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data.toString());\n  client.end();\n});\nclient.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;disconnected from server&#39;);\n});\n</code></pre>\n<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be\nchanged to</p>\n<pre><code class=\"lang-js\">const client = net.connect({path: &#39;/tmp/echo.sock&#39;});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(path[, connectListener])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>A factory function, which returns a new unix [<code>net.Socket</code>][] and automatically\nconnects to the supplied <code>path</code>.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event once.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(port[, host][, connectListener])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>A factory function, which returns a new [<code>net.Socket</code>][] and automatically\nconnects to the supplied <code>port</code> and <code>host</code>.</p>\n<p>If <code>host</code> is omitted, <code>&#39;localhost&#39;</code> will be assumed.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event once.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(options[, connectListener])",
          "type": "method",
          "name": "createConnection",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>A factory function, which returns a new [<code>net.Socket</code>][] and automatically\nconnects with the supplied <code>options</code>.</p>\n<p>The options are passed to both the [<code>net.Socket</code>][] constructor and the\n[<code>socket.connect</code>][] method.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event once.</p>\n<p>Here is an example of a client of the previously described echo server:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst client = net.createConnection({port: 8124}, () =&gt; {\n  //&#39;connect&#39; listener\n  console.log(&#39;connected to server!&#39;);\n  client.write(&#39;world!\\r\\n&#39;);\n});\nclient.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data.toString());\n  client.end();\n});\nclient.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;disconnected from server&#39;);\n});\n</code></pre>\n<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be\nchanged to</p>\n<pre><code class=\"lang-js\">const client = net.connect({path: &#39;/tmp/echo.sock&#39;});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(path[, connectListener])",
          "type": "method",
          "name": "createConnection",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>A factory function, which returns a new unix [<code>net.Socket</code>][] and automatically\nconnects to the supplied <code>path</code>.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event once.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(port[, host][, connectListener])",
          "type": "method",
          "name": "createConnection",
          "meta": {
            "added": [
              "v0.1.90"
            ]
          },
          "desc": "<p>A factory function, which returns a new [<code>net.Socket</code>][] and automatically\nconnects to the supplied <code>port</code> and <code>host</code>.</p>\n<p>If <code>host</code> is omitted, <code>&#39;localhost&#39;</code> will be assumed.</p>\n<p>The <code>connectListener</code> parameter will be added as a listener for the\n[<code>&#39;connect&#39;</code>][] event once.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createServer([options][, connectionListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>Creates a new server. The <code>connectionListener</code> argument is\nautomatically set as a listener for the [<code>&#39;connection&#39;</code>][] event.</p>\n<p><code>options</code> is an object with the following defaults:</p>\n<pre><code class=\"lang-js\">{\n  allowHalfOpen: false,\n  pauseOnConnect: false\n}\n</code></pre>\n<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won&#39;t automatically send a FIN\npacket when the other end of the socket sends a FIN packet. The socket becomes\nnon-readable, but still writable. You should call the [<code>end()</code>][] method explicitly.\nSee [<code>&#39;end&#39;</code>][] event for more information.</p>\n<p>If <code>pauseOnConnect</code> is <code>true</code>, then the socket associated with each incoming\nconnection will be paused, and no data will be read from its handle. This allows\nconnections to be passed between processes without any data being read by the\noriginal process. To begin reading data from a paused socket, call [<code>resume()</code>][].</p>\n<p>Here is an example of an echo server which listens for connections\non port 8124:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst server = net.createServer((c) =&gt; {\n  // &#39;connection&#39; listener\n  console.log(&#39;client connected&#39;);\n  c.on(&#39;end&#39;, () =&gt; {\n    console.log(&#39;client disconnected&#39;);\n  });\n  c.write(&#39;hello\\r\\n&#39;);\n  c.pipe(c);\n});\nserver.on(&#39;error&#39;, (err) =&gt; {\n  throw err;\n});\nserver.listen(8124, () =&gt; {\n  console.log(&#39;server bound&#39;);\n});\n</code></pre>\n<p>Test this by using <code>telnet</code>:</p>\n<pre><code>telnet localhost 8124\n</code></pre><p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would\njust be changed to</p>\n<pre><code class=\"lang-js\">server.listen(&#39;/tmp/echo.sock&#39;, () =&gt; {\n  console.log(&#39;server bound&#39;);\n});\n</code></pre>\n<p>Use <code>nc</code> to connect to a UNIX domain socket server:</p>\n<pre><code class=\"lang-js\">nc -U /tmp/echo.sock\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIP(input)",
          "type": "method",
          "name": "isIP",
          "meta": {
            "added": [
              "v0.3.0"
            ]
          },
          "desc": "<p>Tests if input is an IP address. Returns 0 for invalid strings,\nreturns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv4(input)",
          "type": "method",
          "name": "isIPv4",
          "meta": {
            "added": [
              "v0.3.0"
            ]
          },
          "desc": "<p>Returns true if input is a version 4 IP address, otherwise returns false.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv6(input)",
          "type": "method",
          "name": "isIPv6",
          "meta": {
            "added": [
              "v0.3.0"
            ]
          },
          "desc": "<p>Returns true if input is a version 6 IP address, otherwise returns false.</p>\n<!-- [end-include:net.md] -->\n<!-- [start-include:os.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "net"
    },
    {
      "textRaw": "OS",
      "name": "os",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Provides a few basic operating-system related utility functions.</p>\n<p>Use <code>require(&#39;os&#39;)</code> to access this module.</p>\n",
      "properties": [
        {
          "textRaw": "os.EOL",
          "name": "EOL",
          "meta": {
            "added": [
              "v0.7.8"
            ]
          },
          "desc": "<p>A constant defining the appropriate End-of-line marker for the operating\nsystem.</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "os.arch()",
          "type": "method",
          "name": "arch",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>Returns the operating system CPU architecture. Possible values are <code>&#39;x64&#39;</code>,\n<code>&#39;arm&#39;</code> and <code>&#39;ia32&#39;</code>. Returns the value of [<code>process.arch</code>][].</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.cpus()",
          "type": "method",
          "name": "cpus",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns an array of objects containing information about each CPU/core\ninstalled: model, speed (in MHz), and times (an object containing the number of\nmilliseconds the CPU/core spent in: user, nice, sys, idle, and irq).</p>\n<p>Example inspection of os.cpus:</p>\n<pre><code class=\"lang-js\">[ { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 252020,\n       nice: 0,\n       sys: 30340,\n       idle: 1070356870,\n       irq: 0 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 306960,\n       nice: 0,\n       sys: 26980,\n       idle: 1071569080,\n       irq: 0 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 248450,\n       nice: 0,\n       sys: 21750,\n       idle: 1070919370,\n       irq: 0 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 256880,\n       nice: 0,\n       sys: 19430,\n       idle: 1070905480,\n       irq: 20 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 511580,\n       nice: 20,\n       sys: 40900,\n       idle: 1070842510,\n       irq: 0 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 291660,\n       nice: 0,\n       sys: 34360,\n       idle: 1070888000,\n       irq: 10 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 308260,\n       nice: 0,\n       sys: 55410,\n       idle: 1071129970,\n       irq: 880 } },\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\n    speed: 2926,\n    times:\n     { user: 266450,\n       nice: 1480,\n       sys: 34920,\n       idle: 1072572010,\n       irq: 30 } } ]\n</code></pre>\n<p>Note that since <code>nice</code> values are UNIX centric in Windows the <code>nice</code> values of\nall processors are always 0.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.endianness()",
          "type": "method",
          "name": "endianness",
          "meta": {
            "added": [
              "v0.9.4"
            ]
          },
          "desc": "<p>Returns the endianness of the CPU. Possible values are <code>&#39;BE&#39;</code> for big endian\nor <code>&#39;LE&#39;</code> for little endian.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.freemem()",
          "type": "method",
          "name": "freemem",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns the amount of free system memory in bytes.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.homedir()",
          "type": "method",
          "name": "homedir",
          "meta": {
            "added": [
              "v2.3.0"
            ]
          },
          "desc": "<p>Returns the home directory of the current user.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.hostname()",
          "type": "method",
          "name": "hostname",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns the hostname of the operating system.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.loadavg()",
          "type": "method",
          "name": "loadavg",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns an array containing the 1, 5, and 15 minute load averages.</p>\n<p>The load average is a measure of system activity, calculated by the operating\nsystem and expressed as a fractional number.  As a rule of thumb, the load\naverage should ideally be less than the number of logical CPUs in the system.</p>\n<p>The load average is a very UNIX-y concept; there is no real equivalent on\nWindows platforms.  That is why this function always returns <code>[0, 0, 0]</code> on\nWindows.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.networkInterfaces()",
          "type": "method",
          "name": "networkInterfaces",
          "meta": {
            "added": [
              "v0.6.0"
            ]
          },
          "desc": "<p>Get a list of network interfaces:</p>\n<pre><code class=\"lang-js\">{ lo:\n   [ { address: &#39;127.0.0.1&#39;,\n       netmask: &#39;255.0.0.0&#39;,\n       family: &#39;IPv4&#39;,\n       mac: &#39;00:00:00:00:00:00&#39;,\n       internal: true },\n     { address: &#39;::1&#39;,\n       netmask: &#39;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&#39;,\n       family: &#39;IPv6&#39;,\n       mac: &#39;00:00:00:00:00:00&#39;,\n       internal: true } ],\n  eth0:\n   [ { address: &#39;192.168.1.108&#39;,\n       netmask: &#39;255.255.255.0&#39;,\n       family: &#39;IPv4&#39;,\n       mac: &#39;01:02:03:0a:0b:0c&#39;,\n       internal: false },\n     { address: &#39;fe80::a00:27ff:fe4e:66a1&#39;,\n       netmask: &#39;ffff:ffff:ffff:ffff::&#39;,\n       family: &#39;IPv6&#39;,\n       mac: &#39;01:02:03:0a:0b:0c&#39;,\n       internal: false } ] }\n</code></pre>\n<p>Note that due to the underlying implementation this will only return network\ninterfaces that have been assigned an address.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.platform()",
          "type": "method",
          "name": "platform",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>Returns the operating system platform. Possible values are <code>&#39;darwin&#39;</code>,\n<code>&#39;freebsd&#39;</code>, <code>&#39;linux&#39;</code>, <code>&#39;sunos&#39;</code> or <code>&#39;win32&#39;</code>. Returns the value of\n[<code>process.platform</code>][].</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.release()",
          "type": "method",
          "name": "release",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns the operating system release.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.tmpdir()",
          "type": "method",
          "name": "tmpdir",
          "meta": {
            "added": [
              "v0.9.9"
            ]
          },
          "desc": "<p>Returns the operating system&#39;s default directory for temporary files.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.totalmem()",
          "type": "method",
          "name": "totalmem",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns the total amount of system memory in bytes.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.type()",
          "type": "method",
          "name": "type",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns the operating system name. For example <code>&#39;Linux&#39;</code> on Linux, <code>&#39;Darwin&#39;</code>\non OS X and <code>&#39;Windows_NT&#39;</code> on Windows.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.uptime()",
          "type": "method",
          "name": "uptime",
          "meta": {
            "added": [
              "v0.3.3"
            ]
          },
          "desc": "<p>Returns the system uptime in seconds.</p>\n<!-- [end-include:os.md] -->\n<!-- [start-include:path.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "OS"
    },
    {
      "textRaw": "Path",
      "name": "path",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>This module contains utilities for handling and transforming file\npaths.  Almost all these methods perform only string transformations.\nThe file system is not consulted to check whether paths are valid.</p>\n<p>Use <code>require(&#39;path&#39;)</code> to use this module.  The following methods are provided:</p>\n",
      "methods": [
        {
          "textRaw": "path.basename(p[, ext])",
          "type": "method",
          "name": "basename",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;)\n// returns &#39;quux.html&#39;\n\npath.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;, &#39;.html&#39;)\n// returns &#39;quux&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                },
                {
                  "name": "ext",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.dirname(p)",
          "type": "method",
          "name": "dirname",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">path.dirname(&#39;/foo/bar/baz/asdf/quux&#39;)\n// returns &#39;/foo/bar/baz/asdf&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.extname(p)",
          "type": "method",
          "name": "extname",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Return the extension of the path, from the last &#39;.&#39; to end of string\nin the last portion of the path.  If there is no &#39;.&#39; in the last portion\nof the path or the first character of it is &#39;.&#39;, then it returns\nan empty string.  Examples:</p>\n<pre><code class=\"lang-js\">path.extname(&#39;index.html&#39;)\n// returns &#39;.html&#39;\n\npath.extname(&#39;index.coffee.md&#39;)\n// returns &#39;.md&#39;\n\npath.extname(&#39;index.&#39;)\n// returns &#39;.&#39;\n\npath.extname(&#39;index&#39;)\n// returns &#39;&#39;\n\npath.extname(&#39;.index&#39;)\n// returns &#39;&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.format(pathObject)",
          "type": "method",
          "name": "format",
          "meta": {
            "added": [
              "v0.11.15"
            ]
          },
          "desc": "<p>Returns a path string from an object, the opposite of [<code>path.parse</code>][].</p>\n<p>Examples:</p>\n<p>Some Posix system examples:</p>\n<pre><code class=\"lang-js\">// If `dir` and `base` are provided, `dir` + platform separator + `base`\n// will be returned.\npath.format({\n    dir: &#39;/home/user/dir&#39;,\n    base: &#39;file.txt&#39;\n});\n// returns &#39;/home/user/dir/file.txt&#39;\n\n// `base` will be returned if `dir` or `root` are not provided.\npath.format({\n    base: &#39;file.txt&#39;\n});\n// returns &#39;file.txt&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "pathObject"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.isAbsolute(path)",
          "type": "method",
          "name": "isAbsolute",
          "meta": {
            "added": [
              "v0.11.2"
            ]
          },
          "desc": "<p>Determines whether <code>path</code> is an absolute path. An absolute path will always\nresolve to the same location, regardless of the working directory.</p>\n<p>Posix examples:</p>\n<pre><code class=\"lang-js\">path.isAbsolute(&#39;/foo/bar&#39;) // true\npath.isAbsolute(&#39;/baz/..&#39;)  // true\npath.isAbsolute(&#39;qux/&#39;)     // false\npath.isAbsolute(&#39;.&#39;)        // false\n</code></pre>\n<p>Windows examples:</p>\n<pre><code class=\"lang-js\">path.isAbsolute(&#39;//server&#39;)  // true\npath.isAbsolute(&#39;C:/foo/..&#39;) // true\npath.isAbsolute(&#39;bar\\\\baz&#39;)  // false\npath.isAbsolute(&#39;.&#39;)         // false\n</code></pre>\n<p><em>Note:</em> If the path string passed as parameter is a zero-length string, unlike\n        other path module functions, it will be used as-is and <code>false</code> will be\n        returned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.join([path1][, path2][, ...])",
          "type": "method",
          "name": "join",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>Join all arguments together and normalize the resulting path.</p>\n<p>Arguments must be strings.  In v0.8, non-string arguments were\nsilently ignored.  In v0.10 and up, an exception is thrown.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz/asdf&#39;, &#39;quux&#39;, &#39;..&#39;)\n// returns &#39;/foo/bar/baz/asdf&#39;\n\npath.join(&#39;foo&#39;, {}, &#39;bar&#39;)\n// throws exception\nTypeError: Arguments to path.join must be strings\n</code></pre>\n<p><em>Note:</em> If the arguments to <code>join</code> have zero-length strings, unlike other path\n        module functions, they will be ignored. If the joined path string is a\n        zero-length string then <code>&#39;.&#39;</code> will be returned, which represents the\n        current working directory.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path1",
                  "optional": true
                },
                {
                  "name": "path2",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.normalize(p)",
          "type": "method",
          "name": "normalize",
          "meta": {
            "added": [
              "v0.1.23"
            ]
          },
          "desc": "<p>Normalize a string path, taking care of <code>&#39;..&#39;</code> and <code>&#39;.&#39;</code> parts.</p>\n<p>When multiple slashes are found, they&#39;re replaced by a single one;\nwhen the path contains a trailing slash, it is preserved.\nOn Windows backslashes are used.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">path.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;)\n// returns &#39;/foo/bar/baz/asdf&#39;\n</code></pre>\n<p><em>Note:</em> If the path string passed as argument is a zero-length string then <code>&#39;.&#39;</code>\n        will be returned, which represents the current working directory.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.parse(pathString)",
          "type": "method",
          "name": "parse",
          "meta": {
            "added": [
              "v0.11.15"
            ]
          },
          "desc": "<p>Returns an object from a path string.</p>\n<p>An example on *nix:</p>\n<pre><code class=\"lang-js\">path.parse(&#39;/home/user/dir/file.txt&#39;)\n// returns\n// {\n//    root : &quot;/&quot;,\n//    dir : &quot;/home/user/dir&quot;,\n//    base : &quot;file.txt&quot;,\n//    ext : &quot;.txt&quot;,\n//    name : &quot;file&quot;\n// }\n</code></pre>\n<p>An example on Windows:</p>\n<pre><code class=\"lang-js\">path.parse(&#39;C:\\\\path\\\\dir\\\\index.html&#39;)\n// returns\n// {\n//    root : &quot;C:\\\\&quot;,\n//    dir : &quot;C:\\\\path\\\\dir&quot;,\n//    base : &quot;index.html&quot;,\n//    ext : &quot;.html&quot;,\n//    name : &quot;index&quot;\n// }\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "pathString"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.relative(from, to)",
          "type": "method",
          "name": "relative",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>Solve the relative path from <code>from</code> to <code>to</code>.</p>\n<p>At times we have two absolute paths, and we need to derive the relative\npath from one to the other.  This is actually the reverse transform of\n<code>path.resolve</code>, which means we see that:</p>\n<pre><code class=\"lang-js\">path.resolve(from, path.relative(from, to)) == path.resolve(to)\n</code></pre>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">path.relative(&#39;C:\\\\orandea\\\\test\\\\aaa&#39;, &#39;C:\\\\orandea\\\\impl\\\\bbb&#39;)\n// returns &#39;..\\\\..\\\\impl\\\\bbb&#39;\n\npath.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;)\n// returns &#39;../../impl/bbb&#39;\n</code></pre>\n<p><em>Note:</em> If the arguments to <code>relative</code> have zero-length strings then the current\n        working directory will be used instead of the zero-length strings. If\n        both the paths are the same then a zero-length string will be returned.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.resolve([from ...], to)",
          "type": "method",
          "name": "resolve",
          "meta": {
            "added": [
              "v0.3.4"
            ]
          },
          "desc": "<p>Resolves <code>to</code> to an absolute path.</p>\n<p>If <code>to</code> isn&#39;t already absolute <code>from</code> arguments are prepended in right to left\norder, until an absolute path is found. If after using all <code>from</code> paths still\nno absolute path is found, the current working directory is used as well. The\nresulting path is normalized, and trailing slashes are removed unless the path\ngets resolved to the root directory. Non-string <code>from</code> arguments are ignored.</p>\n<p>Another way to think of it is as a sequence of <code>cd</code> commands in a shell.</p>\n<pre><code class=\"lang-js\">path.resolve(&#39;foo/bar&#39;, &#39;/tmp/file/&#39;, &#39;..&#39;, &#39;a/../subfile&#39;)\n</code></pre>\n<p>Is similar to:</p>\n<pre><code>cd foo/bar\ncd /tmp/file/\ncd ..\ncd a/../subfile\npwd\n</code></pre><p>The difference is that the different paths don&#39;t need to exist and may also be\nfiles.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;)\n// returns &#39;/foo/bar/baz&#39;\n\npath.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;)\n// returns &#39;/tmp/file&#39;\n\npath.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;)\n// if currently in /home/myself/node, it returns\n// &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;\n</code></pre>\n<p><em>Note:</em> If the arguments to <code>resolve</code> have zero-length strings then the current\n        working directory will be used instead of them.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from ...",
                  "optional": true
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "path.delimiter",
          "name": "delimiter",
          "meta": {
            "added": [
              "v0.9.3"
            ]
          },
          "desc": "<p>The platform-specific path delimiter, <code>;</code> or <code>&#39;:&#39;</code>.</p>\n<p>An example on *nix:</p>\n<pre><code class=\"lang-js\">console.log(process.env.PATH)\n// &#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#39;\n\nprocess.env.PATH.split(path.delimiter)\n// returns [&#39;/usr/bin&#39;, &#39;/bin&#39;, &#39;/usr/sbin&#39;, &#39;/sbin&#39;, &#39;/usr/local/bin&#39;]\n</code></pre>\n<p>An example on Windows:</p>\n<pre><code class=\"lang-js\">console.log(process.env.PATH)\n// &#39;C:\\Windows\\system32;C:\\Windows;C:\\Program Files\\node\\&#39;\n\nprocess.env.PATH.split(path.delimiter)\n// returns [&#39;C:\\\\Windows\\\\system32&#39;, &#39;C:\\\\Windows&#39;, &#39;C:\\\\Program Files\\\\node\\\\&#39;]\n</code></pre>\n"
        },
        {
          "textRaw": "path.posix",
          "name": "posix",
          "meta": {
            "added": [
              "v0.11.15"
            ]
          },
          "desc": "<p>Provide access to aforementioned <code>path</code> methods but always interact in a posix\ncompatible way.</p>\n"
        },
        {
          "textRaw": "path.sep",
          "name": "sep",
          "meta": {
            "added": [
              "v0.7.9"
            ]
          },
          "desc": "<p>The platform-specific file separator. <code>&#39;\\\\&#39;</code> or <code>&#39;/&#39;</code>.</p>\n<p>An example on *nix:</p>\n<pre><code class=\"lang-js\">&#39;foo/bar/baz&#39;.split(path.sep)\n// returns [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]\n</code></pre>\n<p>An example on Windows:</p>\n<pre><code class=\"lang-js\">&#39;foo\\\\bar\\\\baz&#39;.split(path.sep)\n// returns [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]\n</code></pre>\n"
        },
        {
          "textRaw": "path.win32",
          "name": "win32",
          "meta": {
            "added": [
              "v0.11.15"
            ]
          },
          "desc": "<p>Provide access to aforementioned <code>path</code> methods but always interact in a win32\ncompatible way.</p>\n<!-- [end-include:path.md] -->\n<!-- [start-include:process.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "Path"
    },
    {
      "textRaw": "punycode",
      "name": "punycode",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>[Punycode.js][] is bundled with Node.js v0.5.1+. Use <code>require(&#39;punycode&#39;)</code> to\naccess it. (To use it with other Node.js versions, use npm to install the\n<code>punycode</code> module first.)</p>\n",
      "methods": [
        {
          "textRaw": "punycode.decode(string)",
          "type": "method",
          "name": "decode",
          "meta": {
            "added": [
              "v0.5.1"
            ]
          },
          "desc": "<p>Converts a Punycode string of ASCII-only symbols to a string of Unicode symbols.</p>\n<pre><code class=\"lang-js\">// decode domain name parts\npunycode.decode(&#39;maana-pta&#39;); // &#39;maÃ±ana&#39;\npunycode.decode(&#39;--dqo34k&#39;); // &#39;â˜ƒ-âŒ˜&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "punycode.encode(string)",
          "type": "method",
          "name": "encode",
          "meta": {
            "added": [
              "v0.5.1"
            ]
          },
          "desc": "<p>Converts a string of Unicode symbols to a Punycode string of ASCII-only symbols.</p>\n<pre><code class=\"lang-js\">// encode domain name parts\npunycode.encode(&#39;maÃ±ana&#39;); // &#39;maana-pta&#39;\npunycode.encode(&#39;â˜ƒ-âŒ˜&#39;); // &#39;--dqo34k&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "punycode.toASCII(domain)",
          "type": "method",
          "name": "toASCII",
          "meta": {
            "added": [
              "v0.6.1"
            ]
          },
          "desc": "<p>Converts a Unicode string representing a domain name to Punycode. Only the\nnon-ASCII parts of the domain name will be converted, i.e. it doesn&#39;t matter if\nyou call it with a domain that&#39;s already in ASCII.</p>\n<pre><code class=\"lang-js\">// encode domain names\npunycode.toASCII(&#39;maÃ±ana.com&#39;); // &#39;xn--maana-pta.com&#39;\npunycode.toASCII(&#39;â˜ƒ-âŒ˜.com&#39;); // &#39;xn----dqo34k.com&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "punycode.toUnicode(domain)",
          "type": "method",
          "name": "toUnicode",
          "meta": {
            "added": [
              "v0.6.1"
            ]
          },
          "desc": "<p>Converts a Punycode string representing a domain name to Unicode. Only the\nPunycoded parts of the domain name will be converted, i.e. it doesn&#39;t matter if\nyou call it on a string that has already been converted to Unicode.</p>\n<pre><code class=\"lang-js\">// decode domain names\npunycode.toUnicode(&#39;xn--maana-pta.com&#39;); // &#39;maÃ±ana.com&#39;\npunycode.toUnicode(&#39;xn----dqo34k.com&#39;); // &#39;â˜ƒ-âŒ˜.com&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "punycode.ucs2",
          "name": "ucs2",
          "meta": {
            "added": [
              "v0.7.0"
            ]
          },
          "modules": [
            {
              "textRaw": "punycode.ucs2.decode(string)",
              "name": "punycode.ucs2.decode(string)",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p>Creates an array containing the numeric code point values of each Unicode\nsymbol in the string. While [JavaScript uses UCS-2 internally][], this function\nwill convert a pair of surrogate halves (each of which UCS-2 exposes as\nseparate characters) into a single code point, matching UTF-16.</p>\n<pre><code class=\"lang-js\">punycode.ucs2.decode(&#39;abc&#39;); // [0x61, 0x62, 0x63]\n// surrogate pair for U+1D306 tetragram for centre:\npunycode.ucs2.decode(&#39;\\uD834\\uDF06&#39;); // [0x1D306]\n</code></pre>\n",
              "type": "module",
              "displayName": "punycode.ucs2.decode(string)"
            },
            {
              "textRaw": "punycode.ucs2.encode(codePoints)",
              "name": "punycode.ucs2.encode(codepoints)",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p>Creates a string based on an array of numeric code point values.</p>\n<pre><code class=\"lang-js\">punycode.ucs2.encode([0x61, 0x62, 0x63]); // &#39;abc&#39;\npunycode.ucs2.encode([0x1D306]); // &#39;\\uD834\\uDF06&#39;\n</code></pre>\n",
              "type": "module",
              "displayName": "punycode.ucs2.encode(codePoints)"
            }
          ]
        },
        {
          "textRaw": "punycode.version",
          "name": "version",
          "meta": {
            "added": [
              "v0.6.1"
            ]
          },
          "desc": "<p>A string representing the current Punycode.js version number.</p>\n<!-- [end-include:punycode.md] -->\n<!-- [start-include:querystring.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "punycode"
    },
    {
      "textRaw": "Query String",
      "name": "querystring",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>This module provides utilities for dealing with query strings.\nIt provides the following methods:</p>\n",
      "properties": [
        {
          "textRaw": "querystring.escape",
          "name": "escape",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>The escape function used by <code>querystring.stringify</code>,\nprovided so that it could be overridden if necessary.</p>\n"
        },
        {
          "textRaw": "querystring.unescape",
          "name": "unescape",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>The unescape function used by <code>querystring.parse</code>,\nprovided so that it could be overridden if necessary.</p>\n<p>It will try to use <code>decodeURIComponent</code> in the first place,\nbut if that fails it falls back to a safer equivalent that\ndoesn&#39;t throw on malformed URLs.</p>\n<!-- [end-include:querystring.md] -->\n<!-- [start-include:readline.md] -->\n"
        }
      ],
      "methods": [
        {
          "textRaw": "querystring.parse(str[, sep][, eq][, options])",
          "type": "method",
          "name": "parse",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Deserialize a query string to an object.\nOptionally override the default separator (<code>&#39;&amp;&#39;</code>) and assignment (<code>&#39;=&#39;</code>)\ncharacters.</p>\n<p>Options object may contain <code>maxKeys</code> property (equal to 1000 by default), it&#39;ll\nbe used to limit processed keys. Set it to 0 to remove key count limitation.</p>\n<p>Options object may contain <code>decodeURIComponent</code> property (<code>querystring.unescape</code> by default),\nit can be used to decode a <code>non-utf8</code> encoding string if necessary.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">querystring.parse(&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39;)\n// returns { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }\n\n// Suppose gbkDecodeURIComponent function already exists,\n// it can decode `gbk` encoding string\nquerystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null,\n  { decodeURIComponent: gbkDecodeURIComponent })\n// returns { w: &#39;ä¸­æ–‡&#39;, foo: &#39;bar&#39; }\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "sep",
                  "optional": true
                },
                {
                  "name": "eq",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "querystring.stringify(obj[, sep][, eq][, options])",
          "type": "method",
          "name": "stringify",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Serialize an object to a query string.\nOptionally override the default separator (<code>&#39;&amp;&#39;</code>) and assignment (<code>&#39;=&#39;</code>)\ncharacters.</p>\n<p>Options object may contain <code>encodeURIComponent</code> property (<code>querystring.escape</code> by default),\nit can be used to encode string with <code>non-utf8</code> encoding if necessary.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">querystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; })\n// returns &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;\n\nquerystring.stringify({foo: &#39;bar&#39;, baz: &#39;qux&#39;}, &#39;;&#39;, &#39;:&#39;)\n// returns &#39;foo:bar;baz:qux&#39;\n\n// Suppose gbkEncodeURIComponent function already exists,\n// it can encode string with `gbk` encoding\nquerystring.stringify({ w: &#39;ä¸­æ–‡&#39;, foo: &#39;bar&#39; }, null, null,\n  { encodeURIComponent: gbkEncodeURIComponent })\n// returns &#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                },
                {
                  "name": "sep",
                  "optional": true
                },
                {
                  "name": "eq",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "querystring"
    },
    {
      "textRaw": "Readline",
      "name": "readline",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>To use this module, do <code>require(&#39;readline&#39;)</code>. Readline allows reading of a\nstream (such as [<code>process.stdin</code>][]) on a line-by-line basis.</p>\n<p>Note that once you&#39;ve invoked this module, your Node.js program will not\nterminate until you&#39;ve closed the interface. Here&#39;s how to allow your\nprogram to gracefully exit:</p>\n<pre><code class=\"lang-js\">const readline = require(&#39;readline&#39;);\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.question(&#39;What do you think of Node.js? &#39;, (answer) =&gt; {\n  // TODO: Log the answer in a database\n  console.log(&#39;Thank you for your valuable feedback:&#39;, answer);\n\n  rl.close();\n});\n</code></pre>\n",
      "classes": [
        {
          "textRaw": "Class: Interface",
          "type": "class",
          "name": "Interface",
          "meta": {
            "added": [
              "v0.1.104"
            ]
          },
          "desc": "<p>The class that represents a readline interface with an input and output\nstream.</p>\n",
          "methods": [
            {
              "textRaw": "rl.close()",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.98"
                ]
              },
              "desc": "<p>Closes the <code>Interface</code> instance, relinquishing control on the <code>input</code> and\n<code>output</code> streams. The <code>&#39;close&#39;</code> event will also be emitted.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "rl.pause()",
              "type": "method",
              "name": "pause",
              "meta": {
                "added": [
                  "v0.3.4"
                ]
              },
              "desc": "<p>Pauses the readline <code>input</code> stream, allowing it to be resumed later if needed.</p>\n<p>Note that this doesn&#39;t immediately pause the stream of events. Several events may\nbe emitted after calling <code>pause</code>, including <code>line</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "rl.prompt([preserveCursor])",
              "type": "method",
              "name": "prompt",
              "meta": {
                "added": [
                  "v0.1.98"
                ]
              },
              "desc": "<p>Readies readline for input from the user, putting the current <code>setPrompt</code>\noptions on a new line, giving the user a new spot to write. Set <code>preserveCursor</code>\nto <code>true</code> to prevent the cursor placement being reset to <code>0</code>.</p>\n<p>This will also resume the <code>input</code> stream used with <code>createInterface</code> if it has\nbeen paused.</p>\n<p>If <code>output</code> is set to <code>null</code> or <code>undefined</code> when calling <code>createInterface</code>, the\nprompt is not written.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "preserveCursor",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "rl.question(query, callback)",
              "type": "method",
              "name": "question",
              "meta": {
                "added": [
                  "v0.3.3"
                ]
              },
              "desc": "<p>Prepends the prompt with <code>query</code> and invokes <code>callback</code> with the user&#39;s\nresponse. Displays the query to the user, and then invokes <code>callback</code>\nwith the user&#39;s response after it has been typed.</p>\n<p>This will also resume the <code>input</code> stream used with <code>createInterface</code> if\nit has been paused.</p>\n<p>If <code>output</code> is set to <code>null</code> or <code>undefined</code> when calling <code>createInterface</code>,\nnothing is displayed.</p>\n<p>Example usage:</p>\n<pre><code class=\"lang-js\">rl.question(&#39;What is your favorite food?&#39;, (answer) =&gt; {\n  console.log(`Oh, so your favorite food is ${answer}`);\n});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "query"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "rl.resume()",
              "type": "method",
              "name": "resume",
              "meta": {
                "added": [
                  "v0.3.4"
                ]
              },
              "desc": "<p>Resumes the readline <code>input</code> stream.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "rl.setPrompt(prompt)",
              "type": "method",
              "name": "setPrompt",
              "meta": {
                "added": [
                  "v0.1.98"
                ]
              },
              "desc": "<p>Sets the prompt, for example when you run <code>node</code> on the command line, you see\n<code>&gt;</code>, which is Node.js&#39;s prompt.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prompt"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "rl.write(data[, key])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.98"
                ]
              },
              "desc": "<p>Writes <code>data</code> to <code>output</code> stream, unless <code>output</code> is set to <code>null</code> or\n<code>undefined</code> when calling <code>createInterface</code>. <code>key</code> is an object literal to\nrepresent a key sequence; available if the terminal is a TTY.</p>\n<p>This will also resume the <code>input</code> stream if it has been paused.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">rl.write(&#39;Delete me!&#39;);\n// Simulate ctrl+u to delete the line written previously\nrl.write(null, {ctrl: true, name: &#39;u&#39;});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "key",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Events",
          "name": "events",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.98"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p>Emitted when <code>close()</code> is called.</p>\n<p>Also emitted when the <code>input</code> stream receives its <code>&#39;end&#39;</code> event. The <code>Interface</code>\ninstance should be considered &quot;finished&quot; once this is emitted. For example, when\nthe <code>input</code> stream receives <code>^D</code>, respectively known as <code>EOT</code>.</p>\n<p>This event is also called if there is no <code>SIGINT</code> event listener present when\nthe <code>input</code> stream receives a <code>^C</code>, respectively known as <code>SIGINT</code>.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'line'",
              "type": "event",
              "name": "line",
              "meta": {
                "added": [
                  "v0.1.98"
                ]
              },
              "desc": "<p><code>function (line) {}</code></p>\n<p>Emitted whenever the <code>input</code> stream receives an end of line (<code>\\n</code>, <code>\\r</code>, or\n<code>\\r\\n</code>), usually received when the user hits enter, or return. This is a good\nhook to listen for user input.</p>\n<p>Example of listening for <code>&#39;line&#39;</code>:</p>\n<pre><code class=\"lang-js\">rl.on(&#39;line&#39;, (cmd) =&gt; {\n  console.log(`You just typed: ${cmd}`);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pause'",
              "type": "event",
              "name": "pause",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p>Emitted whenever the <code>input</code> stream is paused.</p>\n<p>Also emitted whenever the <code>input</code> stream is not paused and receives the\n<code>SIGCONT</code> event. (See events <code>SIGTSTP</code> and <code>SIGCONT</code>)</p>\n<p>Example of listening for <code>&#39;pause&#39;</code>:</p>\n<pre><code class=\"lang-js\">rl.on(&#39;pause&#39;, () =&gt; {\n  console.log(&#39;Readline paused.&#39;);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'resume'",
              "type": "event",
              "name": "resume",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p>Emitted whenever the <code>input</code> stream is resumed.</p>\n<p>Example of listening for <code>&#39;resume&#39;</code>:</p>\n<pre><code class=\"lang-js\">rl.on(&#39;resume&#39;, () =&gt; {\n  console.log(&#39;Readline resumed.&#39;);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'SIGCONT'",
              "type": "event",
              "name": "SIGCONT",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p><strong>This does not work on Windows.</strong></p>\n<p>Emitted whenever the <code>input</code> stream is sent to the background with <code>^Z</code>,\nrespectively known as <code>SIGTSTP</code>, and then continued with <code>fg(1)</code>. This event\nonly emits if the stream was not paused before sending the program to the\nbackground.</p>\n<p>Example of listening for <code>SIGCONT</code>:</p>\n<pre><code class=\"lang-js\">rl.on(&#39;SIGCONT&#39;, () =&gt; {\n  // `prompt` will automatically resume the stream\n  rl.prompt();\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'SIGINT'",
              "type": "event",
              "name": "SIGINT",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p>Emitted whenever the <code>input</code> stream receives a <code>^C</code>, respectively known as\n<code>SIGINT</code>. If there is no <code>SIGINT</code> event listener present when the <code>input</code>\nstream receives a <code>SIGINT</code>, <code>pause</code> will be triggered.</p>\n<p>Example of listening for <code>SIGINT</code>:</p>\n<pre><code class=\"lang-js\">rl.on(&#39;SIGINT&#39;, () =&gt; {\n  rl.question(&#39;Are you sure you want to exit?&#39;, (answer) =&gt; {\n    if (answer.match(/^y(es)?$/i)) rl.pause();\n  });\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'SIGTSTP'",
              "type": "event",
              "name": "SIGTSTP",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p><strong>This does not work on Windows.</strong></p>\n<p>Emitted whenever the <code>input</code> stream receives a <code>^Z</code>, respectively known as\n<code>SIGTSTP</code>. If there is no <code>SIGTSTP</code> event listener present when the <code>input</code>\nstream receives a <code>SIGTSTP</code>, the program will be sent to the background.</p>\n<p>When the program is resumed with <code>fg</code>, the <code>&#39;pause&#39;</code> and <code>SIGCONT</code> events will be\nemitted. You can use either to resume the stream.</p>\n<p>The <code>&#39;pause&#39;</code> and <code>SIGCONT</code> events will not be triggered if the stream was paused\nbefore the program was sent to the background.</p>\n<p>Example of listening for <code>SIGTSTP</code>:</p>\n<pre><code class=\"lang-js\">rl.on(&#39;SIGTSTP&#39;, () =&gt; {\n  // This will override SIGTSTP and prevent the program from going to the\n  // background.\n  console.log(&#39;Caught SIGTSTP.&#39;);\n});\n</code></pre>\n<h2>Example: Tiny CLI</h2>\n<p>Here&#39;s an example of how to use all these together to craft a tiny command\nline interface:</p>\n<pre><code class=\"lang-js\">const readline = require(&#39;readline&#39;);\nconst rl = readline.createInterface(process.stdin, process.stdout);\n\nrl.setPrompt(&#39;OHAI&gt; &#39;);\nrl.prompt();\n\nrl.on(&#39;line&#39;, (line) =&gt; {\n  switch(line.trim()) {\n    case &#39;hello&#39;:\n      console.log(&#39;world!&#39;);\n      break;\n    default:\n      console.log(&#39;Say what? I might have heard `&#39; + line.trim() + &#39;`&#39;);\n      break;\n  }\n  rl.prompt();\n}).on(&#39;close&#39;, () =&gt; {\n  console.log(&#39;Have a great day!&#39;);\n  process.exit(0);\n});\n</code></pre>\n<h2>Example: Read File Stream Line-by-Line</h2>\n<p>A common case for <code>readline</code>&#39;s <code>input</code> option is to pass a filesystem readable\nstream to it. This is how one could craft line-by-line parsing of a file:</p>\n<pre><code class=\"lang-js\">const readline = require(&#39;readline&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst rl = readline.createInterface({\n  input: fs.createReadStream(&#39;sample.txt&#39;)\n});\n\nrl.on(&#39;line&#39;, (line) =&gt; {\n  console.log(&#39;Line from file:&#39;, line);\n});\n</code></pre>\n",
              "params": []
            }
          ],
          "type": "module",
          "displayName": "Events"
        }
      ],
      "methods": [
        {
          "textRaw": "readline.clearLine(stream, dir)",
          "type": "method",
          "name": "clearLine",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>Clears current line of given TTY stream in a specified direction.\n<code>dir</code> should have one of following values:</p>\n<ul>\n<li><code>-1</code> - to the left from cursor</li>\n<li><code>1</code> - to the right from cursor</li>\n<li><code>0</code> - the entire line</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "dir"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.clearScreenDown(stream)",
          "type": "method",
          "name": "clearScreenDown",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>Clears the screen from the current position of the cursor down.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.createInterface(options)",
          "type": "method",
          "name": "createInterface",
          "meta": {
            "added": [
              "v0.1.98"
            ]
          },
          "desc": "<p>Creates a readline <code>Interface</code> instance. Accepts an <code>options</code> Object that takes\nthe following values:</p>\n<ul>\n<li><p><code>input</code> - the readable stream to listen to (Required).</p>\n</li>\n<li><p><code>output</code> - the writable stream to write readline data to (Optional).</p>\n</li>\n<li><p><code>completer</code> - an optional function that is used for Tab autocompletion. See\nbelow for an example of using this.</p>\n</li>\n<li><p><code>terminal</code> - pass <code>true</code> if the <code>input</code> and <code>output</code> streams should be\ntreated like a TTY, and have ANSI/VT100 escape codes written to it.\nDefaults to checking <code>isTTY</code> on the <code>output</code> stream upon instantiation.</p>\n</li>\n<li><p><code>historySize</code> - maximum number of history lines retained. Defaults to <code>30</code>.</p>\n</li>\n</ul>\n<p>The <code>completer</code> function is given the current line entered by the user, and\nis supposed to return an Array with 2 entries:</p>\n<ol>\n<li><p>An Array with matching entries for the completion.</p>\n</li>\n<li><p>The substring that was used for the matching.</p>\n</li>\n</ol>\n<p>Which ends up looking something like:\n<code>[[substr1, substr2, ...], originalsubstring]</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">function completer(line) {\n  var completions = &#39;.help .error .exit .quit .q&#39;.split(&#39; &#39;)\n  var hits = completions.filter((c) =&gt; { return c.indexOf(line) == 0 })\n  // show all completions if none found\n  return [hits.length ? hits : completions, line]\n}\n</code></pre>\n<p>Also <code>completer</code> can be run in async mode if it accepts two arguments:</p>\n<pre><code class=\"lang-js\">function completer(linePartial, callback) {\n  callback(null, [[&#39;123&#39;], linePartial]);\n}\n</code></pre>\n<p><code>createInterface</code> is commonly used with [<code>process.stdin</code>][] and\n[<code>process.stdout</code>][] in order to accept user input:</p>\n<pre><code class=\"lang-js\">const readline = require(&#39;readline&#39;);\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n</code></pre>\n<p>Once you have a readline instance, you most commonly listen for the\n<code>&#39;line&#39;</code> event.</p>\n<p>If <code>terminal</code> is <code>true</code> for this instance then the <code>output</code> stream will get\nthe best compatibility if it defines an <code>output.columns</code> property, and fires\na <code>&#39;resize&#39;</code> event on the <code>output</code> if/when the columns ever change\n([<code>process.stdout</code>][] does this automatically when it is a TTY).</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.cursorTo(stream, x, y)",
          "type": "method",
          "name": "cursorTo",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>Move cursor to the specified position in a given TTY stream.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.emitKeypressEvents(stream[, interface])",
          "type": "method",
          "name": "emitKeypressEvents",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>Causes <code>stream</code> to begin emitting <code>&#39;keypress&#39;</code> events corresponding to its\ninput.\nOptionally, <code>interface</code> specifies a <code>readline.Interface</code> instance for which\nautocompletion is disabled when copy-pasted input is detected.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "interface",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.moveCursor(stream, dx, dy)",
          "type": "method",
          "name": "moveCursor",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>Move cursor relative to it&#39;s current position in a given TTY stream.</p>\n<!-- [end-include:readline.md] -->\n<!-- [start-include:repl.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "dx"
                },
                {
                  "name": "dy"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Readline"
    },
    {
      "textRaw": "REPL",
      "name": "repl",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and\neasily includable in other programs. The REPL provides a way to interactively\nrun JavaScript and see the results.  It can be used for debugging, testing, or\njust trying things out.</p>\n<p>By executing <code>node</code> without any arguments from the command-line you will be\ndropped into the REPL. It has simplistic emacs line-editing.</p>\n<pre><code>$ node\nType &#39;.help&#39; for options.\n&gt; a = [1, 2, 3];\n[ 1, 2, 3 ]\n&gt; a.forEach((v) =&gt; {\n...   console.log(v);\n...   });\n1\n2\n3\n</code></pre><p>For advanced line-editors, start Node.js with the environmental variable\n<code>NODE_NO_READLINE=1</code>. This will start the main and debugger REPL in canonical\nterminal settings which will allow you to use with <code>rlwrap</code>.</p>\n<p>For example, you could add this to your bashrc file:</p>\n<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;\n</code></pre>",
      "modules": [
        {
          "textRaw": "Environment Variable Options",
          "name": "environment_variable_options",
          "desc": "<p>The built-in repl (invoked by running <code>node</code> or <code>node -i</code>) may be controlled\nvia the following environment variables:</p>\n<ul>\n<li><code>NODE_REPL_HISTORY</code> - When a valid path is given, persistent REPL history\nwill be saved to the specified file rather than <code>.node_repl_history</code> in the\nuser&#39;s home directory. Setting this value to <code>&quot;&quot;</code> will disable persistent\nREPL history. Whitespace will be trimmed from the value.</li>\n<li><code>NODE_REPL_HISTORY_SIZE</code> - Defaults to <code>1000</code>. Controls how many lines of\nhistory will be persisted if history is available. Must be a positive number.</li>\n<li><code>NODE_REPL_MODE</code> - May be any of <code>sloppy</code>, <code>strict</code>, or <code>magic</code>. Defaults\nto <code>magic</code>, which will automatically run &quot;strict mode only&quot; statements in\nstrict mode.</li>\n</ul>\n",
          "type": "module",
          "displayName": "Environment Variable Options"
        },
        {
          "textRaw": "Persistent History",
          "name": "persistent_history",
          "desc": "<p>By default, the REPL will persist history between <code>node</code> REPL sessions by saving\nto a <code>.node_repl_history</code> file in the user&#39;s home directory. This can be\ndisabled by setting the environment variable <code>NODE_REPL_HISTORY=&quot;&quot;</code>.</p>\n",
          "modules": [
            {
              "textRaw": "NODE_REPL_HISTORY_FILE",
              "name": "node_repl_history_file",
              "stability": 0,
              "stabilityText": "Deprecated: Use `NODE_REPL_HISTORY` instead.",
              "desc": "<p>Previously in Node.js/io.js v2.x, REPL history was controlled by using a\n<code>NODE_REPL_HISTORY_FILE</code> environment variable, and the history was saved in JSON\nformat. This variable has now been deprecated, and your REPL history will\nautomatically be converted to using plain text. The new file will be saved to\neither your home directory, or a directory defined by the <code>NODE_REPL_HISTORY</code>\nvariable, as documented <a href=\"#repl_environment_variable_options\">here</a>.</p>\n",
              "type": "module",
              "displayName": "NODE_REPL_HISTORY_FILE"
            }
          ],
          "type": "module",
          "displayName": "Persistent History"
        }
      ],
      "miscs": [
        {
          "textRaw": "REPL Features",
          "name": "REPL Features",
          "type": "misc",
          "desc": "<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.\nTab completion is supported for both global and local variables.</p>\n<p>Core modules will be loaded on-demand into the environment. For example,\naccessing <code>fs</code> will <code>require()</code> the <code>fs</code> module as <code>global.fs</code>.</p>\n<p>The special variable <code>_</code> (underscore) contains the result of the last expression.</p>\n<pre><code>&gt; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]\n[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]\n&gt; _.length\n3\n&gt; _ += 1\n4\n</code></pre><p>The REPL provides access to any variables in the global scope. You can expose\na variable to the REPL explicitly by assigning it to the <code>context</code> object\nassociated with each <code>REPLServer</code>.  For example:</p>\n<pre><code class=\"lang-js\">// repl_test.js\nconst repl = require(&#39;repl&#39;);\nvar msg = &#39;message&#39;;\n\nrepl.start(&#39;&gt; &#39;).context.m = msg;\n</code></pre>\n<p>Things in the <code>context</code> object appear as local within the REPL:</p>\n<pre><code>$ node repl_test.js\n&gt; m\n&#39;message&#39;\n</code></pre><p>There are a few special REPL commands:</p>\n<ul>\n<li><code>.break</code> - While inputting a multi-line expression, sometimes you get lost\nor just don&#39;t care about completing it. <code>.break</code> will start over.</li>\n<li><code>.clear</code> - Resets the <code>context</code> object to an empty object and clears any\nmulti-line expression.</li>\n<li><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.</li>\n<li><code>.help</code> - Show this list of special commands.</li>\n<li><code>.save</code> - Save the current REPL session to a file<blockquote>\n<p>.save ./file/to/save.js</p>\n</blockquote>\n</li>\n<li><code>.load</code> - Load a file into the current REPL session.<blockquote>\n<p>.load ./file/to/load.js</p>\n</blockquote>\n</li>\n</ul>\n<p>The following key combinations in the REPL have these special effects:</p>\n<ul>\n<li><code>&lt;ctrl&gt;C</code> - Similar to the <code>.break</code> keyword.  Terminates the current\ncommand.  Press twice on a blank line to forcibly exit.</li>\n<li><code>&lt;ctrl&gt;D</code> - Similar to the <code>.exit</code> keyword.</li>\n<li><code>&lt;tab&gt;</code> - Show both global and local(scope) variables</li>\n</ul>\n",
          "miscs": [
            {
              "textRaw": "Customizing Object displays in the REPL",
              "name": "customizing_object_displays_in_the_repl",
              "desc": "<p>The REPL module internally uses\n[<code>util.inspect()</code>][], when printing values. However, <code>util.inspect</code> delegates the\n call to the object&#39;s <code>inspect()</code> function, if it has one. You can read more\n about this delegation [here][].</p>\n<p>For example, if you have defined an <code>inspect()</code> function on an object, like this:</p>\n<pre><code>&gt; var obj = {foo: &#39;this will not show up in the inspect() output&#39;};\nundefined\n&gt; obj.inspect = () =&gt; {\n...   return {bar: &#39;baz&#39;};\n... };\n[Function]\n</code></pre><p>and try to print <code>obj</code> in REPL, it will invoke the custom <code>inspect()</code> function:</p>\n<pre><code>&gt; obj\n{bar: &#39;baz&#39;}\n</code></pre>",
              "type": "misc",
              "displayName": "Customizing Object displays in the REPL"
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: REPLServer",
          "type": "class",
          "name": "REPLServer",
          "meta": {
            "added": [
              "v0.1.91"
            ]
          },
          "desc": "<p>This inherits from [Readline Interface][] with the following events:</p>\n",
          "events": [
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p>Emitted when the user exits the REPL in any of the defined ways. Namely, typing\n<code>.exit</code> at the repl, pressing Ctrl+C twice to signal <code>SIGINT</code>, or pressing Ctrl+D\nto signal <code>&#39;end&#39;</code> on the <code>input</code> stream.</p>\n<p>Example of listening for <code>exit</code>:</p>\n<pre><code class=\"lang-js\">replServer.on(&#39;exit&#39;, () =&gt; {\n  console.log(&#39;Got &quot;exit&quot; event from repl!&#39;);\n  process.exit();\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'reset'",
              "type": "event",
              "name": "reset",
              "meta": {
                "added": [
                  "v0.11.0"
                ]
              },
              "desc": "<p><code>function (context) {}</code></p>\n<p>Emitted when the REPL&#39;s context is reset. This happens when you type <code>.clear</code>.\nIf you start the repl with <code>{ useGlobal: true }</code> then this event will never\nbe emitted.</p>\n<p>Example of listening for <code>reset</code>:</p>\n<pre><code class=\"lang-js\">// Extend the initial repl context.\nvar replServer = repl.start({ options ... });\nsomeExtension.extend(r.context);\n\n// When a new context is created extend it as well.\nreplServer.on(&#39;reset&#39;, (context) =&gt; {\n  console.log(&#39;repl has a new context&#39;);\n  someExtension.extend(context);\n});\n</code></pre>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "replServer.defineCommand(keyword, cmd)",
              "type": "method",
              "name": "defineCommand",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`keyword` {String} ",
                      "name": "keyword",
                      "type": "String"
                    },
                    {
                      "textRaw": "`cmd` {Object|Function} ",
                      "name": "cmd",
                      "type": "Object|Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "keyword"
                    },
                    {
                      "name": "cmd"
                    }
                  ]
                }
              ],
              "desc": "<p>Makes a command available in the REPL. The command is invoked by typing a <code>.</code>\nfollowed by the keyword. The <code>cmd</code> is an object with the following values:</p>\n<ul>\n<li><code>help</code> - help text to be displayed when <code>.help</code> is entered (Optional).</li>\n<li><code>action</code> - a function to execute, potentially taking in a string argument,\nwhen the command is invoked, bound to the REPLServer instance (Required).</li>\n</ul>\n<p>If a function is provided instead of an object for <code>cmd</code>, it is treated as the\n<code>action</code>.</p>\n<p>Example of defining a command:</p>\n<pre><code class=\"lang-js\">// repl_test.js\nconst repl = require(&#39;repl&#39;);\n\nvar replServer = repl.start();\nreplServer.defineCommand(&#39;sayhello&#39;, {\n  help: &#39;Say hello&#39;,\n  action: function(name) {\n    this.write(`Hello, ${name}!\\n`);\n    this.displayPrompt();\n  }\n});\n</code></pre>\n<p>Example of invoking that command from the REPL:</p>\n<pre><code>&gt; .sayhello Node.js User\nHello, Node.js User!\n</code></pre>"
            },
            {
              "textRaw": "replServer.displayPrompt([preserveCursor])",
              "type": "method",
              "name": "displayPrompt",
              "meta": {
                "added": [
                  "v0.1.91"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`preserveCursor` {Boolean} ",
                      "name": "preserveCursor",
                      "type": "Boolean",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "preserveCursor",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Like [<code>readline.prompt</code>][] except also adding indents with ellipses when inside\nblocks. The <code>preserveCursor</code> argument is passed to [<code>readline.prompt</code>][]. This is\nused primarily with <code>defineCommand</code>. It&#39;s also used internally to render each\nprompt line.</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "repl.start(options)",
          "type": "method",
          "name": "start",
          "desc": "<p>Returns and starts a <code>REPLServer</code> instance, that inherits from\n[Readline Interface][]. Accepts an &quot;options&quot; Object that takes\nthe following values:</p>\n<ul>\n<li><p><code>prompt</code> - the prompt and <code>stream</code> for all I/O. Defaults to <code>&gt;</code>.</p>\n</li>\n<li><p><code>input</code> - the readable stream to listen to. Defaults to <code>process.stdin</code>.</p>\n</li>\n<li><p><code>output</code> - the writable stream to write readline data to. Defaults to\n<code>process.stdout</code>.</p>\n</li>\n<li><p><code>terminal</code> - pass <code>true</code> if the <code>stream</code> should be treated like a TTY, and\nhave ANSI/VT100 escape codes written to it. Defaults to checking <code>isTTY</code>\non the <code>output</code> stream upon instantiation.</p>\n</li>\n<li><p><code>eval</code> - function that will be used to eval each given line. Defaults to\nan async wrapper for <code>eval()</code>. See below for an example of a custom <code>eval</code>.</p>\n</li>\n<li><p><code>useColors</code> - a boolean which specifies whether or not the <code>writer</code> function\nshould output colors. If a different <code>writer</code> function is set then this does\nnothing. Defaults to the repl&#39;s <code>terminal</code> value.</p>\n</li>\n<li><p><code>useGlobal</code> - if set to <code>true</code>, then the repl will use the <code>global</code> object,\ninstead of running scripts in a separate context. Defaults to <code>false</code>.</p>\n</li>\n<li><p><code>ignoreUndefined</code> - if set to <code>true</code>, then the repl will not output the\nreturn value of command if it&#39;s <code>undefined</code>. Defaults to <code>false</code>.</p>\n</li>\n<li><p><code>writer</code> - the function to invoke for each command that gets evaluated which\nreturns the formatting (including coloring) to display. Defaults to\n<code>util.inspect</code>.</p>\n</li>\n<li><p><code>replMode</code> - controls whether the repl runs all commands in strict mode,\ndefault mode, or a hybrid mode (&quot;magic&quot; mode.) Acceptable values are:</p>\n<ul>\n<li><code>repl.REPL_MODE_SLOPPY</code> - run commands in sloppy mode.</li>\n<li><code>repl.REPL_MODE_STRICT</code> - run commands in strict mode. This is equivalent to\nprefacing every repl statement with <code>&#39;use strict&#39;</code>.</li>\n<li><code>repl.REPL_MODE_MAGIC</code> - attempt to run commands in default mode. If they\nfail to parse, re-try in strict mode.</li>\n</ul>\n</li>\n</ul>\n<p>You can use your own <code>eval</code> function if it has following signature:</p>\n<pre><code>function eval(cmd, context, filename, callback) {\n  callback(null, result);\n}\n</code></pre><p>On tab completion, <code>eval</code> will be called with <code>.scope</code> as an input string. It\nis expected to return an array of scope names to be used for the auto-completion.</p>\n<p>Multiple REPLs may be started against the same running instance of Node.js.  Each\nwill share the same global object but will have unique I/O.</p>\n<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst repl = require(&#39;repl&#39;);\nvar connections = 0;\n\nrepl.start({\n  prompt: &#39;Node.js via stdin&gt; &#39;,\n  input: process.stdin,\n  output: process.stdout\n});\n\nnet.createServer((socket) =&gt; {\n  connections += 1;\n  repl.start({\n    prompt: &#39;Node.js via Unix socket&gt; &#39;,\n    input: socket,\n    output: socket\n  }).on(&#39;exit&#39;, () =&gt; {\n    socket.end();\n  })\n}).listen(&#39;/tmp/node-repl-sock&#39;);\n\nnet.createServer((socket) =&gt; {\n  connections += 1;\n  repl.start({\n    prompt: &#39;Node.js via TCP socket&gt; &#39;,\n    input: socket,\n    output: socket\n  }).on(&#39;exit&#39;, () =&gt; {\n    socket.end();\n  });\n}).listen(5001);\n</code></pre>\n<p>Running this program from the command line will start a REPL on stdin.  Other\nREPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful\nfor connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and\nTCP sockets.</p>\n<p>By starting a REPL from a Unix socket-based server instead of stdin, you can\nconnect to a long-running Node.js process without restarting it.</p>\n<p>For an example of running a &quot;full-featured&quot; (<code>terminal</code>) REPL over\na <code>net.Server</code> and <code>net.Socket</code> instance, see: <a href=\"https://gist.github.com/2209310\">https://gist.github.com/2209310</a></p>\n<p>For an example of running a REPL instance over <code>curl(1)</code>,\nsee: <a href=\"https://gist.github.com/2053342\">https://gist.github.com/2053342</a></p>\n<!-- [end-include:repl.md] -->\n<!-- [start-include:stream.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "REPL"
    },
    {
      "textRaw": "Stream",
      "name": "stream",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>A stream is an abstract interface implemented by various objects in\nNode.js. For example a [request to an HTTP server][http-incoming-message] is a\nstream, as is [<code>process.stdout</code>][]. Streams are readable, writable, or both. All\nstreams are instances of [<code>EventEmitter</code>][].</p>\n<p>You can load the Stream base classes by doing <code>require(&#39;stream&#39;)</code>.\nThere are base classes provided for [Readable][] streams, [Writable][]\nstreams, [Duplex][] streams, and [Transform][] streams.</p>\n<p>This document is split up into 3 sections:</p>\n<ol>\n<li>The first section explains the parts of the API that you need to be\naware of to use streams in your programs.</li>\n<li>The second section explains the parts of the API that you need to\nuse if you implement your own custom streams yourself. The API is designed to\nmake this easy for you to do.</li>\n<li>The third section goes into more depth about how streams work,\nincluding some of the internal mechanisms and functions that you\nshould probably not modify unless you definitely know what you are\ndoing.</li>\n</ol>\n",
      "classes": [
        {
          "textRaw": "Class: stream.Duplex",
          "type": "class",
          "name": "stream.Duplex",
          "desc": "<p>Duplex streams are streams that implement both the [Readable][] and\n[Writable][] interfaces.</p>\n<p>Examples of Duplex streams include:</p>\n<ul>\n<li>[TCP sockets][]</li>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n</ul>\n"
        },
        {
          "textRaw": "Class: stream.Readable",
          "type": "class",
          "name": "stream.Readable",
          "desc": "<p>The Readable stream interface is the abstraction for a <em>source</em> of\ndata that you are reading from. In other words, data comes <em>out</em> of a\nReadable stream.</p>\n<p>A Readable stream will not start emitting data until you indicate that\nyou are ready to receive it.</p>\n<p>Readable streams have two &quot;modes&quot;: a <strong>flowing mode</strong> and a <strong>paused\nmode</strong>. When in flowing mode, data is read from the underlying system\nand provided to your program as fast as possible. In paused mode, you\nmust explicitly call [<code>stream.read()</code>][stream-read] to get chunks of data out.\nStreams start out in paused mode.</p>\n<p><strong>Note</strong>: If no data event handlers are attached, and there are no\n[<code>stream.pipe()</code>][] destinations, and the stream is switched into flowing\nmode, then data will be lost.</p>\n<p>You can switch to flowing mode by doing any of the following:</p>\n<ul>\n<li>Adding a [<code>&#39;data&#39;</code>][] event handler to listen for data.</li>\n<li>Calling the [<code>stream.resume()</code>][stream-resume] method to explicitly open the\nflow.</li>\n<li>Calling the [<code>stream.pipe()</code>][] method to send the data to a [Writable][].</li>\n</ul>\n<p>You can switch back to paused mode by doing either of the following:</p>\n<ul>\n<li>If there are no pipe destinations, by calling the\n[<code>stream.pause()</code>][stream-pause] method.</li>\n<li>If there are pipe destinations, by removing any [<code>&#39;data&#39;</code>][] event\nhandlers, and removing all pipe destinations by calling the\n[<code>stream.unpipe()</code>][] method.</li>\n</ul>\n<p>Note that, for backwards compatibility reasons, removing [<code>&#39;data&#39;</code>][]\nevent handlers will <strong>not</strong> automatically pause the stream. Also, if\nthere are piped destinations, then calling [<code>stream.pause()</code>][stream-pause] will\nnot guarantee that the stream will <em>remain</em> paused once those\ndestinations drain and ask for more data.</p>\n<p>Examples of readable streams include:</p>\n<ul>\n<li>[HTTP responses, on the client][http-incoming-message]</li>\n<li>[HTTP requests, on the server][http-incoming-message]</li>\n<li>[fs read streams][]</li>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n<li>[TCP sockets][]</li>\n<li>[child process stdout and stderr][]</li>\n<li>[<code>process.stdin</code>][]</li>\n</ul>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p>Emitted when the stream and any of its underlying resources (a file\ndescriptor, for example) have been closed. The event indicates that\nno more events will be emitted, and no further computation will occur.</p>\n<p>Not all streams will emit the <code>&#39;close&#39;</code> event as the <code>&#39;close&#39;</code> event is\noptional.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "params": [],
              "desc": "<p>Attaching a <code>&#39;data&#39;</code> event listener to a stream that has not been\nexplicitly paused will switch the stream into flowing mode. Data will\nthen be passed as soon as it is available.</p>\n<p>If you just want to get all the data out of the stream as fast as\npossible, this is the best way to do so.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n});\n</code></pre>\n"
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<p>This event fires when there will be no more data to read.</p>\n<p>Note that the <code>&#39;end&#39;</code> event <strong>will not fire</strong> unless the data is\ncompletely consumed. This can be done by switching into flowing mode,\nor by calling [<code>stream.read()</code>][stream-read] repeatedly until you get to the\nend.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n});\nreadable.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;there will be no more data.&#39;);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>Emitted if there was an error receiving data.</p>\n"
            },
            {
              "textRaw": "Event: 'readable'",
              "type": "event",
              "name": "readable",
              "desc": "<p>When a chunk of data can be read from the stream, it will emit a\n<code>&#39;readable&#39;</code> event.</p>\n<p>In some cases, listening for a <code>&#39;readable&#39;</code> event will cause some data\nto be read into the internal buffer from the underlying system, if it\nhadn&#39;t already.</p>\n<pre><code class=\"lang-javascript\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, () =&gt; {\n  // there is some data to read now\n});\n</code></pre>\n<p>Once the internal buffer is drained, a <code>&#39;readable&#39;</code> event will fire\nagain when more data is available.</p>\n<p>The <code>&#39;readable&#39;</code> event is not emitted in the &quot;flowing&quot; mode with the\nsole exception of the last one, on end-of-stream.</p>\n<p>The <code>&#39;readable&#39;</code> event indicates that the stream has new information:\neither new data is available or the end of the stream has been reached.\nIn the former case, [<code>stream.read()</code>][stream-read] will return that data. In the\nlatter case, [<code>stream.read()</code>][stream-read] will return null. For instance, in\nthe following example, <code>foo.txt</code> is an empty file:</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\nvar rr = fs.createReadStream(&#39;foo.txt&#39;);\nrr.on(&#39;readable&#39;, () =&gt; {\n  console.log(&#39;readable:&#39;, rr.read());\n});\nrr.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;end&#39;);\n});\n</code></pre>\n<p>The output of running this script is:</p>\n<pre><code>$ node test.js\nreadable: null\nend\n</code></pre>",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "readable.isPaused()",
              "type": "method",
              "name": "isPaused",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>This method returns whether or not the <code>readable</code> has been <strong>explicitly</strong>\npaused by client code (using [<code>stream.pause()</code>][stream-pause] without a\ncorresponding [<code>stream.resume()</code>][stream-resume]).</p>\n<pre><code class=\"lang-js\">var readable = new stream.Readable\n\nreadable.isPaused() // === false\nreadable.pause()\nreadable.isPaused() // === true\nreadable.resume()\nreadable.isPaused() // === false\n</code></pre>\n"
            },
            {
              "textRaw": "readable.pause()",
              "type": "method",
              "name": "pause",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: `this` ",
                    "name": "return",
                    "desc": "`this`"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>This method will cause a stream in flowing mode to stop emitting\n[<code>&#39;data&#39;</code>][] events, switching out of flowing mode. Any data that becomes\navailable will remain in the internal buffer.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  readable.pause();\n  console.log(&#39;there will be no more data for 1 second&#39;);\n  setTimeout(() =&gt; {\n    console.log(&#39;now data will start flowing again&#39;);\n    readable.resume();\n  }, 1000);\n});\n</code></pre>\n"
            },
            {
              "textRaw": "readable.pipe(destination[, options])",
              "type": "method",
              "name": "pipe",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`destination` {stream.Writable} The destination for writing data ",
                      "name": "destination",
                      "type": "stream.Writable",
                      "desc": "The destination for writing data"
                    },
                    {
                      "textRaw": "`options` {Object} Pipe options ",
                      "options": [
                        {
                          "textRaw": "`end` {Boolean} End the writer when the reader ends. Default = `true` ",
                          "name": "end",
                          "type": "Boolean",
                          "desc": "End the writer when the reader ends. Default = `true`"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "Pipe options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "destination"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>This method pulls all the data out of a readable stream, and writes it\nto the supplied destination, automatically managing the flow so that\nthe destination is not overwhelmed by a fast readable stream.</p>\n<p>Multiple destinations can be piped to safely.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;\nreadable.pipe(writable);\n</code></pre>\n<p>This function returns the destination stream, so you can set up pipe\nchains like so:</p>\n<pre><code class=\"lang-js\">var r = fs.createReadStream(&#39;file.txt&#39;);\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream(&#39;file.txt.gz&#39;);\nr.pipe(z).pipe(w);\n</code></pre>\n<p>For example, emulating the Unix <code>cat</code> command:</p>\n<pre><code class=\"lang-js\">process.stdin.pipe(process.stdout);\n</code></pre>\n<p>By default [<code>stream.end()</code>][stream-end] is called on the destination when the\nsource stream emits [<code>&#39;end&#39;</code>][], so that <code>destination</code> is no longer writable.\nPass <code>{ end: false }</code> as <code>options</code> to keep the destination stream open.</p>\n<p>This keeps <code>writer</code> open so that &quot;Goodbye&quot; can be written at the\nend.</p>\n<pre><code class=\"lang-js\">reader.pipe(writer, { end: false });\nreader.on(&#39;end&#39;, () =&gt; {\n  writer.end(&#39;Goodbye\\n&#39;);\n});\n</code></pre>\n<p>Note that [<code>process.stderr</code>][] and [<code>process.stdout</code>][] are never closed until\nthe process exits, regardless of the specified options.</p>\n"
            },
            {
              "textRaw": "readable.read([size])",
              "type": "method",
              "name": "read",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return {String|Buffer|Null} ",
                    "name": "return",
                    "type": "String|Buffer|Null"
                  },
                  "params": [
                    {
                      "textRaw": "`size` {Number} Optional argument to specify how much data to read. ",
                      "name": "size",
                      "type": "Number",
                      "desc": "Optional argument to specify how much data to read.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>read()</code> method pulls some data out of the internal buffer and\nreturns it. If there is no data available, then it will return\n<code>null</code>.</p>\n<p>If you pass in a <code>size</code> argument, then it will return that many\nbytes. If <code>size</code> bytes are not available, then it will return <code>null</code>,\nunless we&#39;ve ended, in which case it will return the data remaining\nin the buffer.</p>\n<p>If you do not specify a <code>size</code> argument, then it will return all the\ndata in the internal buffer.</p>\n<p>This method should only be called in paused mode. In flowing mode,\nthis method is called automatically until the internal buffer is\ndrained.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, () =&gt; {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  }\n});\n</code></pre>\n<p>If this method returns a data chunk, then it will also trigger the\nemission of a [<code>&#39;data&#39;</code>][] event.</p>\n<p>Note that calling [<code>stream.read([size])</code>][stream-read] after the [<code>&#39;end&#39;</code>][]\nevent has been triggered will return <code>null</code>. No runtime error will be raised.</p>\n"
            },
            {
              "textRaw": "readable.resume()",
              "type": "method",
              "name": "resume",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: `this` ",
                    "name": "return",
                    "desc": "`this`"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>This method will cause the readable stream to resume emitting [<code>&#39;data&#39;</code>][]\nevents.</p>\n<p>This method will switch the stream into flowing mode. If you do <em>not</em>\nwant to consume the data from a stream, but you <em>do</em> want to get to\nits [<code>&#39;end&#39;</code>][] event, you can call [<code>stream.resume()</code>][stream-resume] to open\nthe flow of data.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;got to the end, but did not read anything&#39;);\n});\n</code></pre>\n"
            },
            {
              "textRaw": "readable.setEncoding(encoding)",
              "type": "method",
              "name": "setEncoding",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: `this` ",
                    "name": "return",
                    "desc": "`this`"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {String} The encoding to use. ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The encoding to use."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>Call this function to cause the stream to return strings of the specified\nencoding instead of Buffer objects. For example, if you do\n<code>readable.setEncoding(&#39;utf8&#39;)</code>, then the output data will be interpreted as\nUTF-8 data, and returned as strings. If you do <code>readable.setEncoding(&#39;hex&#39;)</code>,\nthen the data will be encoded in hexadecimal string format.</p>\n<p>This properly handles multi-byte characters that would otherwise be\npotentially mangled if you simply pulled the Buffers directly and\ncalled [<code>buf.toString(encoding)</code>][] on them. If you want to read the data\nas strings, always use this method.</p>\n<p>Also you can disable any encoding at all with <code>readable.setEncoding(null)</code>.\nThis approach is very useful if you deal with binary data or with large\nmulti-byte strings spread out over multiple chunks.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.setEncoding(&#39;utf8&#39;);\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  assert.equal(typeof chunk, &#39;string&#39;);\n  console.log(&#39;got %d characters of string data&#39;, chunk.length);\n});\n</code></pre>\n"
            },
            {
              "textRaw": "readable.unpipe([destination])",
              "type": "method",
              "name": "unpipe",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`destination` {stream.Writable} Optional specific stream to unpipe ",
                      "name": "destination",
                      "type": "stream.Writable",
                      "desc": "Optional specific stream to unpipe",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "destination",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>This method will remove the hooks set up for a previous [<code>stream.pipe()</code>][]\ncall.</p>\n<p>If the destination is not specified, then all pipes are removed.</p>\n<p>If the destination is specified, but no pipe is set up for it, then\nthis is a no-op.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;,\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(() =&gt; {\n  console.log(&#39;stop writing to file.txt&#39;);\n  readable.unpipe(writable);\n  console.log(&#39;manually close the file stream&#39;);\n  writable.end();\n}, 1000);\n</code></pre>\n"
            },
            {
              "textRaw": "readable.unshift(chunk)",
              "type": "method",
              "name": "unshift",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {Buffer|String} Chunk of data to unshift onto the read queue ",
                      "name": "chunk",
                      "type": "Buffer|String",
                      "desc": "Chunk of data to unshift onto the read queue"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    }
                  ]
                }
              ],
              "desc": "<p>This is useful in certain cases where a stream is being consumed by a\nparser, which needs to &quot;un-consume&quot; some data that it has\noptimistically pulled out of the source, so that the stream can be\npassed on to some other party.</p>\n<p>Note that <code>stream.unshift(chunk)</code> cannot be called after the [<code>&#39;end&#39;</code>][] event\nhas been triggered; a runtime error will be raised.</p>\n<p>If you find that you must often call <code>stream.unshift(chunk)</code> in your\nprograms, consider implementing a [Transform][] stream instead. (See [API\nfor Stream Implementors][].)</p>\n<pre><code class=\"lang-js\">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nconst StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on(&#39;error&#39;, callback);\n  stream.on(&#39;readable&#39;, onReadable);\n  var decoder = new StringDecoder(&#39;utf8&#39;);\n  var header = &#39;&#39;;\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join(&#39;\\n\\n&#39;);\n        var buf = new Buffer(remaining, &#39;utf8&#39;);\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener(&#39;error&#39;, callback);\n        stream.removeListener(&#39;readable&#39;, onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}\n</code></pre>\n<p>Note that, unlike [<code>stream.push(chunk)</code>][stream-push], <code>stream.unshift(chunk)</code>\nwill not end the reading process by resetting the internal reading state of the\nstream. This can cause unexpected results if <code>unshift()</code> is called during a\nread (i.e. from within a [<code>stream._read()</code>][stream-_read] implementation on a\ncustom stream). Following the call to <code>unshift()</code> with an immediate\n[<code>stream.push(&#39;&#39;)</code>][stream-push] will reset the reading state appropriately,\nhowever it is best to simply avoid calling <code>unshift()</code> while in the process of\nperforming a read.</p>\n"
            },
            {
              "textRaw": "readable.wrap(stream)",
              "type": "method",
              "name": "wrap",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`stream` {Stream} An \"old style\" readable stream ",
                      "name": "stream",
                      "type": "Stream",
                      "desc": "An \"old style\" readable stream"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "stream"
                    }
                  ]
                }
              ],
              "desc": "<p>Versions of Node.js prior to v0.10 had streams that did not implement the\nentire Streams API as it is today. (See [Compatibility][] for\nmore information.)</p>\n<p>If you are using an older Node.js library that emits [<code>&#39;data&#39;</code>][] events and\nhas a [<code>stream.pause()</code>][stream-pause] method that is advisory only, then you\ncan use the <code>wrap()</code> method to create a [Readable][] stream that uses the old\nstream as its data source.</p>\n<p>You will very rarely ever need to call this function, but it exists\nas a convenience for interacting with old Node.js programs and libraries.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">const OldReader = require(&#39;./old-api-module.js&#39;).OldReader;\nconst Readable = require(&#39;stream&#39;).Readable;\nconst oreader = new OldReader;\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on(&#39;readable&#39;, () =&gt; {\n  myReader.read(); // etc.\n});\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: stream.Transform",
          "type": "class",
          "name": "stream.Transform",
          "desc": "<p>Transform streams are [Duplex][] streams where the output is in some way\ncomputed from the input. They implement both the [Readable][] and\n[Writable][] interfaces.</p>\n<p>Examples of Transform streams include:</p>\n<ul>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n</ul>\n"
        },
        {
          "textRaw": "Class: stream.Writable",
          "type": "class",
          "name": "stream.Writable",
          "desc": "<p>The Writable stream interface is an abstraction for a <em>destination</em>\nthat you are writing data <em>to</em>.</p>\n<p>Examples of writable streams include:</p>\n<ul>\n<li>[HTTP requests, on the client][]</li>\n<li>[HTTP responses, on the server][]</li>\n<li>[fs write streams][]</li>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n<li>[TCP sockets][]</li>\n<li>[child process stdin][]</li>\n<li>[<code>process.stdout</code>][], [<code>process.stderr</code>][]</li>\n</ul>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p>Emitted when the stream and any of its underlying resources (a file descriptor,\nfor example) have been closed. The event indicates that no more events will be\nemitted, and no further computation will occur.</p>\n<p>Not all streams will emit the <code>&#39;close&#39;</code> event as the <code>&#39;close&#39;</code> event is\noptional.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<p>If a [<code>stream.write(chunk)</code>][stream-write] call returns <code>false</code>, then the\n<code>&#39;drain&#39;</code> event will indicate when it is appropriate to begin writing more data\nto the stream.</p>\n<pre><code class=\"lang-js\">// Write the data to the supplied writable stream one million times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don&#39;t pass the callback, because we&#39;re not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i &gt; 0 &amp;&amp; ok);\n    if (i &gt; 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once(&#39;drain&#39;, write);\n    }\n  }\n}\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>Emitted if there was an error when writing or piping data.</p>\n"
            },
            {
              "textRaw": "Event: 'finish'",
              "type": "event",
              "name": "finish",
              "desc": "<p>When the [<code>stream.end()</code>][stream-end] method has been called, and all data has\nbeen flushed to the underlying system, this event is emitted.</p>\n<pre><code class=\"lang-javascript\">var writer = getWritableStreamSomehow();\nfor (var i = 0; i &lt; 100; i ++) {\n  writer.write(&#39;hello, #${i}!\\n&#39;);\n}\nwriter.end(&#39;this is the end\\n&#39;);\nwriter.on(&#39;finish&#39;, () =&gt; {\n  console.error(&#39;all writes are now complete.&#39;);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pipe'",
              "type": "event",
              "name": "pipe",
              "params": [],
              "desc": "<p>This is emitted whenever the [<code>stream.pipe()</code>][] method is called on a readable\nstream, adding this writable to its set of destinations.</p>\n<pre><code class=\"lang-js\">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;pipe&#39;, (src) =&gt; {\n  console.error(&#39;something is piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\n</code></pre>\n"
            },
            {
              "textRaw": "Event: 'unpipe'",
              "type": "event",
              "name": "unpipe",
              "params": [],
              "desc": "<p>This is emitted whenever the [<code>stream.unpipe()</code>][] method is called on a\nreadable stream, removing this writable from its set of destinations.</p>\n<pre><code class=\"lang-js\">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;unpipe&#39;, (src) =&gt; {\n  console.error(&#39;something has stopped piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);\n</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "writable.cork()",
              "type": "method",
              "name": "cork",
              "desc": "<p>Forces buffering of all writes.</p>\n<p>Buffered data will be flushed either at [<code>stream.uncork()</code>][] or at\n[<code>stream.end()</code>][stream-end] call.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "writable.end([chunk][, encoding][, callback])",
              "type": "method",
              "name": "end",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {String|Buffer} Optional data to write ",
                      "name": "chunk",
                      "type": "String|Buffer",
                      "desc": "Optional data to write",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} The encoding, if `chunk` is a String ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The encoding, if `chunk` is a String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} Optional callback for when the stream is finished ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Optional callback for when the stream is finished",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Call this method when no more data will be written to the stream. If supplied,\nthe callback is attached as a listener on the [<code>&#39;finish&#39;</code>][] event.</p>\n<p>Calling [<code>stream.write()</code>][stream-write] after calling\n[<code>stream.end()</code>][stream-end] will raise an error.</p>\n<pre><code class=\"lang-js\">// write &#39;hello, &#39; and then end with &#39;world!&#39;\nvar file = fs.createWriteStream(&#39;example.txt&#39;);\nfile.write(&#39;hello, &#39;);\nfile.end(&#39;world!&#39;);\n// writing more now is not allowed!\n</code></pre>\n"
            },
            {
              "textRaw": "writable.setDefaultEncoding(encoding)",
              "type": "method",
              "name": "setDefaultEncoding",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` {String} The new default encoding ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The new default encoding"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the default encoding for a writable stream.</p>\n"
            },
            {
              "textRaw": "writable.uncork()",
              "type": "method",
              "name": "uncork",
              "desc": "<p>Flush all data, buffered since [<code>stream.cork()</code>][] call.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "writable.write(chunk[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Boolean} `true` if the data was handled completely. ",
                    "name": "return",
                    "type": "Boolean",
                    "desc": "`true` if the data was handled completely."
                  },
                  "params": [
                    {
                      "textRaw": "`chunk` {String|Buffer} The data to write ",
                      "name": "chunk",
                      "type": "String|Buffer",
                      "desc": "The data to write"
                    },
                    {
                      "textRaw": "`encoding` {String} The encoding, if `chunk` is a String ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The encoding, if `chunk` is a String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} Callback for when this chunk of data is flushed ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Callback for when this chunk of data is flushed",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>This method writes some data to the underlying system, and calls the\nsupplied callback once the data has been fully handled.  If an error\noccurs, the callback may or may not be called with the error as its\nfirst argument.  To detect write errors, listen for the <code>&#39;error&#39;</code> event.</p>\n<p>The return value indicates if you should continue writing right now.\nIf the data had to be buffered internally, then it will return\n<code>false</code>. Otherwise, it will return <code>true</code>.</p>\n<p>This return value is strictly advisory. You MAY continue to write,\neven if it returns <code>false</code>. However, writes will be buffered in\nmemory, so it is best not to do this excessively. Instead, wait for\nthe [<code>&#39;drain&#39;</code>][] event before writing more data.</p>\n"
            }
          ]
        }
      ],
      "miscs": [
        {
          "textRaw": "API for Stream Consumers",
          "name": "API for Stream Consumers",
          "type": "misc",
          "desc": "<p>Streams can be either [Readable][], [Writable][], or both ([Duplex][]).</p>\n<p>All streams are EventEmitters, but they also have other custom methods\nand properties depending on whether they are Readable, Writable, or\nDuplex.</p>\n<p>If a stream is both Readable and Writable, then it implements all of\nthe methods and events. So, a [Duplex][] or [Transform][] stream is\nfully described by this API, though their implementation may be\nsomewhat different.</p>\n<p>It is not necessary to implement Stream interfaces in order to consume\nstreams in your programs. If you <strong>are</strong> implementing streaming\ninterfaces in your own program, please also refer to\n[API for Stream Implementors][].</p>\n<p>Almost all Node.js programs, no matter how simple, use Streams in some\nway. Here is an example of using Streams in an Node.js program:</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\n\nvar server = http.createServer( (req, res) =&gt; {\n  // req is an http.IncomingMessage, which is a Readable Stream\n  // res is an http.ServerResponse, which is a Writable Stream\n\n  var body = &#39;&#39;;\n  // we want to get the data as utf8 strings\n  // If you don&#39;t set an encoding, then you&#39;ll get Buffer objects\n  req.setEncoding(&#39;utf8&#39;);\n\n  // Readable streams emit &#39;data&#39; events once a listener is added\n  req.on(&#39;data&#39;, (chunk) =&gt; {\n    body += chunk;\n  });\n\n  // the end event tells you that you have entire body\n  req.on(&#39;end&#39;, () =&gt; {\n    try {\n      var data = JSON.parse(body);\n    } catch (er) {\n      // uh oh!  bad json!\n      res.statusCode = 400;\n      return res.end(`error: ${er.message}`);\n    }\n\n    // write back something interesting to the user:\n    res.write(typeof data);\n    res.end();\n  });\n});\n\nserver.listen(1337);\n\n// $ curl localhost:1337 -d &#39;{}&#39;\n// object\n// $ curl localhost:1337 -d &#39;&quot;foo&quot;&#39;\n// string\n// $ curl localhost:1337 -d &#39;not json&#39;\n// error: Unexpected token o\n</code></pre>\n",
          "classes": [
            {
              "textRaw": "Class: stream.Duplex",
              "type": "class",
              "name": "stream.Duplex",
              "desc": "<p>Duplex streams are streams that implement both the [Readable][] and\n[Writable][] interfaces.</p>\n<p>Examples of Duplex streams include:</p>\n<ul>\n<li>[TCP sockets][]</li>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n</ul>\n"
            },
            {
              "textRaw": "Class: stream.Readable",
              "type": "class",
              "name": "stream.Readable",
              "desc": "<p>The Readable stream interface is the abstraction for a <em>source</em> of\ndata that you are reading from. In other words, data comes <em>out</em> of a\nReadable stream.</p>\n<p>A Readable stream will not start emitting data until you indicate that\nyou are ready to receive it.</p>\n<p>Readable streams have two &quot;modes&quot;: a <strong>flowing mode</strong> and a <strong>paused\nmode</strong>. When in flowing mode, data is read from the underlying system\nand provided to your program as fast as possible. In paused mode, you\nmust explicitly call [<code>stream.read()</code>][stream-read] to get chunks of data out.\nStreams start out in paused mode.</p>\n<p><strong>Note</strong>: If no data event handlers are attached, and there are no\n[<code>stream.pipe()</code>][] destinations, and the stream is switched into flowing\nmode, then data will be lost.</p>\n<p>You can switch to flowing mode by doing any of the following:</p>\n<ul>\n<li>Adding a [<code>&#39;data&#39;</code>][] event handler to listen for data.</li>\n<li>Calling the [<code>stream.resume()</code>][stream-resume] method to explicitly open the\nflow.</li>\n<li>Calling the [<code>stream.pipe()</code>][] method to send the data to a [Writable][].</li>\n</ul>\n<p>You can switch back to paused mode by doing either of the following:</p>\n<ul>\n<li>If there are no pipe destinations, by calling the\n[<code>stream.pause()</code>][stream-pause] method.</li>\n<li>If there are pipe destinations, by removing any [<code>&#39;data&#39;</code>][] event\nhandlers, and removing all pipe destinations by calling the\n[<code>stream.unpipe()</code>][] method.</li>\n</ul>\n<p>Note that, for backwards compatibility reasons, removing [<code>&#39;data&#39;</code>][]\nevent handlers will <strong>not</strong> automatically pause the stream. Also, if\nthere are piped destinations, then calling [<code>stream.pause()</code>][stream-pause] will\nnot guarantee that the stream will <em>remain</em> paused once those\ndestinations drain and ask for more data.</p>\n<p>Examples of readable streams include:</p>\n<ul>\n<li>[HTTP responses, on the client][http-incoming-message]</li>\n<li>[HTTP requests, on the server][http-incoming-message]</li>\n<li>[fs read streams][]</li>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n<li>[TCP sockets][]</li>\n<li>[child process stdout and stderr][]</li>\n<li>[<code>process.stdin</code>][]</li>\n</ul>\n",
              "events": [
                {
                  "textRaw": "Event: 'close'",
                  "type": "event",
                  "name": "close",
                  "desc": "<p>Emitted when the stream and any of its underlying resources (a file\ndescriptor, for example) have been closed. The event indicates that\nno more events will be emitted, and no further computation will occur.</p>\n<p>Not all streams will emit the <code>&#39;close&#39;</code> event as the <code>&#39;close&#39;</code> event is\noptional.</p>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'data'",
                  "type": "event",
                  "name": "data",
                  "params": [],
                  "desc": "<p>Attaching a <code>&#39;data&#39;</code> event listener to a stream that has not been\nexplicitly paused will switch the stream into flowing mode. Data will\nthen be passed as soon as it is available.</p>\n<p>If you just want to get all the data out of the stream as fast as\npossible, this is the best way to do so.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "Event: 'end'",
                  "type": "event",
                  "name": "end",
                  "desc": "<p>This event fires when there will be no more data to read.</p>\n<p>Note that the <code>&#39;end&#39;</code> event <strong>will not fire</strong> unless the data is\ncompletely consumed. This can be done by switching into flowing mode,\nor by calling [<code>stream.read()</code>][stream-read] repeatedly until you get to the\nend.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n});\nreadable.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;there will be no more data.&#39;);\n});\n</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'error'",
                  "type": "event",
                  "name": "error",
                  "params": [],
                  "desc": "<p>Emitted if there was an error receiving data.</p>\n"
                },
                {
                  "textRaw": "Event: 'readable'",
                  "type": "event",
                  "name": "readable",
                  "desc": "<p>When a chunk of data can be read from the stream, it will emit a\n<code>&#39;readable&#39;</code> event.</p>\n<p>In some cases, listening for a <code>&#39;readable&#39;</code> event will cause some data\nto be read into the internal buffer from the underlying system, if it\nhadn&#39;t already.</p>\n<pre><code class=\"lang-javascript\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, () =&gt; {\n  // there is some data to read now\n});\n</code></pre>\n<p>Once the internal buffer is drained, a <code>&#39;readable&#39;</code> event will fire\nagain when more data is available.</p>\n<p>The <code>&#39;readable&#39;</code> event is not emitted in the &quot;flowing&quot; mode with the\nsole exception of the last one, on end-of-stream.</p>\n<p>The <code>&#39;readable&#39;</code> event indicates that the stream has new information:\neither new data is available or the end of the stream has been reached.\nIn the former case, [<code>stream.read()</code>][stream-read] will return that data. In the\nlatter case, [<code>stream.read()</code>][stream-read] will return null. For instance, in\nthe following example, <code>foo.txt</code> is an empty file:</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\nvar rr = fs.createReadStream(&#39;foo.txt&#39;);\nrr.on(&#39;readable&#39;, () =&gt; {\n  console.log(&#39;readable:&#39;, rr.read());\n});\nrr.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;end&#39;);\n});\n</code></pre>\n<p>The output of running this script is:</p>\n<pre><code>$ node test.js\nreadable: null\nend\n</code></pre>",
                  "params": []
                }
              ],
              "methods": [
                {
                  "textRaw": "readable.isPaused()",
                  "type": "method",
                  "name": "isPaused",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Return: {Boolean} ",
                        "name": "return",
                        "type": "Boolean"
                      },
                      "params": []
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>This method returns whether or not the <code>readable</code> has been <strong>explicitly</strong>\npaused by client code (using [<code>stream.pause()</code>][stream-pause] without a\ncorresponding [<code>stream.resume()</code>][stream-resume]).</p>\n<pre><code class=\"lang-js\">var readable = new stream.Readable\n\nreadable.isPaused() // === false\nreadable.pause()\nreadable.isPaused() // === true\nreadable.resume()\nreadable.isPaused() // === false\n</code></pre>\n"
                },
                {
                  "textRaw": "readable.pause()",
                  "type": "method",
                  "name": "pause",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Return: `this` ",
                        "name": "return",
                        "desc": "`this`"
                      },
                      "params": []
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>This method will cause a stream in flowing mode to stop emitting\n[<code>&#39;data&#39;</code>][] events, switching out of flowing mode. Any data that becomes\navailable will remain in the internal buffer.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  readable.pause();\n  console.log(&#39;there will be no more data for 1 second&#39;);\n  setTimeout(() =&gt; {\n    console.log(&#39;now data will start flowing again&#39;);\n    readable.resume();\n  }, 1000);\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "readable.pipe(destination[, options])",
                  "type": "method",
                  "name": "pipe",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`destination` {stream.Writable} The destination for writing data ",
                          "name": "destination",
                          "type": "stream.Writable",
                          "desc": "The destination for writing data"
                        },
                        {
                          "textRaw": "`options` {Object} Pipe options ",
                          "options": [
                            {
                              "textRaw": "`end` {Boolean} End the writer when the reader ends. Default = `true` ",
                              "name": "end",
                              "type": "Boolean",
                              "desc": "End the writer when the reader ends. Default = `true`"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Pipe options",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "destination"
                        },
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>This method pulls all the data out of a readable stream, and writes it\nto the supplied destination, automatically managing the flow so that\nthe destination is not overwhelmed by a fast readable stream.</p>\n<p>Multiple destinations can be piped to safely.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;\nreadable.pipe(writable);\n</code></pre>\n<p>This function returns the destination stream, so you can set up pipe\nchains like so:</p>\n<pre><code class=\"lang-js\">var r = fs.createReadStream(&#39;file.txt&#39;);\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream(&#39;file.txt.gz&#39;);\nr.pipe(z).pipe(w);\n</code></pre>\n<p>For example, emulating the Unix <code>cat</code> command:</p>\n<pre><code class=\"lang-js\">process.stdin.pipe(process.stdout);\n</code></pre>\n<p>By default [<code>stream.end()</code>][stream-end] is called on the destination when the\nsource stream emits [<code>&#39;end&#39;</code>][], so that <code>destination</code> is no longer writable.\nPass <code>{ end: false }</code> as <code>options</code> to keep the destination stream open.</p>\n<p>This keeps <code>writer</code> open so that &quot;Goodbye&quot; can be written at the\nend.</p>\n<pre><code class=\"lang-js\">reader.pipe(writer, { end: false });\nreader.on(&#39;end&#39;, () =&gt; {\n  writer.end(&#39;Goodbye\\n&#39;);\n});\n</code></pre>\n<p>Note that [<code>process.stderr</code>][] and [<code>process.stdout</code>][] are never closed until\nthe process exits, regardless of the specified options.</p>\n"
                },
                {
                  "textRaw": "readable.read([size])",
                  "type": "method",
                  "name": "read",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Return {String|Buffer|Null} ",
                        "name": "return",
                        "type": "String|Buffer|Null"
                      },
                      "params": [
                        {
                          "textRaw": "`size` {Number} Optional argument to specify how much data to read. ",
                          "name": "size",
                          "type": "Number",
                          "desc": "Optional argument to specify how much data to read.",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "size",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>read()</code> method pulls some data out of the internal buffer and\nreturns it. If there is no data available, then it will return\n<code>null</code>.</p>\n<p>If you pass in a <code>size</code> argument, then it will return that many\nbytes. If <code>size</code> bytes are not available, then it will return <code>null</code>,\nunless we&#39;ve ended, in which case it will return the data remaining\nin the buffer.</p>\n<p>If you do not specify a <code>size</code> argument, then it will return all the\ndata in the internal buffer.</p>\n<p>This method should only be called in paused mode. In flowing mode,\nthis method is called automatically until the internal buffer is\ndrained.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, () =&gt; {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  }\n});\n</code></pre>\n<p>If this method returns a data chunk, then it will also trigger the\nemission of a [<code>&#39;data&#39;</code>][] event.</p>\n<p>Note that calling [<code>stream.read([size])</code>][stream-read] after the [<code>&#39;end&#39;</code>][]\nevent has been triggered will return <code>null</code>. No runtime error will be raised.</p>\n"
                },
                {
                  "textRaw": "readable.resume()",
                  "type": "method",
                  "name": "resume",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Return: `this` ",
                        "name": "return",
                        "desc": "`this`"
                      },
                      "params": []
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>This method will cause the readable stream to resume emitting [<code>&#39;data&#39;</code>][]\nevents.</p>\n<p>This method will switch the stream into flowing mode. If you do <em>not</em>\nwant to consume the data from a stream, but you <em>do</em> want to get to\nits [<code>&#39;end&#39;</code>][] event, you can call [<code>stream.resume()</code>][stream-resume] to open\nthe flow of data.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;got to the end, but did not read anything&#39;);\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "readable.setEncoding(encoding)",
                  "type": "method",
                  "name": "setEncoding",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Return: `this` ",
                        "name": "return",
                        "desc": "`this`"
                      },
                      "params": [
                        {
                          "textRaw": "`encoding` {String} The encoding to use. ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "The encoding to use."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "encoding"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Call this function to cause the stream to return strings of the specified\nencoding instead of Buffer objects. For example, if you do\n<code>readable.setEncoding(&#39;utf8&#39;)</code>, then the output data will be interpreted as\nUTF-8 data, and returned as strings. If you do <code>readable.setEncoding(&#39;hex&#39;)</code>,\nthen the data will be encoded in hexadecimal string format.</p>\n<p>This properly handles multi-byte characters that would otherwise be\npotentially mangled if you simply pulled the Buffers directly and\ncalled [<code>buf.toString(encoding)</code>][] on them. If you want to read the data\nas strings, always use this method.</p>\n<p>Also you can disable any encoding at all with <code>readable.setEncoding(null)</code>.\nThis approach is very useful if you deal with binary data or with large\nmulti-byte strings spread out over multiple chunks.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nreadable.setEncoding(&#39;utf8&#39;);\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  assert.equal(typeof chunk, &#39;string&#39;);\n  console.log(&#39;got %d characters of string data&#39;, chunk.length);\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "readable.unpipe([destination])",
                  "type": "method",
                  "name": "unpipe",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`destination` {stream.Writable} Optional specific stream to unpipe ",
                          "name": "destination",
                          "type": "stream.Writable",
                          "desc": "Optional specific stream to unpipe",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "destination",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>This method will remove the hooks set up for a previous [<code>stream.pipe()</code>][]\ncall.</p>\n<p>If the destination is not specified, then all pipes are removed.</p>\n<p>If the destination is specified, but no pipe is set up for it, then\nthis is a no-op.</p>\n<pre><code class=\"lang-js\">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;,\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(() =&gt; {\n  console.log(&#39;stop writing to file.txt&#39;);\n  readable.unpipe(writable);\n  console.log(&#39;manually close the file stream&#39;);\n  writable.end();\n}, 1000);\n</code></pre>\n"
                },
                {
                  "textRaw": "readable.unshift(chunk)",
                  "type": "method",
                  "name": "unshift",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|String} Chunk of data to unshift onto the read queue ",
                          "name": "chunk",
                          "type": "Buffer|String",
                          "desc": "Chunk of data to unshift onto the read queue"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>This is useful in certain cases where a stream is being consumed by a\nparser, which needs to &quot;un-consume&quot; some data that it has\noptimistically pulled out of the source, so that the stream can be\npassed on to some other party.</p>\n<p>Note that <code>stream.unshift(chunk)</code> cannot be called after the [<code>&#39;end&#39;</code>][] event\nhas been triggered; a runtime error will be raised.</p>\n<p>If you find that you must often call <code>stream.unshift(chunk)</code> in your\nprograms, consider implementing a [Transform][] stream instead. (See [API\nfor Stream Implementors][].)</p>\n<pre><code class=\"lang-js\">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nconst StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on(&#39;error&#39;, callback);\n  stream.on(&#39;readable&#39;, onReadable);\n  var decoder = new StringDecoder(&#39;utf8&#39;);\n  var header = &#39;&#39;;\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join(&#39;\\n\\n&#39;);\n        var buf = new Buffer(remaining, &#39;utf8&#39;);\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener(&#39;error&#39;, callback);\n        stream.removeListener(&#39;readable&#39;, onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}\n</code></pre>\n<p>Note that, unlike [<code>stream.push(chunk)</code>][stream-push], <code>stream.unshift(chunk)</code>\nwill not end the reading process by resetting the internal reading state of the\nstream. This can cause unexpected results if <code>unshift()</code> is called during a\nread (i.e. from within a [<code>stream._read()</code>][stream-_read] implementation on a\ncustom stream). Following the call to <code>unshift()</code> with an immediate\n[<code>stream.push(&#39;&#39;)</code>][stream-push] will reset the reading state appropriately,\nhowever it is best to simply avoid calling <code>unshift()</code> while in the process of\nperforming a read.</p>\n"
                },
                {
                  "textRaw": "readable.wrap(stream)",
                  "type": "method",
                  "name": "wrap",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`stream` {Stream} An \"old style\" readable stream ",
                          "name": "stream",
                          "type": "Stream",
                          "desc": "An \"old style\" readable stream"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "stream"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Versions of Node.js prior to v0.10 had streams that did not implement the\nentire Streams API as it is today. (See [Compatibility][] for\nmore information.)</p>\n<p>If you are using an older Node.js library that emits [<code>&#39;data&#39;</code>][] events and\nhas a [<code>stream.pause()</code>][stream-pause] method that is advisory only, then you\ncan use the <code>wrap()</code> method to create a [Readable][] stream that uses the old\nstream as its data source.</p>\n<p>You will very rarely ever need to call this function, but it exists\nas a convenience for interacting with old Node.js programs and libraries.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">const OldReader = require(&#39;./old-api-module.js&#39;).OldReader;\nconst Readable = require(&#39;stream&#39;).Readable;\nconst oreader = new OldReader;\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on(&#39;readable&#39;, () =&gt; {\n  myReader.read(); // etc.\n});\n</code></pre>\n"
                }
              ]
            },
            {
              "textRaw": "Class: stream.Transform",
              "type": "class",
              "name": "stream.Transform",
              "desc": "<p>Transform streams are [Duplex][] streams where the output is in some way\ncomputed from the input. They implement both the [Readable][] and\n[Writable][] interfaces.</p>\n<p>Examples of Transform streams include:</p>\n<ul>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n</ul>\n"
            },
            {
              "textRaw": "Class: stream.Writable",
              "type": "class",
              "name": "stream.Writable",
              "desc": "<p>The Writable stream interface is an abstraction for a <em>destination</em>\nthat you are writing data <em>to</em>.</p>\n<p>Examples of writable streams include:</p>\n<ul>\n<li>[HTTP requests, on the client][]</li>\n<li>[HTTP responses, on the server][]</li>\n<li>[fs write streams][]</li>\n<li>[zlib streams][zlib]</li>\n<li>[crypto streams][crypto]</li>\n<li>[TCP sockets][]</li>\n<li>[child process stdin][]</li>\n<li>[<code>process.stdout</code>][], [<code>process.stderr</code>][]</li>\n</ul>\n",
              "events": [
                {
                  "textRaw": "Event: 'close'",
                  "type": "event",
                  "name": "close",
                  "desc": "<p>Emitted when the stream and any of its underlying resources (a file descriptor,\nfor example) have been closed. The event indicates that no more events will be\nemitted, and no further computation will occur.</p>\n<p>Not all streams will emit the <code>&#39;close&#39;</code> event as the <code>&#39;close&#39;</code> event is\noptional.</p>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'drain'",
                  "type": "event",
                  "name": "drain",
                  "desc": "<p>If a [<code>stream.write(chunk)</code>][stream-write] call returns <code>false</code>, then the\n<code>&#39;drain&#39;</code> event will indicate when it is appropriate to begin writing more data\nto the stream.</p>\n<pre><code class=\"lang-js\">// Write the data to the supplied writable stream one million times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don&#39;t pass the callback, because we&#39;re not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i &gt; 0 &amp;&amp; ok);\n    if (i &gt; 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once(&#39;drain&#39;, write);\n    }\n  }\n}\n</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'error'",
                  "type": "event",
                  "name": "error",
                  "params": [],
                  "desc": "<p>Emitted if there was an error when writing or piping data.</p>\n"
                },
                {
                  "textRaw": "Event: 'finish'",
                  "type": "event",
                  "name": "finish",
                  "desc": "<p>When the [<code>stream.end()</code>][stream-end] method has been called, and all data has\nbeen flushed to the underlying system, this event is emitted.</p>\n<pre><code class=\"lang-javascript\">var writer = getWritableStreamSomehow();\nfor (var i = 0; i &lt; 100; i ++) {\n  writer.write(&#39;hello, #${i}!\\n&#39;);\n}\nwriter.end(&#39;this is the end\\n&#39;);\nwriter.on(&#39;finish&#39;, () =&gt; {\n  console.error(&#39;all writes are now complete.&#39;);\n});\n</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'pipe'",
                  "type": "event",
                  "name": "pipe",
                  "params": [],
                  "desc": "<p>This is emitted whenever the [<code>stream.pipe()</code>][] method is called on a readable\nstream, adding this writable to its set of destinations.</p>\n<pre><code class=\"lang-js\">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;pipe&#39;, (src) =&gt; {\n  console.error(&#39;something is piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\n</code></pre>\n"
                },
                {
                  "textRaw": "Event: 'unpipe'",
                  "type": "event",
                  "name": "unpipe",
                  "params": [],
                  "desc": "<p>This is emitted whenever the [<code>stream.unpipe()</code>][] method is called on a\nreadable stream, removing this writable from its set of destinations.</p>\n<pre><code class=\"lang-js\">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;unpipe&#39;, (src) =&gt; {\n  console.error(&#39;something has stopped piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);\n</code></pre>\n"
                }
              ],
              "methods": [
                {
                  "textRaw": "writable.cork()",
                  "type": "method",
                  "name": "cork",
                  "desc": "<p>Forces buffering of all writes.</p>\n<p>Buffered data will be flushed either at [<code>stream.uncork()</code>][] or at\n[<code>stream.end()</code>][stream-end] call.</p>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                },
                {
                  "textRaw": "writable.end([chunk][, encoding][, callback])",
                  "type": "method",
                  "name": "end",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunk` {String|Buffer} Optional data to write ",
                          "name": "chunk",
                          "type": "String|Buffer",
                          "desc": "Optional data to write",
                          "optional": true
                        },
                        {
                          "textRaw": "`encoding` {String} The encoding, if `chunk` is a String ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "The encoding, if `chunk` is a String",
                          "optional": true
                        },
                        {
                          "textRaw": "`callback` {Function} Optional callback for when the stream is finished ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Optional callback for when the stream is finished",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk",
                          "optional": true
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Call this method when no more data will be written to the stream. If supplied,\nthe callback is attached as a listener on the [<code>&#39;finish&#39;</code>][] event.</p>\n<p>Calling [<code>stream.write()</code>][stream-write] after calling\n[<code>stream.end()</code>][stream-end] will raise an error.</p>\n<pre><code class=\"lang-js\">// write &#39;hello, &#39; and then end with &#39;world!&#39;\nvar file = fs.createWriteStream(&#39;example.txt&#39;);\nfile.write(&#39;hello, &#39;);\nfile.end(&#39;world!&#39;);\n// writing more now is not allowed!\n</code></pre>\n"
                },
                {
                  "textRaw": "writable.setDefaultEncoding(encoding)",
                  "type": "method",
                  "name": "setDefaultEncoding",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`encoding` {String} The new default encoding ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "The new default encoding"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "encoding"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Sets the default encoding for a writable stream.</p>\n"
                },
                {
                  "textRaw": "writable.uncork()",
                  "type": "method",
                  "name": "uncork",
                  "desc": "<p>Flush all data, buffered since [<code>stream.cork()</code>][] call.</p>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                },
                {
                  "textRaw": "writable.write(chunk[, encoding][, callback])",
                  "type": "method",
                  "name": "write",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Boolean} `true` if the data was handled completely. ",
                        "name": "return",
                        "type": "Boolean",
                        "desc": "`true` if the data was handled completely."
                      },
                      "params": [
                        {
                          "textRaw": "`chunk` {String|Buffer} The data to write ",
                          "name": "chunk",
                          "type": "String|Buffer",
                          "desc": "The data to write"
                        },
                        {
                          "textRaw": "`encoding` {String} The encoding, if `chunk` is a String ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "The encoding, if `chunk` is a String",
                          "optional": true
                        },
                        {
                          "textRaw": "`callback` {Function} Callback for when this chunk of data is flushed ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Callback for when this chunk of data is flushed",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>This method writes some data to the underlying system, and calls the\nsupplied callback once the data has been fully handled.  If an error\noccurs, the callback may or may not be called with the error as its\nfirst argument.  To detect write errors, listen for the <code>&#39;error&#39;</code> event.</p>\n<p>The return value indicates if you should continue writing right now.\nIf the data had to be buffered internally, then it will return\n<code>false</code>. Otherwise, it will return <code>true</code>.</p>\n<p>This return value is strictly advisory. You MAY continue to write,\neven if it returns <code>false</code>. However, writes will be buffered in\nmemory, so it is best not to do this excessively. Instead, wait for\nthe [<code>&#39;drain&#39;</code>][] event before writing more data.</p>\n"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "API for Stream Implementors",
          "name": "API for Stream Implementors",
          "type": "misc",
          "desc": "<p>To implement any sort of stream, the pattern is the same:</p>\n<ol>\n<li>Extend the appropriate parent class in your own subclass. (The\n[<code>util.inherits()</code>][] method is particularly helpful for this.)</li>\n<li>Call the appropriate parent class constructor in your constructor,\nto be sure that the internal mechanisms are set up properly.</li>\n<li>Implement one or more specific methods, as detailed below.</li>\n</ol>\n<p>The class to extend and the method(s) to implement depend on the sort\nof stream class you are writing:</p>\n<table>\n  <thead>\n    <tr>\n      <th>\n        <p>Use-case</p>\n      </th>\n      <th>\n        <p>Class</p>\n      </th>\n      <th>\n        <p>Method(s) to implement</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <p>Reading only</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_readable_1\">Readable</a></p>\n    </td>\n    <td>\n      <p><code>[_read][stream-_read]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Writing only</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_writable_1\">Writable</a></p>\n    </td>\n    <td>\n      <p><code>[_write][stream-_write]</code>, <code>[_writev][stream-_writev]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Reading and writing</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_duplex_1\">Duplex</a></p>\n    </td>\n    <td>\n      <p><code>[_read][stream-_read]</code>, <code>[_write][stream-_write]</code>, <code>[_writev][stream-_writev]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Operate on written data, then read the result</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_transform_1\">Transform</a></p>\n    </td>\n    <td>\n      <p><code>[_transform][stream-_transform]</code>, <code>[_flush][stream-_flush]</code></p>\n    </td>\n  </tr>\n</table>\n\n<p>In your implementation code, it is very important to never call the methods\ndescribed in [API for Stream Consumers][]. Otherwise, you can potentially cause\nadverse side effects in programs that consume your streaming interfaces.</p>\n",
          "classes": [
            {
              "textRaw": "Class: stream.Duplex",
              "type": "class",
              "name": "stream.Duplex",
              "desc": "<p>A &quot;duplex&quot; stream is one that is both Readable and Writable, such as a TCP\nsocket connection.</p>\n<p>Note that <code>stream.Duplex</code> is an abstract class designed to be extended\nwith an underlying implementation of the [<code>stream._read(size)</code>][stream-_read]\nand [<code>stream._write(chunk, encoding, callback)</code>][stream-_write] methods as you\nwould with a Readable or Writable stream class.</p>\n<p>Since JavaScript doesn&#39;t have multiple prototypal inheritance, this class\nprototypally inherits from Readable, and then parasitically from Writable. It is\nthus up to the user to implement both the low-level\n[<code>stream._read(n)</code>][stream-_read] method as well as the low-level\n[<code>stream._write(chunk, encoding, callback)</code>][stream-_write] method on extension\nduplex classes.</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Duplex(options)",
                  "type": "method",
                  "name": "Duplex",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} Passed to both Writable and Readable constructors. Also has the following fields: ",
                          "options": [
                            {
                              "textRaw": "`allowHalfOpen` {Boolean} Default = `true`. If set to `false`, then the stream will automatically end the readable side when the writable side ends and vice versa. ",
                              "name": "allowHalfOpen",
                              "type": "Boolean",
                              "desc": "Default = `true`. If set to `false`, then the stream will automatically end the readable side when the writable side ends and vice versa."
                            },
                            {
                              "textRaw": "`readableObjectMode` {Boolean} Default = `false`. Sets `objectMode` for readable side of the stream. Has no effect if `objectMode` is `true`. ",
                              "name": "readableObjectMode",
                              "type": "Boolean",
                              "desc": "Default = `false`. Sets `objectMode` for readable side of the stream. Has no effect if `objectMode` is `true`."
                            },
                            {
                              "textRaw": "`writableObjectMode` {Boolean} Default = `false`. Sets `objectMode` for writable side of the stream. Has no effect if `objectMode` is `true`. ",
                              "name": "writableObjectMode",
                              "type": "Boolean",
                              "desc": "Default = `false`. Sets `objectMode` for writable side of the stream. Has no effect if `objectMode` is `true`."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Passed to both Writable and Readable constructors. Also has the following fields:"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>In classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.</p>\n"
                }
              ]
            },
            {
              "textRaw": "Class: stream.PassThrough",
              "type": "class",
              "name": "stream.PassThrough",
              "desc": "<p>This is a trivial implementation of a [Transform][] stream that simply\npasses the input bytes across to the output. Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy as a building block for novel sorts of streams.</p>\n"
            },
            {
              "textRaw": "Class: stream.Readable",
              "type": "class",
              "name": "stream.Readable",
              "desc": "<p><code>stream.Readable</code> is an abstract class designed to be extended with an\nunderlying implementation of the [<code>stream._read(size)</code>][stream-_read] method.</p>\n<p>Please see [API for Stream Consumers][] for how to consume\nstreams in your programs. What follows is an explanation of how to\nimplement Readable streams in your programs.</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Readable([options])",
                  "type": "method",
                  "name": "Readable",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource. Default = `16384` (16kb), or `16` for `objectMode` streams ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource. Default = `16384` (16kb), or `16` for `objectMode` streams"
                            },
                            {
                              "textRaw": "`encoding` {String} If specified, then buffers will be decoded to strings using the specified encoding. Default = `null` ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "If specified, then buffers will be decoded to strings using the specified encoding. Default = `null`"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} Whether this stream should behave as a stream of objects. Meaning that [`stream.read(n)`][stream-read] returns a single value instead of a Buffer of size n. Default = `false` ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "Whether this stream should behave as a stream of objects. Meaning that [`stream.read(n)`][stream-read] returns a single value instead of a Buffer of size n. Default = `false`"
                            },
                            {
                              "textRaw": "`read` {Function} Implementation for the [`stream._read()`][stream-_read] method. ",
                              "name": "read",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._read()`][stream-_read] method."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>In classes that extend the Readable class, make sure to call the\nReadable constructor so that the buffering settings can be properly\ninitialized.</p>\n"
                },
                {
                  "textRaw": "readable._read(size)",
                  "type": "method",
                  "name": "_read",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`size` {Number} Number of bytes to read asynchronously ",
                          "name": "size",
                          "type": "Number",
                          "desc": "Number of bytes to read asynchronously"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "size"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Note: <strong>Implement this method, but do NOT call it directly.</strong></p>\n<p>This method is prefixed with an underscore because it is internal to the\nclass that defines it and should only be called by the internal Readable\nclass methods. All Readable stream implementations must provide a _read\nmethod to fetch data from the underlying resource.</p>\n<p>When <code>_read()</code> is called, if data is available from the resource, the <code>_read()</code>\nimplementation should start pushing that data into the read queue by calling\n[<code>this.push(dataChunk)</code>][stream-push]. <code>_read()</code> should continue reading from\nthe resource and pushing data until push returns <code>false</code>, at which point it\nshould stop reading from the resource. Only when <code>_read()</code> is called again after\nit has stopped should it start reading more data from the resource and pushing\nthat data onto the queue.</p>\n<p>Note: once the <code>_read()</code> method is called, it will not be called again until\nthe [<code>stream.push()</code>][stream-push] method is called.</p>\n<p>The <code>size</code> argument is advisory. Implementations where a &quot;read&quot; is a\nsingle call that returns data can use this to know how much data to\nfetch. Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available. There is no need, for example to &quot;wait&quot; until\n<code>size</code> bytes are available before calling [<code>stream.push(chunk)</code>][stream-push].</p>\n"
                }
              ],
              "examples": [
                {
                  "textRaw": "readable.push(chunk[, encoding])",
                  "type": "example",
                  "name": "push",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "return {Boolean} Whether or not more pushes should be performed ",
                        "name": "return",
                        "type": "Boolean",
                        "desc": "Whether or not more pushes should be performed"
                      },
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|Null|String} Chunk of data to push into the read queue ",
                          "name": "chunk",
                          "type": "Buffer|Null|String",
                          "desc": "Chunk of data to push into the read queue"
                        },
                        {
                          "textRaw": "`encoding` {String} Encoding of String chunks.  Must be a valid Buffer encoding, such as `'utf8'` or `'ascii'` ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "Encoding of String chunks.  Must be a valid Buffer encoding, such as `'utf8'` or `'ascii'`",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Note: <strong>This method should be called by Readable implementors, NOT\nby consumers of Readable streams.</strong></p>\n<p>If a value other than null is passed, The <code>push()</code> method adds a chunk of data\ninto the queue for subsequent stream processors to consume. If <code>null</code> is\npassed, it signals the end of the stream (EOF), after which no more data\ncan be written.</p>\n<p>The data added with <code>push()</code> can be pulled out by calling the\n[<code>stream.read()</code>][stream-read] method when the [<code>&#39;readable&#39;</code>][] event fires.</p>\n<p>This API is designed to be as flexible as possible. For example,\nyou may be wrapping a lower-level source which has some sort of\npause/resume mechanism, and a data callback. In those cases, you\ncould wrap the low-level source object by doing something like this:</p>\n<pre><code class=\"lang-js\">// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nutil.inherits(SourceWrapper, Readable);\n\nfunction SourceWrapper(options) {\n  Readable.call(this, options);\n\n  this._source = getLowlevelSourceObject();\n\n  // Every time there&#39;s data, we push it into the internal buffer.\n  this._source.ondata = (chunk) =&gt; {\n    // if push() returns false, then we need to stop reading from source\n    if (!this.push(chunk))\n      this._source.readStop();\n  };\n\n  // When the source ends, we push the EOF-signaling `null` chunk\n  this._source.onend = () =&gt; {\n    this.push(null);\n  };\n}\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nSourceWrapper.prototype._read = function(size) {\n  this._source.readStart();\n};\n</code></pre>\n<h4>Example: A Counting Stream</h4>\n<p>This is a basic example of a Readable stream. It emits the numerals\nfrom 1 to 1,000,000 in ascending order, and then ends.</p>\n<pre><code class=\"lang-js\">const Readable = require(&#39;stream&#39;).Readable;\nconst util = require(&#39;util&#39;);\nutil.inherits(Counter, Readable);\n\nfunction Counter(opt) {\n  Readable.call(this, opt);\n  this._max = 1000000;\n  this._index = 1;\n}\n\nCounter.prototype._read = function() {\n  var i = this._index++;\n  if (i &gt; this._max)\n    this.push(null);\n  else {\n    var str = &#39;&#39; + i;\n    var buf = new Buffer(str, &#39;ascii&#39;);\n    this.push(buf);\n  }\n};\n</code></pre>\n<h4>Example: SimpleProtocol v1 (Sub-optimal)</h4>\n<p>This is similar to the <code>parseHeader</code> function described\n<a href=\"#stream_readable_unshift_chunk\">here</a>, but implemented as a custom stream.\nAlso, note that this implementation does not convert the incoming data to a\nstring.</p>\n<p>However, this would be better implemented as a [Transform][] stream. See\n[SimpleProtocol v2][] for a better implementation.</p>\n<pre><code class=\"lang-js\">// A parser for a simple data protocol.\n// The &quot;header&quot; is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// NOTE: This can be done more simply as a Transform stream!\n// Using Readable directly for this is sub-optimal. See the\n// alternative example below under the Transform section.\n\nconst Readable = require(&#39;stream&#39;).Readable;\nconst util = require(&#39;util&#39;);\n\nutil.inherits(SimpleProtocol, Readable);\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(source, options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  source.on(&#39;end&#39;, () =&gt; {\n    this.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on(&#39;readable&#39;, () =&gt; {\n    this.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn&#39;t have data, we don&#39;t have data yet.\n    if (chunk === null)\n      return this.push(&#39;&#39;);\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // &#39;\\n&#39;\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push(&#39;&#39;);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n      // calling unshift by itself does not reset the reading state\n      // of the stream; since we&#39;re inside _read, doing an additional\n      // push(&#39;&#39;) will reset the state appropriately.\n      this.push(&#39;&#39;);\n\n      // and let them know that we are done parsing the header.\n      this.emit(&#39;header&#39;, this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\n// var parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit &#39;header&#39;\n// with the parsed header data.\n</code></pre>\n"
                }
              ]
            },
            {
              "textRaw": "Class: stream.Transform",
              "type": "class",
              "name": "stream.Transform",
              "desc": "<p>A &quot;transform&quot; stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a [zlib][] stream or a\n[crypto][] stream.</p>\n<p>There is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time. For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended. A zlib stream will produce output\nthat is either much smaller or much larger than its input.</p>\n<p>Rather than implement the [<code>stream._read()</code>][stream-_read] and\n[<code>stream._write()</code>][stream-_write] methods, Transform classes must implement the\n[<code>stream._transform()</code>][stream-_transform] method, and may optionally\nalso implement the [<code>stream._flush()</code>][stream-_flush] method. (See below.)</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Transform([options])",
                  "type": "method",
                  "name": "Transform",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} Passed to both Writable and Readable constructors. Also has the following fields: ",
                          "options": [
                            {
                              "textRaw": "`transform` {Function} Implementation for the [`stream._transform()`][stream-_transform] method. ",
                              "name": "transform",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._transform()`][stream-_transform] method."
                            },
                            {
                              "textRaw": "`flush` {Function} Implementation for the [`stream._flush()`][stream-_flush] method. ",
                              "name": "flush",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._flush()`][stream-_flush] method."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Passed to both Writable and Readable constructors. Also has the following fields:",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>In classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.</p>\n"
                },
                {
                  "textRaw": "transform._flush(callback)",
                  "type": "method",
                  "name": "_flush",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`callback` {Function} Call this function (optionally with an error argument) when you are done flushing any remaining data. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Call this function (optionally with an error argument) when you are done flushing any remaining data."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.</p>\n<p>In some cases, your transform operation may need to emit a bit more\ndata at the end of the stream. For example, a <code>Zlib</code> compression\nstream will store up some internal state so that it can optimally\ncompress the output. At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.</p>\n<p>In those cases, you can implement a <code>_flush()</code> method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting [<code>&#39;end&#39;</code>][] to signal the end of the readable side. Just\nlike with [<code>stream._transform()</code>][stream-_transform], call\n<code>transform.push(chunk)</code> zero or more times, as appropriate, and call <code>callback</code>\nwhen the flush operation is complete.</p>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms. However, you <strong>are</strong> expected to override this method in\nyour own extension classes.</p>\n"
                },
                {
                  "textRaw": "transform._transform(chunk, encoding, callback)",
                  "type": "method",
                  "name": "_transform",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|String} The chunk to be transformed. Will **always** be a buffer unless the `decodeStrings` option was set to `false`. ",
                          "name": "chunk",
                          "type": "Buffer|String",
                          "desc": "The chunk to be transformed. Will **always** be a buffer unless the `decodeStrings` option was set to `false`."
                        },
                        {
                          "textRaw": "`encoding` {String} If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value - 'buffer', ignore it in this case. ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value - 'buffer', ignore it in this case."
                        },
                        {
                          "textRaw": "`callback` {Function} Call this function (optionally with an error argument and data) when you are done processing the supplied chunk. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Call this function (optionally with an error argument and data) when you are done processing the supplied chunk."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.</p>\n<p>All Transform stream implementations must provide a <code>_transform()</code>\nmethod to accept input and produce output.</p>\n<p><code>_transform()</code> should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface. Do asynchronous I/O,\nprocess things, and so on.</p>\n<p>Call <code>transform.push(outputChunk)</code> 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.</p>\n<p>Call the callback function only when the current chunk is completely\nconsumed. Note that there may or may not be output as a result of any\nparticular input chunk. If you supply a second argument to the callback\nit will be passed to the push method. In other words the following are\nequivalent:</p>\n<pre><code class=\"lang-js\">transform.prototype._transform = function (data, encoding, callback) {\n  this.push(data);\n  callback();\n};\n\ntransform.prototype._transform = function (data, encoding, callback) {\n  callback(null, data);\n};\n</code></pre>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms. However, you <strong>are</strong> expected to override this method in\nyour own extension classes.</p>\n<h4>Example: <code>SimpleProtocol</code> parser v2</h4>\n<p>The example <a href=\"#stream_example_simpleprotocol_v1_sub_optimal\">here</a> of a simple\nprotocol parser can be implemented simply by using the higher level\n[Transform][] stream class, similar to the <code>parseHeader</code> and <code>SimpleProtocol\nv1</code> examples.</p>\n<p>In this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node.js stream\napproach.</p>\n<pre><code class=\"lang-javascript\">const util = require(&#39;util&#39;);\nconst Transform = require(&#39;stream&#39;).Transform;\nutil.inherits(SimpleProtocol, Transform);\n\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // &#39;\\n&#39;\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit(&#39;header&#39;, this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(chunk.slice(split));\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(chunk);\n  }\n  done();\n};\n\n// Usage:\n// var parser = new SimpleProtocol();\n// source.pipe(parser)\n// Now parser is a readable stream that will emit &#39;header&#39;\n// with the parsed header data.\n</code></pre>\n"
                }
              ],
              "modules": [
                {
                  "textRaw": "Events: 'finish' and 'end'",
                  "name": "events:_'finish'_and_'end'",
                  "desc": "<p>The [<code>&#39;finish&#39;</code>][] and [<code>&#39;end&#39;</code>][] events are from the parent Writable\nand Readable classes respectively. The <code>&#39;finish&#39;</code> event is fired after\n[<code>stream.end()</code>][stream-end] is called and all chunks have been processed by\n[<code>stream._transform()</code>][stream-_transform], <code>&#39;end&#39;</code> is fired after all data has\nbeen output which is after the callback in [<code>stream._flush()</code>][stream-_flush]\nhas been called.</p>\n",
                  "type": "module",
                  "displayName": "Events: 'finish' and 'end'"
                }
              ]
            },
            {
              "textRaw": "Class: stream.Writable",
              "type": "class",
              "name": "stream.Writable",
              "desc": "<p><code>stream.Writable</code> is an abstract class designed to be extended with an\nunderlying implementation of the\n[<code>stream._write(chunk, encoding, callback)</code>][stream-_write] method.</p>\n<p>Please see [API for Stream Consumers][] for how to consume\nwritable streams in your programs. What follows is an explanation of\nhow to implement Writable streams in your programs.</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Writable([options])",
                  "type": "method",
                  "name": "Writable",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} Buffer level when [`stream.write()`][stream-write] starts returning `false`. Default = `16384` (16kb), or `16` for `objectMode` streams. ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "Buffer level when [`stream.write()`][stream-write] starts returning `false`. Default = `16384` (16kb), or `16` for `objectMode` streams."
                            },
                            {
                              "textRaw": "`decodeStrings` {Boolean} Whether or not to decode strings into Buffers before passing them to [`stream._write()`][stream-_write]. Default = `true` ",
                              "name": "decodeStrings",
                              "type": "Boolean",
                              "desc": "Whether or not to decode strings into Buffers before passing them to [`stream._write()`][stream-_write]. Default = `true`"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} Whether or not the [`stream.write(anyObj)`][stream-write] is a valid operation. If set you can write arbitrary data instead of only `Buffer` / `String` data. Default = `false` ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "Whether or not the [`stream.write(anyObj)`][stream-write] is a valid operation. If set you can write arbitrary data instead of only `Buffer` / `String` data. Default = `false`"
                            },
                            {
                              "textRaw": "`write` {Function} Implementation for the [`stream._write()`][stream-_write] method. ",
                              "name": "write",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._write()`][stream-_write] method."
                            },
                            {
                              "textRaw": "`writev` {Function} Implementation for the [`stream._writev()`][stream-_writev] method. ",
                              "name": "writev",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._writev()`][stream-_writev] method."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>In classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.</p>\n"
                },
                {
                  "textRaw": "writable._write(chunk, encoding, callback)",
                  "type": "method",
                  "name": "_write",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|String} The chunk to be written. Will **always** be a buffer unless the `decodeStrings` option was set to `false`. ",
                          "name": "chunk",
                          "type": "Buffer|String",
                          "desc": "The chunk to be written. Will **always** be a buffer unless the `decodeStrings` option was set to `false`."
                        },
                        {
                          "textRaw": "`encoding` {String} If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value - 'buffer', ignore it in this case. ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value - 'buffer', ignore it in this case."
                        },
                        {
                          "textRaw": "`callback` {Function} Call this function (optionally with an error argument) when you are done processing the supplied chunk. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Call this function (optionally with an error argument) when you are done processing the supplied chunk."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>All Writable stream implementations must provide a\n[<code>stream._write()</code>][stream-_write] method to send data to the underlying\nresource.</p>\n<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.</p>\n<p>Call the callback using the standard <code>callback(error)</code> pattern to\nsignal that the write completed successfully or with an error.</p>\n<p>If the <code>decodeStrings</code> flag is set in the constructor options, then\n<code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will\nindicate the sort of string that it is. This is to support\nimplementations that have an optimized handling for certain string\ndata encodings. If you do not explicitly set the <code>decodeStrings</code>\noption to <code>false</code>, then you can safely ignore the <code>encoding</code> argument,\nand assume that <code>chunk</code> will always be a Buffer.</p>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms. However, you <strong>are</strong> expected to override this method in\nyour own extension classes.</p>\n"
                },
                {
                  "textRaw": "writable._writev(chunks, callback)",
                  "type": "method",
                  "name": "_writev",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunks` {Array} The chunks to be written. Each chunk has following format: `{ chunk: ..., encoding: ... }`. ",
                          "name": "chunks",
                          "type": "Array",
                          "desc": "The chunks to be written. Each chunk has following format: `{ chunk: ..., encoding: ... }`."
                        },
                        {
                          "textRaw": "`callback` {Function} Call this function (optionally with an error argument) when you are done processing the supplied chunks. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Call this function (optionally with an error argument) when you are done processing the supplied chunks."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunks"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Note: <strong>This function MUST NOT be called directly.</strong>  It may be\nimplemented by child classes, and called by the internal Writable\nclass methods only.</p>\n<p>This function is completely optional to implement. In most cases it is\nunnecessary. If implemented, it will be called with all the chunks\nthat are buffered in the write queue.</p>\n"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Simplified Constructor API",
          "name": "Simplified Constructor API",
          "type": "misc",
          "desc": "<p>In simple cases there is now the added benefit of being able to construct a\nstream without inheritance.</p>\n<p>This can be done by passing the appropriate methods as constructor options:</p>\n<p>Examples:</p>\n",
          "miscs": [
            {
              "textRaw": "Duplex",
              "name": "duplex",
              "desc": "<pre><code class=\"lang-js\">var duplex = new stream.Duplex({\n  read: function(n) {\n    // sets this._read under the hood\n\n    // push data onto the read queue, passing null\n    // will signal the end of the stream (EOF)\n    this.push(chunk);\n  },\n  write: function(chunk, encoding, next) {\n    // sets this._write under the hood\n\n    // An optional error can be passed as the first argument\n    next()\n  }\n});\n\n// or\n\nvar duplex = new stream.Duplex({\n  read: function(n) {\n    // sets this._read under the hood\n\n    // push data onto the read queue, passing null\n    // will signal the end of the stream (EOF)\n    this.push(chunk);\n  },\n  writev: function(chunks, next) {\n    // sets this._writev under the hood\n\n    // An optional error can be passed as the first argument\n    next()\n  }\n});\n</code></pre>\n",
              "type": "misc",
              "displayName": "Duplex"
            },
            {
              "textRaw": "Readable",
              "name": "readable",
              "desc": "<pre><code class=\"lang-js\">var readable = new stream.Readable({\n  read: function(n) {\n    // sets this._read under the hood\n\n    // push data onto the read queue, passing null\n    // will signal the end of the stream (EOF)\n    this.push(chunk);\n  }\n});\n</code></pre>\n",
              "type": "misc",
              "displayName": "Readable"
            },
            {
              "textRaw": "Transform",
              "name": "transform",
              "desc": "<pre><code class=\"lang-js\">var transform = new stream.Transform({\n  transform: function(chunk, encoding, next) {\n    // sets this._transform under the hood\n\n    // generate output as many times as needed\n    // this.push(chunk);\n\n    // call when the current chunk is consumed\n    next();\n  },\n  flush: function(done) {\n    // sets this._flush under the hood\n\n    // generate output as many times as needed\n    // this.push(chunk);\n\n    done();\n  }\n});\n</code></pre>\n",
              "type": "misc",
              "displayName": "Transform"
            },
            {
              "textRaw": "Writable",
              "name": "writable",
              "desc": "<pre><code class=\"lang-js\">var writable = new stream.Writable({\n  write: function(chunk, encoding, next) {\n    // sets this._write under the hood\n\n    // An optional error can be passed as the first argument\n    next()\n  }\n});\n\n// or\n\nvar writable = new stream.Writable({\n  writev: function(chunks, next) {\n    // sets this._writev under the hood\n\n    // An optional error can be passed as the first argument\n    next()\n  }\n});\n</code></pre>\n",
              "type": "misc",
              "displayName": "Writable"
            }
          ]
        },
        {
          "textRaw": "Streams: Under the Hood",
          "name": "Streams: Under the Hood",
          "type": "misc",
          "miscs": [
            {
              "textRaw": "Buffering",
              "name": "Buffering",
              "type": "misc",
              "desc": "<p>Both Writable and Readable streams will buffer data on an internal\nobject which can be retrieved from <code>_writableState.getBuffer()</code> or\n<code>_readableState.buffer</code>, respectively.</p>\n<p>The amount of data that will potentially be buffered depends on the\n<code>highWaterMark</code> option which is passed into the constructor.</p>\n<p>Buffering in Readable streams happens when the implementation calls\n[<code>stream.push(chunk)</code>][stream-push]. If the consumer of the Stream does not\ncall [<code>stream.read()</code>][stream-read], then the data will sit in the internal\nqueue until it is consumed.</p>\n<p>Buffering in Writable streams happens when the user calls\n[<code>stream.write(chunk)</code>][stream-write] repeatedly, even when it returns <code>false</code>.</p>\n<p>The purpose of streams, especially with the [<code>stream.pipe()</code>][] method, is to\nlimit the buffering of data to acceptable levels, so that sources and\ndestinations of varying speed will not overwhelm the available memory.</p>\n"
            },
            {
              "textRaw": "Compatibility with Older Node.js Versions",
              "name": "Compatibility with Older Node.js Versions",
              "type": "misc",
              "desc": "<p>In versions of Node.js prior to v0.10, the Readable stream interface was\nsimpler, but also less powerful and less useful.</p>\n<ul>\n<li>Rather than waiting for you to call the [<code>stream.read()</code>][stream-read] method,\n[<code>&#39;data&#39;</code>][] events would start emitting immediately. If you needed to do\nsome I/O to decide how to handle data, then you had to store the chunks\nin some kind of buffer so that they would not be lost.</li>\n<li>The [<code>stream.pause()</code>][stream-pause] method was advisory, rather than\nguaranteed. This meant that you still had to be prepared to receive\n[<code>&#39;data&#39;</code>][] events even when the stream was in a paused state.</li>\n</ul>\n<p>In Node.js v0.10, the [Readable][] class was added.\nFor backwards compatibility with older Node.js programs, Readable streams\nswitch into &quot;flowing mode&quot; when a [<code>&#39;data&#39;</code>][] event handler is added, or\nwhen the [<code>stream.resume()</code>][stream-resume] method is called. The effect is\nthat, even if you are not using the new [<code>stream.read()</code>][stream-read] method\nand [<code>&#39;readable&#39;</code>][] event, you no longer have to worry about losing\n[<code>&#39;data&#39;</code>][] chunks.</p>\n<p>Most programs will continue to function normally. However, this\nintroduces an edge case in the following conditions:</p>\n<ul>\n<li>No [<code>&#39;data&#39;</code>][] event handler is added.</li>\n<li>The [<code>stream.resume()</code>][stream-resume] method is never called.</li>\n<li>The stream is not piped to any writable destination.</li>\n</ul>\n<p>For example, consider the following code:</p>\n<pre><code class=\"lang-js\">// WARNING!  BROKEN!\nnet.createServer((socket) =&gt; {\n\n  // we add an &#39;end&#39; method, but never consume the data\n  socket.on(&#39;end&#39;, () =&gt; {\n    // It will never get here.\n    socket.end(&#39;I got your message (but didnt read it)\\n&#39;);\n  });\n\n}).listen(1337);\n</code></pre>\n<p>In versions of Node.js prior to v0.10, the incoming message data would be\nsimply discarded. However, in Node.js v0.10 and beyond,\nthe socket will remain paused forever.</p>\n<p>The workaround in this situation is to call the\n[<code>stream.resume()</code>][stream-resume] method to start the flow of data:</p>\n<pre><code class=\"lang-js\">// Workaround\nnet.createServer((socket) =&gt; {\n\n  socket.on(&#39;end&#39;, () =&gt; {\n    socket.end(&#39;I got your message (but didnt read it)\\n&#39;);\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n</code></pre>\n<p>In addition to new Readable streams switching into flowing mode,\npre-v0.10 style streams can be wrapped in a Readable class using the\n[<code>stream.wrap()</code>][] method.</p>\n"
            },
            {
              "textRaw": "Object Mode",
              "name": "Object Mode",
              "type": "misc",
              "desc": "<p>Normally, Streams operate on Strings and Buffers exclusively.</p>\n<p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values\nother than Buffers and Strings.</p>\n<p>A Readable stream in object mode will always return a single item from\na call to [<code>stream.read(size)</code>][stream-read], regardless of what the size\nargument is.</p>\n<p>A Writable stream in object mode will always ignore the <code>encoding</code>\nargument to [<code>stream.write(data, encoding)</code>][stream-write].</p>\n<p>The special value <code>null</code> still retains its special value for object\nmode streams. That is, for object mode readable streams, <code>null</code> as a\nreturn value from [<code>stream.read()</code>][stream-read] indicates that there is no more\ndata, and [<code>stream.push(null)</code>][stream-push] will signal the end of stream data\n(<code>EOF</code>).</p>\n<p>No streams in Node.js core are object mode streams. This pattern is only\nused by userland streaming libraries.</p>\n<p>You should set <code>objectMode</code> in your stream child class constructor on\nthe options object. Setting <code>objectMode</code> mid-stream is not safe.</p>\n<p>For Duplex streams <code>objectMode</code> can be set exclusively for readable or\nwritable side with <code>readableObjectMode</code> and <code>writableObjectMode</code>\nrespectively. These options can be used to implement parsers and\nserializers with Transform streams.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\nconst StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nconst Transform = require(&#39;stream&#39;).Transform;\nutil.inherits(JSONParseStream, Transform);\n\n// Gets \\n-delimited JSON string data, and emits the parsed objects\nfunction JSONParseStream() {\n  if (!(this instanceof JSONParseStream))\n    return new JSONParseStream();\n\n  Transform.call(this, { readableObjectMode : true });\n\n  this._buffer = &#39;&#39;;\n  this._decoder = new StringDecoder(&#39;utf8&#39;);\n}\n\nJSONParseStream.prototype._transform = function(chunk, encoding, cb) {\n  this._buffer += this._decoder.write(chunk);\n  // split on newlines\n  var lines = this._buffer.split(/\\r?\\n/);\n  // keep the last partial line buffered\n  this._buffer = lines.pop();\n  for (var l = 0; l &lt; lines.length; l++) {\n    var line = lines[l];\n    try {\n      var obj = JSON.parse(line);\n    } catch (er) {\n      this.emit(&#39;error&#39;, er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};\n\nJSONParseStream.prototype._flush = function(cb) {\n  // Just handle any leftover\n  var rem = this._buffer.trim();\n  if (rem) {\n    try {\n      var obj = JSON.parse(rem);\n    } catch (er) {\n      this.emit(&#39;error&#39;, er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};\n</code></pre>\n"
            },
            {
              "textRaw": "`stream.read(0)`",
              "name": "`stream.read(0)`",
              "desc": "<p>There are some cases where you want to trigger a refresh of the\nunderlying readable stream mechanisms, without actually consuming any\ndata. In that case, you can call <code>stream.read(0)</code>, which will always\nreturn null.</p>\n<p>If the internal read buffer is below the <code>highWaterMark</code>, and the\nstream is not currently reading, then calling <code>stream.read(0)</code> will trigger\na low-level [<code>stream._read()</code>][stream-_read] call.</p>\n<p>There is almost never a need to do this. However, you will see some\ncases in Node.js&#39;s internals where this is done, particularly in the\nReadable stream class internals.</p>\n",
              "type": "misc",
              "displayName": "`stream.read(0)`"
            },
            {
              "textRaw": "`stream.push('')`",
              "name": "`stream.push('')`",
              "desc": "<p>Pushing a zero-byte string or Buffer (when not in [Object mode][]) has an\ninteresting side effect. Because it <em>is</em> a call to\n[<code>stream.push()</code>][stream-push], it will end the <code>reading</code> process. However, it\ndoes <em>not</em> add any data to the readable buffer, so there&#39;s nothing for\na user to consume.</p>\n<p>Very rarely, there are cases where you have no data to provide now,\nbut the consumer of your stream (or, perhaps, another bit of your own\ncode) will know when to check again, by calling [<code>stream.read(0)</code>][stream-read].\nIn those cases, you <em>may</em> call <code>stream.push(&#39;&#39;)</code>.</p>\n<p>So far, the only use case for this functionality is in the\n[<code>tls.CryptoStream</code>][] class, which is deprecated in Node.js/io.js v1.0. If you\nfind that you have to use <code>stream.push(&#39;&#39;)</code>, please consider another\napproach, because it almost certainly indicates that something is\nhorribly wrong.</p>\n<!-- [end-include:stream.md] -->\n<!-- [start-include:string_decoder.md] -->\n",
              "type": "misc",
              "displayName": "`stream.push('')`"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Stream"
    },
    {
      "textRaw": "StringDecoder",
      "name": "stringdecoder",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>To use this module, do <code>require(&#39;string_decoder&#39;)</code>. StringDecoder decodes a\nbuffer to a string. It is a simple interface to <code>buffer.toString()</code> but provides\nadditional support for utf8.</p>\n<pre><code class=\"lang-js\">const StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nconst decoder = new StringDecoder(&#39;utf8&#39;);\n\nconst cent = new Buffer([0xC2, 0xA2]);\nconsole.log(decoder.write(cent));\n\nconst euro = new Buffer([0xE2, 0x82, 0xAC]);\nconsole.log(decoder.write(euro));\n</code></pre>\n",
      "classes": [
        {
          "textRaw": "Class: StringDecoder",
          "type": "class",
          "name": "StringDecoder",
          "meta": {
            "added": [
              "v0.1.99"
            ]
          },
          "desc": "<p>Accepts a single argument, <code>encoding</code> which defaults to <code>&#39;utf8&#39;</code>.</p>\n",
          "methods": [
            {
              "textRaw": "decoder.end()",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>Returns any trailing bytes that were left in the buffer.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "decoder.write(buffer)",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.99"
                ]
              },
              "desc": "<p>Returns a decoded string.</p>\n<!-- [end-include:string_decoder.md] -->\n<!-- [start-include:timers.md] -->\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "StringDecoder"
    },
    {
      "textRaw": "Timers",
      "name": "timers",
      "stability": 3,
      "stabilityText": "Locked",
      "desc": "<p>All of the timer functions are globals.  You do not need to <code>require()</code>\nthis module in order to use them.</p>\n",
      "methods": [
        {
          "textRaw": "clearImmediate(immediateObject)",
          "type": "method",
          "name": "clearImmediate",
          "meta": {
            "added": [
              "v0.9.1"
            ]
          },
          "desc": "<p>Stops an <code>immediateObject</code>, as created by [<code>setImmediate</code>][], from triggering.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "immediateObject"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearInterval(intervalObject)",
          "type": "method",
          "name": "clearInterval",
          "meta": {
            "added": [
              "v0.0.1"
            ]
          },
          "desc": "<p>Stops an <code>intervalObject</code>, as created by [<code>setInterval</code>][], from triggering.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "intervalObject"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearTimeout(timeoutObject)",
          "type": "method",
          "name": "clearTimeout",
          "meta": {
            "added": [
              "v0.0.1"
            ]
          },
          "desc": "<p>Prevents a <code>timeoutObject</code>, as created by [<code>setTimeout</code>][], from triggering.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "timeoutObject"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "ref()",
          "type": "method",
          "name": "ref",
          "meta": {
            "added": [
              "v0.9.1"
            ]
          },
          "desc": "<p>If a timer was previously <code>unref()</code>d, then <code>ref()</code> can be called to explicitly\nrequest the timer hold the program open. If the timer is already <code>ref</code>d calling\n<code>ref</code> again will have no effect.</p>\n<p>Returns the timer.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "setImmediate(callback[, arg][, ...])",
          "type": "method",
          "name": "setImmediate",
          "meta": {
            "added": [
              "v0.9.1"
            ]
          },
          "desc": "<p>Schedules &quot;immediate&quot; execution of <code>callback</code> after I/O events&#39;\ncallbacks and before timers set by [<code>setTimeout</code>][] and [<code>setInterval</code>][] are\ntriggered. Returns an <code>immediateObject</code> for possible use with\n[<code>clearImmediate</code>][]. Additional optional arguments may be passed to the\ncallback.</p>\n<p>Callbacks for immediates are queued in the order in which they were created.\nThe entire callback queue is processed every event loop iteration. If an\nimmediate is queued from inside an executing callback, that immediate won&#39;t fire\nuntil the next event loop iteration.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "setInterval(callback, delay[, arg][, ...])",
          "type": "method",
          "name": "setInterval",
          "meta": {
            "added": [
              "v0.0.1"
            ]
          },
          "desc": "<p>Schedules repeated execution of <code>callback</code> every <code>delay</code> milliseconds.\nReturns a <code>intervalObject</code> for possible use with [<code>clearInterval</code>][]. Additional\noptional arguments may be passed to the callback.</p>\n<p>To follow browser behavior, when using delays larger than 2147483647\nmilliseconds (approximately 25 days) or less than 1, Node.js will use 1 as the\n<code>delay</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "setTimeout(callback, delay[, arg][, ...])",
          "type": "method",
          "name": "setTimeout",
          "meta": {
            "added": [
              "v0.0.1"
            ]
          },
          "desc": "<p>Schedules execution of a one-time <code>callback</code> after <code>delay</code> milliseconds.\nReturns a <code>timeoutObject</code> for possible use with [<code>clearTimeout</code>][]. Additional\noptional arguments may be passed to the callback.</p>\n<p>The callback will likely not be invoked in precisely <code>delay</code> milliseconds.\nNode.js makes no guarantees about the exact timing of when callbacks will fire,\nnor of their ordering. The callback will be called as close as possible to the\ntime specified.</p>\n<p>To follow browser behavior, when using delays larger than 2147483647\nmilliseconds (approximately 25 days) or less than 1, the timeout is executed\nimmediately, as if the <code>delay</code> was set to 1.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "unref()",
          "type": "method",
          "name": "unref",
          "meta": {
            "added": [
              "v0.9.1"
            ]
          },
          "desc": "<p>The opaque value returned by [<code>setTimeout</code>][] and [<code>setInterval</code>][] also has the\nmethod <code>timer.unref()</code> which allows the creation of a timer that is active but\nif it is the only item left in the event loop, it won&#39;t keep the program\nrunning. If the timer is already <code>unref</code>d calling <code>unref</code> again will have no\neffect.</p>\n<p>In the case of [<code>setTimeout</code>][], <code>unref</code> creates a separate timer that will\nwakeup the event loop, creating too many of these may adversely effect event\nloop performance -- use wisely.</p>\n<p>Returns the timer.</p>\n<!-- [end-include:timers.md] -->\n<!-- [start-include:tls.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Timers"
    },
    {
      "textRaw": "TLS (SSL)",
      "name": "tls_(ssl)",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Use <code>require(&#39;tls&#39;)</code> to access this module.</p>\n<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or\nSecure Socket Layer: encrypted stream communication.</p>\n<p>TLS/SSL is a public/private key infrastructure. Each client and each\nserver must have a private key. A private key is created like this:</p>\n<pre><code>openssl genrsa -out ryans-key.pem 2048\n</code></pre><p>All servers and some clients need to have a certificate. Certificates are public\nkeys signed by a Certificate Authority or self-signed. The first step to\ngetting a certificate is to create a &quot;Certificate Signing Request&quot; (CSR)\nfile. This is done with:</p>\n<pre><code>openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem\n</code></pre><p>To create a self-signed certificate with the CSR, do this:</p>\n<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem\n</code></pre><p>Alternatively you can send the CSR to a Certificate Authority for signing.</p>\n<p>For Perfect Forward Secrecy, it is required to generate Diffie-Hellman\nparameters:</p>\n<pre><code>openssl dhparam -outform PEM -out dhparam.pem 2048\n</code></pre><p>To create .pfx or .p12, do this:</p>\n<pre><code>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \\\n      -certfile ca-cert.pem -out agent5.pfx\n</code></pre><ul>\n<li><code>in</code>:  certificate</li>\n<li><code>inkey</code>: private key</li>\n<li><code>certfile</code>: all CA certs concatenated in one file like\n<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>\n</ul>\n",
      "miscs": [
        {
          "textRaw": "Client-initiated renegotiation attack mitigation",
          "name": "Client-initiated renegotiation attack mitigation",
          "type": "misc",
          "desc": "<p>The TLS protocol lets the client renegotiate certain aspects of the TLS session.\nUnfortunately, session renegotiation requires a disproportional amount of\nserver-side resources, which makes it a potential vector for denial-of-service\nattacks.</p>\n<p>To mitigate this, renegotiations are limited to three times every 10 minutes. An\nerror is emitted on the [<code>tls.TLSSocket</code>][] instance when the threshold is\nexceeded. The limits are configurable:</p>\n<ul>\n<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p>\n</li>\n<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is\n10 minutes.</p>\n</li>\n</ul>\n<p>Don&#39;t change the defaults unless you know what you are doing.</p>\n<p>To test your server, connect to it with <code>openssl s_client -connect address:port</code>\nand tap <code>R&lt;CR&gt;</code> (that&#39;s the letter <code>R</code> followed by a carriage return) a few\ntimes.</p>\n"
        },
        {
          "textRaw": "NPN and SNI",
          "name": "NPN and SNI",
          "type": "misc",
          "desc": "<p>NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS\nhandshake extensions allowing you:</p>\n<ul>\n<li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li>\n<li>SNI - to use one TLS server for multiple hostnames with different SSL\ncertificates.</li>\n</ul>\n"
        },
        {
          "textRaw": "Perfect Forward Secrecy",
          "name": "Perfect Forward Secrecy",
          "type": "misc",
          "desc": "<p>The term &quot;[Forward Secrecy]&quot; or &quot;Perfect Forward Secrecy&quot; describes a feature of\nkey-agreement (i.e. key-exchange) methods. Practically it means that even if the\nprivate key of a (your) server is compromised, communication can only be\ndecrypted by eavesdroppers if they manage to obtain the key-pair specifically\ngenerated for each session.</p>\n<p>This is achieved by randomly generating a key pair for key-agreement on every\nhandshake (in contrary to the same key for all sessions). Methods implementing\nthis technique, thus offering Perfect Forward Secrecy, are called &quot;ephemeral&quot;.</p>\n<p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note\nthe character &quot;E&quot; appended to the traditional abbreviations):</p>\n<ul>\n<li>[DHE] - An ephemeral version of the Diffie Hellman key-agreement protocol.</li>\n<li>[ECDHE] - An ephemeral version of the Elliptic Curve Diffie Hellman\nkey-agreement protocol.</li>\n</ul>\n<p>Ephemeral methods may have some performance drawbacks, because key generation\nis expensive.</p>\n"
        }
      ],
      "modules": [
        {
          "textRaw": "Modifying the Default TLS Cipher suite",
          "name": "modifying_the_default_tls_cipher_suite",
          "desc": "<p>Node.js is built with a default suite of enabled and disabled TLS ciphers.\nCurrently, the default cipher suite is:</p>\n<pre><code>ECDHE-RSA-AES128-GCM-SHA256:\nECDHE-ECDSA-AES128-GCM-SHA256:\nECDHE-RSA-AES256-GCM-SHA384:\nECDHE-ECDSA-AES256-GCM-SHA384:\nDHE-RSA-AES128-GCM-SHA256:\nECDHE-RSA-AES128-SHA256:\nDHE-RSA-AES128-SHA256:\nECDHE-RSA-AES256-SHA384:\nDHE-RSA-AES256-SHA384:\nECDHE-RSA-AES256-SHA256:\nDHE-RSA-AES256-SHA256:\nHIGH:\n!aNULL:\n!eNULL:\n!EXPORT:\n!DES:\n!RC4:\n!MD5:\n!PSK:\n!SRP:\n!CAMELLIA\n</code></pre><p>This default can be overriden entirely using the <code>--tls-cipher-list</code> command\nline switch. For instance, the following makes\n<code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> the default TLS cipher suite:</p>\n<pre><code>node --tls-cipher-list=&quot;ECDHE-RSA-AES128-GCM-SHA256:!RC4&quot;\n</code></pre><p>Note that the default cipher suite included within Node.js has been carefully\nselected to reflect current security best practices and risk mitigation.\nChanging the default cipher suite can have a significant impact on the security\nof an application. The <code>--tls-cipher-list</code> switch should by used only if\nabsolutely necessary.</p>\n",
          "type": "module",
          "displayName": "Modifying the Default TLS Cipher suite"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: CryptoStream",
          "type": "class",
          "name": "CryptoStream",
          "stability": 0,
          "stabilityText": "Deprecated: Use [`tls.TLSSocket`][] instead.",
          "desc": "<p>This is an encrypted stream.</p>\n",
          "properties": [
            {
              "textRaw": "cryptoStream.bytesWritten",
              "name": "bytesWritten",
              "desc": "<p>A proxy to the underlying socket&#39;s bytesWritten accessor, this will return\nthe total bytes written to the socket, <em>including the TLS overhead</em>.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SecurePair",
          "type": "class",
          "name": "SecurePair",
          "desc": "<p>Returned by tls.createSecurePair.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'secure'",
              "type": "event",
              "name": "secure",
              "desc": "<p>The event is emitted from the SecurePair once the pair has successfully\nestablished a secure connection.</p>\n<p>Similarly to the checking for the server <code>&#39;secureConnection&#39;</code> event,\npair.cleartext.authorized should be checked to confirm whether the certificate\nused properly authorized.</p>\n",
              "params": []
            }
          ]
        },
        {
          "textRaw": "Class: tls.Server",
          "type": "class",
          "name": "tls.Server",
          "meta": {
            "added": [
              "v0.3.2"
            ]
          },
          "desc": "<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.\nInstead of accepting just raw TCP connections, this accepts encrypted\nconnections using TLS or SSL.</p>\n",
          "events": [
            {
              "textRaw": "Event: 'clientError'",
              "type": "event",
              "name": "clientError",
              "meta": {
                "added": [
                  "v0.11.11"
                ]
              },
              "desc": "<p><code>function (exception, tlsSocket) { }</code></p>\n<p>When a client connection emits an <code>&#39;error&#39;</code> event before a secure connection is\nestablished it will be forwarded here.</p>\n<p><code>tlsSocket</code> is the [<code>tls.TLSSocket</code>][] that the error originated from.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'newSession'",
              "type": "event",
              "name": "newSession",
              "meta": {
                "added": [
                  "v0.9.2"
                ]
              },
              "desc": "<p><code>function (sessionId, sessionData, callback) { }</code></p>\n<p>Emitted on creation of TLS session. May be used to store sessions in external\nstorage. <code>callback</code> must be invoked eventually, otherwise no data will be\nsent or received from secure connection.</p>\n<p>NOTE: adding this event listener will have an effect only on connections\nestablished after addition of event listener.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'OCSPRequest'",
              "type": "event",
              "name": "OCSPRequest",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "desc": "<p><code>function (certificate, issuer, callback) { }</code></p>\n<p>Emitted when the client sends a certificate status request. You could parse\nserver&#39;s current certificate to obtain OCSP url and certificate id, and after\nobtaining OCSP response invoke <code>callback(null, resp)</code>, where <code>resp</code> is a\n<code>Buffer</code> instance. Both <code>certificate</code> and <code>issuer</code> are a <code>Buffer</code>\nDER-representations of the primary and issuer&#39;s certificates. They could be used\nto obtain OCSP certificate id and OCSP endpoint url.</p>\n<p>Alternatively, <code>callback(null, null)</code> could be called, meaning that there is no\nOCSP response.</p>\n<p>Calling <code>callback(err)</code> will result in a <code>socket.destroy(err)</code> call.</p>\n<p>Typical flow:</p>\n<ol>\n<li>Client connects to server and sends <code>&#39;OCSPRequest&#39;</code> to it (via status info\nextension in ClientHello.)</li>\n<li>Server receives request and invokes <code>&#39;OCSPRequest&#39;</code> event listener if present</li>\n<li>Server grabs OCSP url from either <code>certificate</code> or <code>issuer</code> and performs an\n[OCSP request] to the CA</li>\n<li>Server receives <code>OCSPResponse</code> from CA and sends it back to client via\n<code>callback</code> argument</li>\n<li>Client validates the response and either destroys socket or performs a\nhandshake.</li>\n</ol>\n<p>NOTE: <code>issuer</code> could be null, if the certificate is self-signed or if the issuer\nis not in the root certificates list. (You could provide an issuer via <code>ca</code>\noption.)</p>\n<p>NOTE: adding this event listener will have an effect only on connections\nestablished after addition of event listener.</p>\n<p>NOTE: you may want to use some npm module like [asn1.js] to parse the\ncertificates.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'resumeSession'",
              "type": "event",
              "name": "resumeSession",
              "meta": {
                "added": [
                  "v0.9.2"
                ]
              },
              "desc": "<p><code>function (sessionId, callback) { }</code></p>\n<p>Emitted when client wants to resume previous TLS session. Event listener may\nperform lookup in external storage using given <code>sessionId</code>, and invoke\n<code>callback(null, sessionData)</code> once finished. If session can&#39;t be resumed\n(i.e. doesn&#39;t exist in storage) one may call <code>callback(null, null)</code>. Calling\n<code>callback(err)</code> will terminate incoming connection and destroy socket.</p>\n<p>NOTE: adding this event listener will have an effect only on connections\nestablished after addition of event listener.</p>\n<p>Here&#39;s an example for using TLS session resumption:</p>\n<pre><code class=\"lang-js\">var tlsSessionStore = {};\nserver.on(&#39;newSession&#39;, (id, data, cb) =&gt; {\n  tlsSessionStore[id.toString(&#39;hex&#39;)] = data;\n  cb();\n});\nserver.on(&#39;resumeSession&#39;, (id, cb) =&gt; {\n  cb(null, tlsSessionStore[id.toString(&#39;hex&#39;)] || null);\n});\n</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'secureConnection'",
              "type": "event",
              "name": "secureConnection",
              "meta": {
                "added": [
                  "v0.3.2"
                ]
              },
              "desc": "<p><code>function (tlsSocket) {}</code></p>\n<p>This event is emitted after a new connection has been successfully\nhandshaked. The argument is an instance of [<code>tls.TLSSocket</code>][]. It has all the\ncommon stream methods and events.</p>\n<p><code>socket.authorized</code> is a boolean value which indicates if the\nclient has verified by one of the supplied certificate authorities for the\nserver. If <code>socket.authorized</code> is false, then\n<code>socket.authorizationError</code> is set to describe how authorization\nfailed. Implied but worth mentioning: depending on the settings of the TLS\nserver, you unauthorized connections may be accepted.\n<code>socket.npnProtocol</code> is a string containing selected NPN protocol.\n<code>socket.servername</code> is a string containing servername requested with\nSNI.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "server.addContext(hostname, context)",
              "type": "method",
              "name": "addContext",
              "meta": {
                "added": [
                  "v0.5.3"
                ]
              },
              "desc": "<p>Add secure context that will be used if client request&#39;s SNI hostname is\nmatching passed <code>hostname</code> (wildcards can be used). <code>context</code> can contain\n<code>key</code>, <code>cert</code>, <code>ca</code> and/or any other properties from\n[<code>tls.createSecureContext()</code>][] <code>options</code> argument.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "hostname"
                    },
                    {
                      "name": "context"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Returns the bound address, the address family name and port of the\nserver as reported by the operating system.  See [<code>net.Server.address()</code>][] for\nmore information.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.3.2"
                ]
              },
              "desc": "<p>Stops the server from accepting new connections. This function is\nasynchronous, the server is finally closed when the server emits a <code>&#39;close&#39;</code>\nevent.  Optionally, you can pass a callback to listen for the <code>&#39;close&#39;</code> event.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.getTicketKeys()",
              "type": "method",
              "name": "getTicketKeys",
              "meta": {
                "added": [
                  "v3.0.0"
                ]
              },
              "desc": "<p>Returns <code>Buffer</code> instance holding the keys currently used for\nencryption/decryption of the [TLS Session Tickets][]</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.listen(port[, hostname][, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "v0.3.2"
                ]
              },
              "desc": "<p>Begin accepting connections on the specified <code>port</code> and <code>hostname</code>. If the\n<code>hostname</code> is omitted, the server will accept connections on any IPv6 address\n(<code>::</code>) when IPv6 is available, or any IPv4 address (<code>0.0.0.0</code>) otherwise. A\nport value of zero will assign a random port.</p>\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound.</p>\n<p>See <code>net.Server</code> for more information.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "hostname",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.setTicketKeys(keys)",
              "type": "method",
              "name": "setTicketKeys",
              "meta": {
                "added": [
                  "v3.0.0"
                ]
              },
              "desc": "<p>Updates the keys for encryption/decryption of the [TLS Session Tickets][].</p>\n<p>NOTE: the buffer should be 48 bytes long. See server <code>ticketKeys</code> option for\nmore information oh how it is going to be used.</p>\n<p>NOTE: the change is effective only for the future server connections. Existing\nor currently pending server connections will use previous keys.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "keys"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "server.connections",
              "name": "connections",
              "meta": {
                "added": [
                  "v0.3.2"
                ]
              },
              "desc": "<p>The number of concurrent connections on the server.</p>\n"
            },
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "meta": {
                "added": [
                  "v0.2.0"
                ]
              },
              "desc": "<p>Set this property to reject connections when the server&#39;s connection count\ngets high.</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: tls.TLSSocket",
          "type": "class",
          "name": "tls.TLSSocket",
          "meta": {
            "added": [
              "v0.11.4"
            ]
          },
          "desc": "<p>This is a wrapped version of [<code>net.Socket</code>][] that does transparent encryption\nof written data and all required TLS negotiation.</p>\n<p>This instance implements a duplex [Stream][] interfaces.  It has all the\ncommon stream methods and events.</p>\n<p>Methods that return TLS connection meta data (e.g.\n[<code>tls.TLSSocket.getPeerCertificate()</code>][] will only return data while the\nconnection is open.</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "new tls.TLSSocket(socket[, options])",
          "type": "method",
          "name": "TLSSocket",
          "meta": {
            "added": [
              "v0.11.4"
            ]
          },
          "desc": "<p>Construct a new TLSSocket object from existing TCP socket.</p>\n<p><code>socket</code> is an instance of [<code>net.Socket</code>][]</p>\n<p><code>options</code> is an optional object that might contain following properties:</p>\n<ul>\n<li><p><code>secureContext</code>: An optional TLS context object from\n [<code>tls.createSecureContext()</code>][]</p>\n</li>\n<li><p><code>isServer</code>: If <code>true</code> the TLS socket will be instantiated in server-mode.\nDefault: <code>false</code></p>\n</li>\n<li><p><code>server</code>: An optional [<code>net.Server</code>][] instance</p>\n</li>\n<li><p><code>requestCert</code>: Optional, see [<code>tls.createSecurePair()</code>][]</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: Optional, see [<code>tls.createSecurePair()</code>][]</p>\n</li>\n<li><p><code>NPNProtocols</code>: Optional, see [<code>tls.createServer()</code>][]</p>\n</li>\n<li><p><code>SNICallback</code>: Optional, see [<code>tls.createServer()</code>][]</p>\n</li>\n<li><p><code>session</code>: Optional, a <code>Buffer</code> instance, containing TLS session</p>\n</li>\n<li><p><code>requestOCSP</code>: Optional, if <code>true</code> the OCSP status request extension will\nbe added to the client hello, and an <code>&#39;OCSPResponse&#39;</code> event will be emitted\non the socket before establishing a secure communication</p>\n</li>\n</ul>\n",
          "events": [
            {
              "textRaw": "Event: 'OCSPResponse'",
              "type": "event",
              "name": "OCSPResponse",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "desc": "<p><code>function (response) { }</code></p>\n<p>This event will be emitted if <code>requestOCSP</code> option was set. <code>response</code> is a\nbuffer object, containing server&#39;s OCSP response.</p>\n<p>Traditionally, the <code>response</code> is a signed object from the server&#39;s CA that\ncontains information about server&#39;s certificate revocation status.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'secureConnect'",
              "type": "event",
              "name": "secureConnect",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>This event is emitted after a new connection has been successfully handshaked.\nThe listener will be called no matter if the server&#39;s certificate was\nauthorized or not. It is up to the user to test <code>tlsSocket.authorized</code>\nto see if the server certificate was signed by one of the specified CAs.\nIf <code>tlsSocket.authorized === false</code> then the error can be found in\n<code>tlsSocket.authorizationError</code>. Also if NPN was used you can check\n<code>tlsSocket.npnProtocol</code> for negotiated protocol.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "tlsSocket.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Returns the bound address, the address family name and port of the\nunderlying socket as reported by the operating system. Returns an\nobject with three properties, e.g.\n<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "tlsSocket.getCipher()",
              "type": "method",
              "name": "getCipher",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Returns an object representing the cipher name and the SSL/TLS\nprotocol version of the current connection.</p>\n<p>Example:\n{ name: &#39;AES256-SHA&#39;, version: &#39;TLSv1/SSLv3&#39; }</p>\n<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in\n<a href=\"https://www.openssl.org/docs/ssl/ssl.html#DEALING-WITH-CIPHERS\">https://www.openssl.org/docs/ssl/ssl.html#DEALING-WITH-CIPHERS</a> for more\ninformation.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "tlsSocket.getPeerCertificate([ detailed ])",
              "type": "method",
              "name": "getPeerCertificate",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Returns an object representing the peer&#39;s certificate. The returned object has\nsome properties corresponding to the field of the certificate. If <code>detailed</code>\nargument is <code>true</code> the full chain with <code>issuer</code> property will be returned,\nif <code>false</code> only the top certificate without <code>issuer</code> property.</p>\n<p>Example:</p>\n<pre><code>{ subject:\n   { C: &#39;UK&#39;,\n     ST: &#39;Acknack Ltd&#39;,\n     L: &#39;Rhys Jones&#39;,\n     O: &#39;node.js&#39;,\n     OU: &#39;Test TLS Certificate&#39;,\n     CN: &#39;localhost&#39; },\n  issuerInfo:\n   { C: &#39;UK&#39;,\n     ST: &#39;Acknack Ltd&#39;,\n     L: &#39;Rhys Jones&#39;,\n     O: &#39;node.js&#39;,\n     OU: &#39;Test TLS Certificate&#39;,\n     CN: &#39;localhost&#39; },\n  issuer:\n   { ... another certificate ... },\n  raw: &lt; RAW DER buffer &gt;,\n  valid_from: &#39;Nov 11 09:52:22 2009 GMT&#39;,\n  valid_to: &#39;Nov  6 09:52:22 2029 GMT&#39;,\n  fingerprint: &#39;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&#39;,\n  serialNumber: &#39;B9B0D332A1AA5635&#39; }\n</code></pre><p>If the peer does not provide a certificate, it returns <code>null</code> or an empty\nobject.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "detailed",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "tlsSocket.getSession()",
              "type": "method",
              "name": "getSession",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Return ASN.1 encoded TLS session or <code>undefined</code> if none was negotiated. Could\nbe used to speed up handshake establishment when reconnecting to the server.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "tlsSocket.getTLSTicket()",
              "type": "method",
              "name": "getTLSTicket",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>NOTE: Works only with client TLS sockets. Useful only for debugging, for\nsession reuse provide <code>session</code> option to [<code>tls.connect()</code>][].</p>\n<p>Return TLS session ticket or <code>undefined</code> if none was negotiated.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "tlsSocket.renegotiate(options, callback)",
              "type": "method",
              "name": "renegotiate",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>Initiate TLS renegotiation process. The <code>options</code> may contain the following\nfields: <code>rejectUnauthorized</code>, <code>requestCert</code> (See [<code>tls.createServer()</code>][] for\ndetails). <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>,\nonce the renegotiation is successfully completed.</p>\n<p>NOTE: Can be used to request peer&#39;s certificate after the secure connection\nhas been established.</p>\n<p>ANOTHER NOTE: When running as the server, socket will be destroyed\nwith an error after <code>handshakeTimeout</code> timeout.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "tlsSocket.setMaxSendFragment(size)",
              "type": "method",
              "name": "setMaxSendFragment",
              "meta": {
                "added": [
                  "v0.11.11"
                ]
              },
              "desc": "<p>Set maximum TLS fragment size (default and maximum value is: <code>16384</code>, minimum\nis: <code>512</code>). Returns <code>true</code> on success, <code>false</code> otherwise.</p>\n<p>Smaller fragment size decreases buffering latency on the client: large\nfragments are buffered by the TLS layer until the entire fragment is received\nand its integrity is verified; large fragments can span multiple roundtrips,\nand their processing can be delayed due to packet loss or reordering. However,\nsmaller fragments add extra TLS framing bytes and CPU overhead, which may\ndecrease overall server throughput.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "tlsSocket.authorized",
              "name": "authorized",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the\nspecified CAs, otherwise <code>false</code></p>\n"
            },
            {
              "textRaw": "tlsSocket.authorizationError",
              "name": "authorizationError",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>The reason why the peer&#39;s certificate has not been verified. This property\nbecomes available only when <code>tlsSocket.authorized === false</code>.</p>\n"
            },
            {
              "textRaw": "tlsSocket.encrypted",
              "name": "encrypted",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Static boolean value, always <code>true</code>. May be used to distinguish TLS sockets\nfrom regular ones.</p>\n"
            },
            {
              "textRaw": "tlsSocket.localPort",
              "name": "localPort",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>The numeric representation of the local port.</p>\n"
            },
            {
              "textRaw": "tlsSocket.localAddress",
              "name": "localAddress",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>The string representation of the local IP address.</p>\n"
            },
            {
              "textRaw": "tlsSocket.remoteAddress",
              "name": "remoteAddress",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>The string representation of the remote IP address. For example,\n<code>&#39;74.125.127.100&#39;</code> or <code>&#39;2001:4860:a005::68&#39;</code>.</p>\n"
            },
            {
              "textRaw": "tlsSocket.remoteFamily",
              "name": "remoteFamily",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>The string representation of the remote IP family. <code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>.</p>\n"
            },
            {
              "textRaw": "tlsSocket.remotePort",
              "name": "remotePort",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>The numeric representation of the remote port. For example, <code>443</code>.</p>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "socket"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.connect(options[, callback])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.11.3"
            ]
          },
          "desc": "<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or\n<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to\n<code>localhost</code>.) <code>options</code> should be an object which specifies:</p>\n<ul>\n<li><p><code>host</code>: Host the client should connect to</p>\n</li>\n<li><p><code>port</code>: Port the client should connect to</p>\n</li>\n<li><p><code>socket</code>: Establish secure connection on a given socket rather than\ncreating a new socket. If this option is specified, <code>host</code> and <code>port</code>\nare ignored.</p>\n</li>\n<li><p><code>path</code>: Creates unix socket connection to path. If this option is\nspecified, <code>host</code> and <code>port</code> are ignored.</p>\n</li>\n<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and\nCA certs of the client in PFX or PKCS12 format.</p>\n</li>\n<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in\nPEM format. (Could be an array of keys).</p>\n</li>\n<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>\n</li>\n<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in\nPEM format. (Could be an array of certs).</p>\n</li>\n<li><p><code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted\ncertificates in PEM format. If this is omitted several well known &quot;root&quot;\nCAs will be used, like VeriSign. These are used to authorize connections.</p>\n</li>\n<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by\n<code>:</code>. Uses the same default cipher suite as [<code>tls.createServer()</code>][].</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against\nthe list of supplied CAs. An <code>&#39;error&#39;</code> event is emitted if verification\nfails; <code>err.code</code> contains the OpenSSL error code. Default: <code>true</code>.</p>\n</li>\n<li><p><code>NPNProtocols</code>: An array of strings or <code>Buffer</code>s containing supported NPN\nprotocols. <code>Buffer</code>s should have following format: <code>0x05hello0x05world</code>,\nwhere first byte is next protocol name&#39;s length. (Passing array should\nusually be much simpler: <code>[&#39;hello&#39;, &#39;world&#39;]</code>.)</p>\n</li>\n<li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p>\n</li>\n<li><p><code>checkServerIdentity(servername, cert)</code>: Provide an override for checking\nserver&#39;s hostname against the certificate. Should return an error if verification\nfails. Return <code>undefined</code> if passing.</p>\n</li>\n<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force\nSSL version 3. The possible values depend on your installation of\nOpenSSL and are defined in the constant [SSL_METHODS][].</p>\n</li>\n<li><p><code>session</code>: A <code>Buffer</code> instance, containing TLS session.</p>\n</li>\n</ul>\n<p>The <code>callback</code> parameter will be added as a listener for the\n[<code>&#39;secureConnect&#39;</code>][] event.</p>\n<p><code>tls.connect()</code> returns a [<code>tls.TLSSocket</code>][] object.</p>\n<p>Here is an example of a client of echo server as described previously:</p>\n<pre><code class=\"lang-js\">const tls = require(&#39;tls&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  // These are necessary only if using the client certificate authentication\n  key: fs.readFileSync(&#39;client-key.pem&#39;),\n  cert: fs.readFileSync(&#39;client-cert.pem&#39;),\n\n  // This is necessary only if the server uses the self-signed certificate\n  ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ]\n};\n\nvar socket = tls.connect(8000, options, () =&gt; {\n  console.log(&#39;client connected&#39;,\n              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding(&#39;utf8&#39;);\nsocket.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\nsocket.on(&#39;end&#39;, () =&gt; {\n  server.close();\n});\n</code></pre>\n<p>Or</p>\n<pre><code class=\"lang-js\">const tls = require(&#39;tls&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  pfx: fs.readFileSync(&#39;client.pfx&#39;)\n};\n\nvar socket = tls.connect(8000, options, () =&gt; {\n  console.log(&#39;client connected&#39;,\n              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding(&#39;utf8&#39;);\nsocket.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\nsocket.on(&#39;end&#39;, () =&gt; {\n  server.close();\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.connect(port[, host][, options][, callback])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.11.3"
            ]
          },
          "desc": "<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or\n<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to\n<code>localhost</code>.) <code>options</code> should be an object which specifies:</p>\n<ul>\n<li><p><code>host</code>: Host the client should connect to</p>\n</li>\n<li><p><code>port</code>: Port the client should connect to</p>\n</li>\n<li><p><code>socket</code>: Establish secure connection on a given socket rather than\ncreating a new socket. If this option is specified, <code>host</code> and <code>port</code>\nare ignored.</p>\n</li>\n<li><p><code>path</code>: Creates unix socket connection to path. If this option is\nspecified, <code>host</code> and <code>port</code> are ignored.</p>\n</li>\n<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and\nCA certs of the client in PFX or PKCS12 format.</p>\n</li>\n<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in\nPEM format. (Could be an array of keys).</p>\n</li>\n<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>\n</li>\n<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in\nPEM format. (Could be an array of certs).</p>\n</li>\n<li><p><code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted\ncertificates in PEM format. If this is omitted several well known &quot;root&quot;\nCAs will be used, like VeriSign. These are used to authorize connections.</p>\n</li>\n<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by\n<code>:</code>. Uses the same default cipher suite as [<code>tls.createServer()</code>][].</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against\nthe list of supplied CAs. An <code>&#39;error&#39;</code> event is emitted if verification\nfails; <code>err.code</code> contains the OpenSSL error code. Default: <code>true</code>.</p>\n</li>\n<li><p><code>NPNProtocols</code>: An array of strings or <code>Buffer</code>s containing supported NPN\nprotocols. <code>Buffer</code>s should have following format: <code>0x05hello0x05world</code>,\nwhere first byte is next protocol name&#39;s length. (Passing array should\nusually be much simpler: <code>[&#39;hello&#39;, &#39;world&#39;]</code>.)</p>\n</li>\n<li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p>\n</li>\n<li><p><code>checkServerIdentity(servername, cert)</code>: Provide an override for checking\nserver&#39;s hostname against the certificate. Should return an error if verification\nfails. Return <code>undefined</code> if passing.</p>\n</li>\n<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force\nSSL version 3. The possible values depend on your installation of\nOpenSSL and are defined in the constant [SSL_METHODS][].</p>\n</li>\n<li><p><code>session</code>: A <code>Buffer</code> instance, containing TLS session.</p>\n</li>\n</ul>\n<p>The <code>callback</code> parameter will be added as a listener for the\n[<code>&#39;secureConnect&#39;</code>][] event.</p>\n<p><code>tls.connect()</code> returns a [<code>tls.TLSSocket</code>][] object.</p>\n<p>Here is an example of a client of echo server as described previously:</p>\n<pre><code class=\"lang-js\">const tls = require(&#39;tls&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  // These are necessary only if using the client certificate authentication\n  key: fs.readFileSync(&#39;client-key.pem&#39;),\n  cert: fs.readFileSync(&#39;client-cert.pem&#39;),\n\n  // This is necessary only if the server uses the self-signed certificate\n  ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ]\n};\n\nvar socket = tls.connect(8000, options, () =&gt; {\n  console.log(&#39;client connected&#39;,\n              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding(&#39;utf8&#39;);\nsocket.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\nsocket.on(&#39;end&#39;, () =&gt; {\n  server.close();\n});\n</code></pre>\n<p>Or</p>\n<pre><code class=\"lang-js\">const tls = require(&#39;tls&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  pfx: fs.readFileSync(&#39;client.pfx&#39;)\n};\n\nvar socket = tls.connect(8000, options, () =&gt; {\n  console.log(&#39;client connected&#39;,\n              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding(&#39;utf8&#39;);\nsocket.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\nsocket.on(&#39;end&#39;, () =&gt; {\n  server.close();\n});\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.createSecureContext(details)",
          "type": "method",
          "name": "createSecureContext",
          "meta": {
            "added": [
              "v0.11.13"
            ]
          },
          "desc": "<p>Creates a credentials object, with the optional details being a\ndictionary with keys:</p>\n<ul>\n<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private\nkey, certificate and CA certificates</li>\n<li><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in\nPEM format. To support multiple keys using different algorithms, an array\ncan be provided. It can either be a plain array of keys, or an array of\nobjects in the format <code>{pem: key, passphrase: passphrase}</code>. (Required)</li>\n<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>\n<li><code>cert</code> : A string holding the PEM encoded certificate</li>\n<li><code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted\ncertificates in PEM format. If this is omitted several well known &quot;root&quot;\nCAs will be used, like VeriSign. These are used to authorize connections.</li>\n<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs\n(Certificate Revocation List)</li>\n<li><code>ciphers</code>: A string describing the ciphers to use or exclude.\nConsult\n<a href=\"https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT\">https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT</a>\nfor details on the format.</li>\n<li><code>honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences\ninstead of the client preferences. For further details see <code>tls</code> module\ndocumentation.</li>\n</ul>\n<p>If no &#39;ca&#39; details are given, then Node.js will use the default\npublicly trusted list of CAs as given in\n<a href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "details"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])",
          "type": "method",
          "name": "createSecurePair",
          "desc": "<p>Creates a new secure pair object with two streams, one of which reads/writes\nencrypted data, and one reads/writes cleartext data.\nGenerally the encrypted one is piped to/from an incoming encrypted data stream,\nand the cleartext one is used as a replacement for the initial encrypted stream.</p>\n<ul>\n<li><p><code>credentials</code>: A secure context object from tls.createSecureContext( ... )</p>\n</li>\n<li><p><code>isServer</code>: A boolean indicating whether this tls connection should be\nopened as a server or a client.</p>\n</li>\n<li><p><code>requestCert</code>: A boolean indicating whether a server should request a\ncertificate from a connecting client. Only applies to server connections.</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should\nautomatically reject clients with invalid certificates. Only applies to\nservers with <code>requestCert</code> enabled.</p>\n</li>\n<li><p><code>options</code>: An object with common SSL options. See [<code>tls.TLSSocket</code>][].</p>\n</li>\n</ul>\n<p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and\n<code>encrypted</code> stream properties.</p>\n<p>NOTE: <code>cleartext</code> has the same APIs as [<code>tls.TLSSocket</code>][]</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "context",
                  "optional": true
                },
                {
                  "name": "isServer",
                  "optional": true
                },
                {
                  "name": "requestCert",
                  "optional": true
                },
                {
                  "name": "rejectUnauthorized",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.createServer(options[, secureConnectionListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "v0.3.2"
            ]
          },
          "desc": "<p>Creates a new [tls.Server][].  The <code>connectionListener</code> argument is\nautomatically set as a listener for the [<code>&#39;secureConnection&#39;</code>][] event.  The\n<code>options</code> object has these possibilities:</p>\n<ul>\n<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and\nCA certs of the server in PFX or PKCS12 format. (Mutually exclusive with\nthe <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p>\n</li>\n<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in\nPEM format. To support multiple keys using different algorithms, an array\ncan be provided. It can either be a plain array of keys, or an array of\nobjects in the format <code>{pem: key, passphrase: passphrase}</code>. (Required)</p>\n</li>\n<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>\n</li>\n<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in\nPEM format. (Could be an array of certs). (Required)</p>\n</li>\n<li><p><code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted\ncertificates in PEM format. If this is omitted several well known &quot;root&quot;\nCAs will be used, like VeriSign. These are used to authorize connections.</p>\n</li>\n<li><p><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate\nRevocation List)</p>\n</li>\n<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by\n<code>:</code>. The default cipher suite is:</p>\n<pre><code class=\"lang-js\">ECDHE-RSA-AES128-GCM-SHA256:\nECDHE-ECDSA-AES128-GCM-SHA256:\nECDHE-RSA-AES256-GCM-SHA384:\nECDHE-ECDSA-AES256-GCM-SHA384:\nDHE-RSA-AES128-GCM-SHA256:\nECDHE-RSA-AES128-SHA256:\nDHE-RSA-AES128-SHA256:\nECDHE-RSA-AES256-SHA384:\nDHE-RSA-AES256-SHA384:\nECDHE-RSA-AES256-SHA256:\nDHE-RSA-AES256-SHA256:\nHIGH:\n!aNULL:\n!eNULL:\n!EXPORT:\n!DES:\n!RC4:\n!MD5:\n!PSK:\n!SRP:\n!CAMELLIA\n</code></pre>\n<p>The default cipher suite prefers GCM ciphers for [Chrome&#39;s &#39;modern\ncryptography&#39; setting] and also prefers ECDHE and DHE ciphers for Perfect\nForward secrecy, while offering <em>some</em> backward compatibiltity.</p>\n<p>128 bit AES is preferred over 192 and 256 bit AES in light of [specific\nattacks affecting larger AES key sizes].</p>\n<p>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers\n(like Internet Explorer 6) aren&#39;t able to complete the handshake with the default\nconfiguration. If you absolutely must support these clients, the\n[TLS recommendations] may offer a compatible cipher suite. For more details\non the format, see the [OpenSSL cipher list format documentation].</p>\n</li>\n<li><p><code>ecdhCurve</code>: A string describing a named curve to use for ECDH key agreement\nor false to disable ECDH.</p>\n<p>Defaults to <code>prime256v1</code> (NIST P-256). Use [<code>crypto.getCurves()</code>][] to obtain\na list of available curve names. On recent releases,\n<code>openssl ecparam -list_curves</code> will also display the name and description of\neach available elliptic curve.</p>\n</li>\n<li><p><code>dhparam</code>: A string or <code>Buffer</code> containing Diffie Hellman parameters,\nrequired for Perfect Forward Secrecy. Use <code>openssl dhparam</code> to create it.\nIts key length should be greater than or equal to 1024 bits, otherwise\nit throws an error. It is strongly recommended to use 2048 bits or\nmore for stronger security. If omitted or invalid, it is silently\ndiscarded and DHE ciphers won&#39;t be available.</p>\n</li>\n<li><p><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not\nfinish in this many milliseconds. The default is 120 seconds.</p>\n<p>A <code>&#39;clientError&#39;</code> is emitted on the <code>tls.Server</code> object whenever a handshake\ntimes out.</p>\n</li>\n<li><p><code>honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences\ninstead of the client preferences. Default: <code>true</code>.</p>\n</li>\n<li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from\nclients that connect and attempt to verify that certificate. Default:\n<code>false</code>.</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection\nwhich is not authorized with the list of supplied CAs. This option only\nhas an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p>\n</li>\n<li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols\nshould be ordered by their priority).</p>\n</li>\n<li><p><code>SNICallback(servername, cb)</code>: A function that will be called if client\nsupports SNI TLS extension. Two argument will be passed to it: <code>servername</code>,\nand <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where <code>ctx</code> is a\nSecureContext instance.\n(You can use <code>tls.createSecureContext(...)</code> to get proper\nSecureContext). If <code>SNICallback</code> wasn&#39;t provided the default callback with\nhigh-level API will be used (see below).</p>\n</li>\n<li><p><code>sessionTimeout</code>: An integer specifying the seconds after which TLS\nsession identifiers and TLS session tickets created by the server are\ntimed out. See [SSL_CTX_set_timeout] for more details.</p>\n</li>\n<li><p><code>ticketKeys</code>: A 48-byte <code>Buffer</code> instance consisting of 16-byte prefix,\n16-byte hmac key, 16-byte AES key. You could use it to accept tls session\ntickets on multiple instances of tls server.</p>\n<p>NOTE: Automatically shared between <code>cluster</code> module workers.</p>\n</li>\n<li><p><code>sessionIdContext</code>: A string containing an opaque identifier for session\nresumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value\ngenerated from command-line. (In FIPS mode a truncated SHA1 hash is\nused instead.) Otherwise, the default is not provided.</p>\n</li>\n<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force\nSSL version 3. The possible values depend on your installation of\nOpenSSL and are defined in the constant [SSL_METHODS][].</p>\n</li>\n</ul>\n<p>Here is a simple example echo server:</p>\n<pre><code class=\"lang-js\">const tls = require(&#39;tls&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  key: fs.readFileSync(&#39;server-key.pem&#39;),\n  cert: fs.readFileSync(&#39;server-cert.pem&#39;),\n\n  // This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n  // This is necessary only if the client uses the self-signed certificate.\n  ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ]\n};\n\nvar server = tls.createServer(options, (socket) =&gt; {\n  console.log(&#39;server connected&#39;,\n              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  socket.write(&#39;welcome!\\n&#39;);\n  socket.setEncoding(&#39;utf8&#39;);\n  socket.pipe(socket);\n});\nserver.listen(8000, () =&gt; {\n  console.log(&#39;server bound&#39;);\n});\n</code></pre>\n<p>Or</p>\n<pre><code class=\"lang-js\">const tls = require(&#39;tls&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst options = {\n  pfx: fs.readFileSync(&#39;server.pfx&#39;),\n\n  // This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n};\n\nvar server = tls.createServer(options, (socket) =&gt; {\n  console.log(&#39;server connected&#39;,\n              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  socket.write(&#39;welcome!\\n&#39;);\n  socket.setEncoding(&#39;utf8&#39;);\n  socket.pipe(socket);\n});\nserver.listen(8000, () =&gt; {\n  console.log(&#39;server bound&#39;);\n});\n</code></pre>\n<p>You can test this server by connecting to it with <code>openssl s_client</code>:</p>\n<pre><code>openssl s_client -connect 127.0.0.1:8000\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "secureConnectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.getCiphers()",
          "type": "method",
          "name": "getCiphers",
          "meta": {
            "added": [
              "v0.10.2"
            ]
          },
          "desc": "<p>Returns an array with the names of the supported SSL ciphers.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">var ciphers = tls.getCiphers();\nconsole.log(ciphers); // [&#39;AES128-SHA&#39;, &#39;AES256-SHA&#39;, ...]\n</code></pre>\n<!-- [end-include:tls.md] -->\n<!-- [start-include:tty.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "TLS (SSL)"
    },
    {
      "textRaw": "TTY",
      "name": "tty",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>tty</code> module houses the <code>tty.ReadStream</code> and <code>tty.WriteStream</code> classes. In\nmost cases, you will not need to use this module directly.</p>\n<p>When Node.js detects that it is being run inside a TTY context, then <code>process.stdin</code>\nwill be a <code>tty.ReadStream</code> instance and <code>process.stdout</code> will be\na <code>tty.WriteStream</code> instance. The preferred way to check if Node.js is being run\nin a TTY context is to check <code>process.stdout.isTTY</code>:</p>\n<pre><code>$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;\ntrue\n$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat\nfalse\n</code></pre>",
      "classes": [
        {
          "textRaw": "Class: ReadStream",
          "type": "class",
          "name": "ReadStream",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>A <code>net.Socket</code> subclass that represents the readable portion of a tty. In normal\ncircumstances, <code>process.stdin</code> will be the only <code>tty.ReadStream</code> instance in any\nNode.js program (only when <code>isatty(0)</code> is true).</p>\n",
          "properties": [
            {
              "textRaw": "rs.isRaw",
              "name": "isRaw",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p>A <code>Boolean</code> that is initialized to <code>false</code>. It represents the current &quot;raw&quot; state\nof the <code>tty.ReadStream</code> instance.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "rs.setRawMode(mode)",
              "type": "method",
              "name": "setRawMode",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p><code>mode</code> should be <code>true</code> or <code>false</code>. This sets the properties of the\n<code>tty.ReadStream</code> to act either as a raw device or default. <code>isRaw</code> will be set\nto the resulting mode.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "mode"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: WriteStream",
          "type": "class",
          "name": "WriteStream",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>A <code>net.Socket</code> subclass that represents the writable portion of a tty. In normal\ncircumstances, <code>process.stdout</code> will be the only <code>tty.WriteStream</code> instance\never created (and only when <code>isatty(1)</code> is true).</p>\n",
          "events": [
            {
              "textRaw": "Event: 'resize'",
              "type": "event",
              "name": "resize",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p><code>function () {}</code></p>\n<p>Emitted by <code>refreshSize()</code> when either of the <code>columns</code> or <code>rows</code> properties\nhas changed.</p>\n<pre><code class=\"lang-js\">process.stdout.on(&#39;resize&#39;, () =&gt; {\n  console.log(&#39;screen size has changed!&#39;);\n  console.log(`${process.stdout.columns}x${process.stdout.rows}`);\n});\n</code></pre>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "ws.columns",
              "name": "columns",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p>A <code>Number</code> that gives the number of columns the TTY currently has. This property\ngets updated on <code>&#39;resize&#39;</code> events.</p>\n"
            },
            {
              "textRaw": "ws.rows",
              "name": "rows",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "desc": "<p>A <code>Number</code> that gives the number of rows the TTY currently has. This property\ngets updated on <code>&#39;resize&#39;</code> events.</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "tty.isatty(fd)",
          "type": "method",
          "name": "isatty",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns <code>true</code> or <code>false</code> depending on if the <code>fd</code> is associated with a\nterminal.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tty.setRawMode(mode)",
          "type": "method",
          "name": "setRawMode",
          "stability": 0,
          "stabilityText": "Deprecated: Use [tty.ReadStream#setRawMode][] (i.e. process.stdin.setRawMode) instead.",
          "desc": "<!-- [end-include:tty.md] -->\n<!-- [start-include:url.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "mode"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "TTY"
    },
    {
      "textRaw": "URL",
      "name": "url",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>This module has utilities for URL resolution and parsing.\nCall <code>require(&#39;url&#39;)</code> to use it.</p>\n",
      "modules": [
        {
          "textRaw": "URL Parsing",
          "name": "url_parsing",
          "desc": "<p>Parsed URL objects have some or all of the following fields, depending on\nwhether or not they exist in the URL string. Any parts that are not in the URL\nstring will not be in the parsed object. Examples are shown for the URL</p>\n<p><code>&#39;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#39;</code></p>\n<ul>\n<li><p><code>href</code>: The full URL that was originally parsed. Both the protocol and host are lowercased.</p>\n<p>  Example: <code>&#39;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#39;</code></p>\n</li>\n<li><p><code>protocol</code>: The request protocol, lowercased.</p>\n<p>  Example: <code>&#39;http:&#39;</code></p>\n</li>\n<li><p><code>slashes</code>: The protocol requires slashes after the colon.</p>\n<p>  Example: true or false</p>\n</li>\n<li><p><code>host</code>: The full lowercased host portion of the URL, including port\ninformation.</p>\n<p>  Example: <code>&#39;host.com:8080&#39;</code></p>\n</li>\n<li><p><code>auth</code>: The authentication information portion of a URL.</p>\n<p>  Example: <code>&#39;user:pass&#39;</code></p>\n</li>\n<li><p><code>hostname</code>: Just the lowercased hostname portion of the host.</p>\n<p>  Example: <code>&#39;host.com&#39;</code></p>\n</li>\n<li><p><code>port</code>: The port number portion of the host.</p>\n<p>  Example: <code>&#39;8080&#39;</code></p>\n</li>\n<li><p><code>pathname</code>: The path section of the URL, that comes after the host and\nbefore the query, including the initial slash if present. No decoding is\nperformed.</p>\n<p>  Example: <code>&#39;/p/a/t/h&#39;</code></p>\n</li>\n<li><p><code>search</code>: The &#39;query string&#39; portion of the URL, including the leading\nquestion mark.</p>\n<p>  Example: <code>&#39;?query=string&#39;</code></p>\n</li>\n<li><p><code>path</code>: Concatenation of <code>pathname</code> and <code>search</code>. No decoding is performed.</p>\n<p>  Example: <code>&#39;/p/a/t/h?query=string&#39;</code></p>\n</li>\n<li><p><code>query</code>: Either the &#39;params&#39; portion of the query string, or a\nquerystring-parsed object.</p>\n<p>  Example: <code>&#39;query=string&#39;</code> or <code>{&#39;query&#39;:&#39;string&#39;}</code></p>\n</li>\n<li><p><code>hash</code>: The &#39;fragment&#39; portion of the URL including the pound-sign.</p>\n<p>  Example: <code>&#39;#hash&#39;</code></p>\n</li>\n</ul>\n",
          "modules": [
            {
              "textRaw": "Escaped Characters",
              "name": "escaped_characters",
              "desc": "<p>Spaces (<code>&#39; &#39;</code>) and the following characters will be automatically escaped in the\nproperties of URL objects:</p>\n<pre><code>&lt; &gt; &quot; ` \\r \\n \\t { } | \\ ^ &#39;\n</code></pre><hr>\n<p>The following methods are provided by the URL module:</p>\n",
              "type": "module",
              "displayName": "Escaped Characters"
            }
          ],
          "type": "module",
          "displayName": "URL Parsing"
        }
      ],
      "methods": [
        {
          "textRaw": "url.format(urlObj)",
          "type": "method",
          "name": "format",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Take a parsed URL object, and return a formatted URL string.</p>\n<p>Here&#39;s how the formatting process works:</p>\n<ul>\n<li><code>href</code> will be ignored.</li>\n<li><code>path</code> will be ignored.</li>\n<li><code>protocol</code> is treated the same with or without the trailing <code>:</code> (colon).<ul>\n<li>The protocols <code>http</code>, <code>https</code>, <code>ftp</code>, <code>gopher</code>, <code>file</code> will be\npostfixed with <code>://</code> (colon-slash-slash) as long as <code>host</code>/<code>hostname</code> are present.</li>\n<li>All other protocols <code>mailto</code>, <code>xmpp</code>, <code>aim</code>, <code>sftp</code>, <code>foo</code>, etc will\nbe postfixed with <code>:</code> (colon).</li>\n</ul>\n</li>\n<li><code>slashes</code> set to <code>true</code> if the protocol requires <code>://</code> (colon-slash-slash)<ul>\n<li>Only needs to be set for protocols not previously listed as requiring\nslashes, such as <code>mongodb://localhost:8000/</code>, or if <code>host</code>/<code>hostname</code> are absent.</li>\n</ul>\n</li>\n<li><code>auth</code> will be used if present.</li>\n<li><code>hostname</code> will only be used if <code>host</code> is absent.</li>\n<li><code>port</code> will only be used if <code>host</code> is absent.</li>\n<li><code>host</code> will be used in place of <code>hostname</code> and <code>port</code>.</li>\n<li><code>pathname</code> is treated the same with or without the leading <code>/</code> (slash).</li>\n<li><code>query</code> (object; see <code>querystring</code>) will only be used if <code>search</code> is absent.</li>\n<li><code>search</code> will be used in place of <code>query</code>.<ul>\n<li>It is treated the same with or without the leading <code>?</code> (question mark).</li>\n</ul>\n</li>\n<li><code>hash</code> is treated the same with or without the leading <code>#</code> (pound sign, anchor).</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "urlObj"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "url.parse(urlStr[, parseQueryString][, slashesDenoteHost])",
          "type": "method",
          "name": "parse",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Take a URL string, and return an object.</p>\n<p>Pass <code>true</code> as the second argument to also parse the query string using the\n<code>querystring</code> module. If <code>true</code> then the <code>query</code> property will always be\nassigned an object, and the <code>search</code> property will always be a (possibly\nempty) string. If <code>false</code> then the <code>query</code> property will not be parsed or\ndecoded. Defaults to <code>false</code>.</p>\n<p>Pass <code>true</code> as the third argument to treat <code>//foo/bar</code> as\n<code>{ host: &#39;foo&#39;, pathname: &#39;/bar&#39; }</code> rather than\n<code>{ pathname: &#39;//foo/bar&#39; }</code>. Defaults to <code>false</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "urlStr"
                },
                {
                  "name": "parseQueryString",
                  "optional": true
                },
                {
                  "name": "slashesDenoteHost",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "url.resolve(from, to)",
          "type": "method",
          "name": "resolve",
          "meta": {
            "added": [
              "v0.1.25"
            ]
          },
          "desc": "<p>Take a base URL, and a href URL, and resolve them as a browser would for\nan anchor tag.  Examples:</p>\n<pre><code class=\"lang-js\">url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;)         // &#39;/one/two/four&#39;\nurl.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;)    // &#39;http://example.com/one&#39;\nurl.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;) // &#39;http://example.com/two&#39;\n</code></pre>\n<!-- [end-include:url.md] -->\n<!-- [start-include:util.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "URL"
    },
    {
      "textRaw": "util",
      "name": "util",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>These functions are in the module <code>&#39;util&#39;</code>. Use <code>require(&#39;util&#39;)</code> to\naccess them.</p>\n<p>The <code>util</code> module is primarily designed to support the needs of Node.js&#39;s\ninternal APIs.  Many of these utilities are useful for your own\nprograms.  If you find that these functions are lacking for your\npurposes, however, you are encouraged to write your own utilities.  We\nare not interested in any future additions to the <code>util</code> module that\nare unnecessary for Node.js&#39;s internal functionality.</p>\n",
      "methods": [
        {
          "textRaw": "util.debug(string)",
          "type": "method",
          "name": "debug",
          "stability": 0,
          "stabilityText": "Deprecated: Use [`console.error()`][] instead.",
          "desc": "<p>Deprecated predecessor of <code>console.error</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.debuglog(section)",
          "type": "method",
          "name": "debuglog",
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {Function} The logging function ",
                "name": "return",
                "type": "Function",
                "desc": "The logging function"
              },
              "params": [
                {
                  "textRaw": "`section` {String} The section of the program to be debugged ",
                  "name": "section",
                  "type": "String",
                  "desc": "The section of the program to be debugged"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "section"
                }
              ]
            }
          ],
          "desc": "<p>This is used to create a function which conditionally writes to stderr\nbased on the existence of a <code>NODE_DEBUG</code> environment variable.  If the\n<code>section</code> name appears in that environment variable, then the returned\nfunction will be similar to <code>console.error()</code>.  If not, then the\nreturned function is a no-op.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">var debuglog = util.debuglog(&#39;foo&#39;);\n\nvar bar = 123;\ndebuglog(&#39;hello from foo [%d]&#39;, bar);\n</code></pre>\n<p>If this program is run with <code>NODE_DEBUG=foo</code> in the environment, then\nit will output something like:</p>\n<pre><code>FOO 3245: hello from foo [123]\n</code></pre><p>where <code>3245</code> is the process id.  If it is not run with that\nenvironment variable set, then it will not print anything.</p>\n<p>You may separate multiple <code>NODE_DEBUG</code> environment variables with a\ncomma.  For example, <code>NODE_DEBUG=fs,net,tls</code>.</p>\n"
        },
        {
          "textRaw": "util.deprecate(function, string)",
          "type": "method",
          "name": "deprecate",
          "desc": "<p>Marks that a method should not be used any more.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nexports.puts = util.deprecate(() =&gt; {\n  for (var i = 0, len = arguments.length; i &lt; len; ++i) {\n    process.stdout.write(arguments[i] + &#39;\\n&#39;);\n  }\n}, &#39;util.puts: Use console.log instead&#39;);\n</code></pre>\n<p>It returns a modified function which warns once by default.</p>\n<p>If <code>--no-deprecation</code> is set then this function is a NO-OP.  Configurable\nat run-time through the <code>process.noDeprecation</code> boolean (only effective\nwhen set before a module is loaded.)</p>\n<p>If <code>--trace-deprecation</code> is set, a warning and a stack trace are logged\nto the console the first time the deprecated API is used.  Configurable\nat run-time through the <code>process.traceDeprecation</code> boolean.</p>\n<p>If <code>--throw-deprecation</code> is set then the application throws an exception\nwhen the deprecated API is used.  Configurable at run-time through the\n<code>process.throwDeprecation</code> boolean.</p>\n<p><code>process.throwDeprecation</code> takes precedence over <code>process.traceDeprecation</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "function"
                },
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.error([...])",
          "type": "method",
          "name": "error",
          "stability": 0,
          "stabilityText": "Deprecated: Use [`console.error()`][] instead.",
          "desc": "<p>Deprecated predecessor of <code>console.error</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.format(format[, ...])",
          "type": "method",
          "name": "format",
          "desc": "<p>Returns a formatted string using the first argument as a <code>printf</code>-like format.</p>\n<p>The first argument is a string that contains zero or more <em>placeholders</em>.\nEach placeholder is replaced with the converted value from its corresponding\nargument. Supported placeholders are:</p>\n<ul>\n<li><code>%s</code> - String.</li>\n<li><code>%d</code> - Number (both integer and float).</li>\n<li><code>%j</code> - JSON.  Replaced with the string <code>&#39;[Circular]&#39;</code> if the argument\ncontains circular references.</li>\n<li><code>%%</code> - single percent sign (<code>&#39;%&#39;</code>). This does not consume an argument.</li>\n</ul>\n<p>If the placeholder does not have a corresponding argument, the placeholder is\nnot replaced.</p>\n<pre><code class=\"lang-js\">util.format(&#39;%s:%s&#39;, &#39;foo&#39;); // &#39;foo:%s&#39;\n</code></pre>\n<p>If there are more arguments than placeholders, the extra arguments are\ncoerced to strings (for objects and symbols, <code>util.inspect()</code> is used)\nand then concatenated, delimited by a space.</p>\n<pre><code class=\"lang-js\">util.format(&#39;%s:%s&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;); // &#39;foo:bar baz&#39;\n</code></pre>\n<p>If the first argument is not a format string then <code>util.format()</code> returns\na string that is the concatenation of all its arguments separated by spaces.\nEach argument is converted to a string with <code>util.inspect()</code>.</p>\n<pre><code class=\"lang-js\">util.format(1, 2, 3); // &#39;1 2 3&#39;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "format"
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.inherits(constructor, superConstructor)",
          "type": "method",
          "name": "inherits",
          "desc": "<p>Inherit the prototype methods from one [constructor][] into another.  The\nprototype of <code>constructor</code> will be set to a new object created from\n<code>superConstructor</code>.</p>\n<p>As an additional convenience, <code>superConstructor</code> will be accessible\nthrough the <code>constructor.super_</code> property.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\nconst EventEmitter = require(&#39;events&#39;);\n\nfunction MyStream() {\n    EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit(&#39;data&#39;, data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof EventEmitter); // true\nconsole.log(MyStream.super_ === EventEmitter); // true\n\nstream.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`Received data: &quot;${data}&quot;`);\n})\nstream.write(&#39;It works!&#39;); // Received data: &quot;It works!&quot;\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "constructor"
                },
                {
                  "name": "superConstructor"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.inspect(object[, options])",
          "type": "method",
          "name": "inspect",
          "desc": "<p>Return a string representation of <code>object</code>, which is useful for debugging.</p>\n<p>An optional <em>options</em> object may be passed that alters certain aspects of the\nformatted string:</p>\n<ul>\n<li><p><code>showHidden</code> - if <code>true</code> then the object&#39;s non-enumerable and symbol\nproperties will be shown too. Defaults to <code>false</code>.</p>\n</li>\n<li><p><code>depth</code> - tells <code>inspect</code> how many times to recurse while formatting the\nobject. This is useful for inspecting large complicated objects. Defaults to\n<code>2</code>. To make it recurse indefinitely pass <code>null</code>.</p>\n</li>\n<li><p><code>colors</code> - if <code>true</code>, then the output will be styled with ANSI color codes.\nDefaults to <code>false</code>. Colors are customizable, see [Customizing\n<code>util.inspect</code> colors][].</p>\n</li>\n<li><p><code>customInspect</code> - if <code>false</code>, then custom <code>inspect(depth, opts)</code> functions\ndefined on the objects being inspected won&#39;t be called. Defaults to <code>true</code>.</p>\n</li>\n</ul>\n<p>Example of inspecting all properties of the <code>util</code> object:</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nconsole.log(util.inspect(util, { showHidden: true, depth: null }));\n</code></pre>\n<p>Values may supply their own custom <code>inspect(depth, opts)</code> functions, when\ncalled they receive the current depth in the recursive inspection, as well as\nthe options object passed to <code>util.inspect()</code>.</p>\n",
          "miscs": [
            {
              "textRaw": "Customizing `util.inspect` colors",
              "name": "Customizing `util.inspect` colors",
              "type": "misc",
              "desc": "<p>Color output (if enabled) of <code>util.inspect</code> is customizable globally\nvia <code>util.inspect.styles</code> and <code>util.inspect.colors</code> objects.</p>\n<p><code>util.inspect.styles</code> is a map assigning each style a color\nfrom <code>util.inspect.colors</code>.\nHighlighted styles and their default values are:</p>\n<ul>\n<li><code>number</code> (yellow)</li>\n<li><code>boolean</code> (yellow)</li>\n<li><code>string</code> (green)</li>\n<li><code>date</code> (magenta)</li>\n<li><code>regexp</code> (red)</li>\n<li><code>null</code> (bold)</li>\n<li><code>undefined</code> (grey)</li>\n<li><code>special</code> - only function at this time (cyan)</li>\n<li><code>name</code> (intentionally no styling)</li>\n</ul>\n<p>Predefined color codes are: <code>white</code>, <code>grey</code>, <code>black</code>, <code>blue</code>, <code>cyan</code>,\n<code>green</code>, <code>magenta</code>, <code>red</code> and <code>yellow</code>.\nThere are also <code>bold</code>, <code>italic</code>, <code>underline</code> and <code>inverse</code> codes.</p>\n"
            },
            {
              "textRaw": "Custom `inspect()` function on Objects",
              "name": "Custom `inspect()` function on Objects",
              "type": "misc",
              "desc": "<p>Objects also may define their own <code>inspect(depth)</code> function which <code>util.inspect()</code>\nwill invoke and use the result of when inspecting the object:</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nvar obj = { name: &#39;nate&#39; };\nobj.inspect = function(depth) {\n  return `{${this.name}}`;\n};\n\nutil.inspect(obj);\n  // &quot;{nate}&quot;\n</code></pre>\n<p>You may also return another Object entirely, and the returned String will be\nformatted according to the returned Object. This is similar to how\n<code>JSON.stringify()</code> works:</p>\n<pre><code class=\"lang-js\">var obj = { foo: &#39;this will not show up in the inspect() output&#39; };\nobj.inspect = function(depth) {\n  return { bar: &#39;baz&#39; };\n};\n\nutil.inspect(obj);\n  // &quot;{ bar: &#39;baz&#39; }&quot;\n</code></pre>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isArray(object)",
          "type": "method",
          "name": "isArray",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Internal alias for [<code>Array.isArray</code>][].</p>\n<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Array</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isBoolean(object)",
          "type": "method",
          "name": "isBoolean",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Boolean</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isBoolean(1)\n  // false\nutil.isBoolean(0)\n  // false\nutil.isBoolean(false)\n  // true\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isBuffer(object)",
          "type": "method",
          "name": "isBuffer",
          "stability": 0,
          "stabilityText": "Deprecated: Use [`Buffer.isBuffer()`][] instead.",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Buffer</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isBuffer({ length: 0 })\n  // false\nutil.isBuffer([])\n  // false\nutil.isBuffer(new Buffer(&#39;hello world&#39;))\n  // true\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isDate(object)",
          "type": "method",
          "name": "isDate",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Date</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isDate(new Date())\n  // true\nutil.isDate(Date())\n  // false (without &#39;new&#39; returns a String)\nutil.isDate({})\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isError(object)",
          "type": "method",
          "name": "isError",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is an [<code>Error</code>][]. Otherwise, returns\n<code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isError(new Error())\n  // true\nutil.isError(new TypeError())\n  // true\nutil.isError({ name: &#39;Error&#39;, message: &#39;an error occurred&#39; })\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isFunction(object)",
          "type": "method",
          "name": "isFunction",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Function</code>. Otherwise, returns\n<code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nfunction Foo() {}\nvar Bar = function() {};\n\nutil.isFunction({})\n  // false\nutil.isFunction(Foo)\n  // true\nutil.isFunction(Bar)\n  // true\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isNull(object)",
          "type": "method",
          "name": "isNull",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is strictly <code>null</code>. Otherwise, returns\n<code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isNull(0)\n  // false\nutil.isNull(undefined)\n  // false\nutil.isNull(null)\n  // true\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isNullOrUndefined(object)",
          "type": "method",
          "name": "isNullOrUndefined",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is <code>null</code> or <code>undefined</code>. Otherwise,\nreturns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isNullOrUndefined(0)\n  // false\nutil.isNullOrUndefined(undefined)\n  // true\nutil.isNullOrUndefined(null)\n  // true\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isNumber(object)",
          "type": "method",
          "name": "isNumber",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Number</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isNumber(false)\n  // false\nutil.isNumber(Infinity)\n  // true\nutil.isNumber(0)\n  // true\nutil.isNumber(NaN)\n  // true\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isObject(object)",
          "type": "method",
          "name": "isObject",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is strictly an <code>Object</code> <strong>and</strong> not a\n<code>Function</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isObject(5)\n  // false\nutil.isObject(null)\n  // false\nutil.isObject({})\n  // true\nutil.isObject(function(){})\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isPrimitive(object)",
          "type": "method",
          "name": "isPrimitive",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a primitive type. Otherwise, returns\n<code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isPrimitive(5)\n  // true\nutil.isPrimitive(&#39;foo&#39;)\n  // true\nutil.isPrimitive(false)\n  // true\nutil.isPrimitive(null)\n  // true\nutil.isPrimitive(undefined)\n  // true\nutil.isPrimitive({})\n  // false\nutil.isPrimitive(function() {})\n  // false\nutil.isPrimitive(/^$/)\n  // false\nutil.isPrimitive(new Date())\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isRegExp(object)",
          "type": "method",
          "name": "isRegExp",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>RegExp</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isRegExp(/some regexp/)\n  // true\nutil.isRegExp(new RegExp(&#39;another regexp&#39;))\n  // true\nutil.isRegExp({})\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isString(object)",
          "type": "method",
          "name": "isString",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>String</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isString(&#39;&#39;)\n  // true\nutil.isString(&#39;foo&#39;)\n  // true\nutil.isString(String(&#39;foo&#39;))\n  // true\nutil.isString(5)\n  // false\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "util.isSymbol(object)",
              "type": "method",
              "name": "isSymbol",
              "stability": 0,
              "stabilityText": "Deprecated",
              "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Symbol</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nutil.isSymbol(5)\n  // false\nutil.isSymbol(&#39;foo&#39;)\n  // false\nutil.isSymbol(Symbol(&#39;foo&#39;))\n  // true\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isUndefined(object)",
          "type": "method",
          "name": "isUndefined",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is <code>undefined</code>. Otherwise, returns <code>false</code>.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nvar foo;\nutil.isUndefined(5)\n  // false\nutil.isUndefined(foo)\n  // true\nutil.isUndefined(null)\n  // false\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.log(string)",
          "type": "method",
          "name": "log",
          "desc": "<p>Output with timestamp on <code>stdout</code>.</p>\n<pre><code>require(&#39;util&#39;).log(&#39;Timestamped message.&#39;);\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.print([...])",
          "type": "method",
          "name": "print",
          "stability": 0,
          "stabilityText": "Deprecated: Use [`console.log()`][] instead.",
          "desc": "<p>Deprecated predecessor of <code>console.log</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.pump(readableStream, writableStream[, callback])",
          "type": "method",
          "name": "pump",
          "stability": 0,
          "stabilityText": "Deprecated: Use readableStream.pipe(writableStream)",
          "desc": "<p>Deprecated predecessor of <code>stream.pipe()</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "readableStream"
                },
                {
                  "name": "writableStream"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.puts([...])",
          "type": "method",
          "name": "puts",
          "stability": 0,
          "stabilityText": "Deprecated: Use [`console.log()`][] instead.",
          "desc": "<p>Deprecated predecessor of <code>console.log</code>.</p>\n<!-- [end-include:util.md] -->\n<!-- [start-include:v8.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "util"
    },
    {
      "textRaw": "V8",
      "name": "v8",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>This module exposes events and interfaces specific to the version of [V8][]\nbuilt with Node.js.  These interfaces are subject to change by upstream and are\ntherefore not covered under the stability index.</p>\n",
      "methods": [
        {
          "textRaw": "getHeapStatistics()",
          "type": "method",
          "name": "getHeapStatistics",
          "meta": {
            "added": [
              "v1.0.0"
            ]
          },
          "desc": "<p>Returns an object with the following properties</p>\n<pre><code class=\"lang-js\">{\n  total_heap_size: 7326976,\n  total_heap_size_executable: 4194304,\n  total_physical_size: 7326976,\n  total_available_size: 1152656,\n  used_heap_size: 3476208,\n  heap_size_limit: 1535115264\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "setFlagsFromString(string)",
          "type": "method",
          "name": "setFlagsFromString",
          "meta": {
            "added": [
              "v1.0.0"
            ]
          },
          "desc": "<p>Set additional V8 command line flags.  Use with care; changing settings\nafter the VM has started may result in unpredictable behavior, including\ncrashes and data loss.  Or it may simply do nothing.</p>\n<p>The V8 options available for a version of Node.js may be determined by running\n<code>node --v8-options</code>.  An unofficial, community-maintained list of options\nand their effects is available [here][].</p>\n<p>Usage:</p>\n<pre><code class=\"lang-js\">// Print GC events to stdout for one minute.\nconst v8 = require(&#39;v8&#39;);\nv8.setFlagsFromString(&#39;--trace_gc&#39;);\nsetTimeout(function() { v8.setFlagsFromString(&#39;--notrace_gc&#39;); }, 60e3);\n</code></pre>\n<!-- [end-include:v8.md] -->\n<!-- [start-include:vm.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "V8"
    },
    {
      "textRaw": "Executing JavaScript",
      "name": "vm",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>You can access this module with:</p>\n<pre><code class=\"lang-js\">const vm = require(&#39;vm&#39;);\n</code></pre>\n<p>JavaScript code can be compiled and run immediately or compiled, saved, and run\nlater.</p>\n",
      "classes": [
        {
          "textRaw": "Class: Script",
          "type": "class",
          "name": "Script",
          "meta": {
            "added": [
              "v0.3.1"
            ]
          },
          "desc": "<p>A class for holding precompiled scripts, and running them in specific sandboxes.</p>\n",
          "methods": [
            {
              "textRaw": "new vm.Script(code, options)",
              "type": "method",
              "name": "Script",
              "meta": {
                "added": [
                  "v0.3.1"
                ]
              },
              "desc": "<p>Creating a new <code>Script</code> compiles <code>code</code> but does not run it. Instead, the\ncreated <code>vm.Script</code> object represents this compiled code. This script can be run\nlater many times using methods below. The returned script is not bound to any\nglobal object. It is bound before each run, just for that run.</p>\n<p>The options when creating a script are:</p>\n<ul>\n<li><code>filename</code>: allows you to control the filename that shows up in any stack\ntraces produced from this script.</li>\n<li><code>lineOffset</code>: allows you to add an offset to the line number that is\ndisplayed in stack traces</li>\n<li><code>columnOffset</code>: allows you to add an offset to the column number that is\ndisplayed in stack traces</li>\n<li><code>displayErrors</code>: whether or not to print any errors to stderr, with the\nline of code that caused them highlighted, before throwing an exception.\nApplies only to syntax errors compiling the code; errors while running the\ncode are controlled by the options to the script&#39;s methods.</li>\n<li><code>timeout</code>: a number of milliseconds to execute <code>code</code> before terminating\nexecution. If execution is terminated, an [<code>Error</code>][] will be thrown.</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "code"
                    },
                    {
                      "name": "options"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "script.runInContext(contextifiedSandbox[, options])",
              "type": "method",
              "name": "runInContext",
              "meta": {
                "added": [
                  "v0.3.1"
                ]
              },
              "desc": "<p>Similar to [<code>vm.runInContext()</code>][] but a method of a precompiled <code>Script</code>\nobject. <code>script.runInContext()</code> runs <code>script</code>&#39;s compiled code in\n<code>contextifiedSandbox</code> and returns the result. Running code does not have access\nto local scope.</p>\n<p><code>script.runInContext()</code> takes the same options as\n[<code>script.runInThisContext()</code>][].</p>\n<p>Example: compile code that increments a global variable and sets one, then\nexecute the code multiple times. These globals are contained in the sandbox.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\nconst vm = require(&#39;vm&#39;);\n\nvar sandbox = {\n  animal: &#39;cat&#39;,\n  count: 2\n};\n\nvar context = new vm.createContext(sandbox);\nvar script = new vm.Script(&#39;count += 1; name = &quot;kitty&quot;&#39;);\n\nfor (var i = 0; i &lt; 10; ++i) {\n  script.runInContext(context);\n}\n\nconsole.log(util.inspect(sandbox));\n\n// { animal: &#39;cat&#39;, count: 12, name: &#39;kitty&#39; }\n</code></pre>\n<p>Note that running untrusted code is a tricky business requiring great care.\n<code>script.runInContext()</code> is quite useful, but safely running untrusted code\nrequires a separate process.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "contextifiedSandbox"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "script.runInNewContext([sandbox][, options])",
              "type": "method",
              "name": "runInNewContext",
              "meta": {
                "added": [
                  "v0.3.1"
                ]
              },
              "desc": "<p>Similar to [<code>vm.runInNewContext()</code>][] but a method of a precompiled <code>Script</code>\nobject. <code>script.runInNewContext()</code> contextifies <code>sandbox</code> if passed or creates a\nnew contextified sandbox if it&#39;s omitted, and then runs <code>script</code>&#39;s compiled code\nwith the sandbox as the global object and returns the result. Running code does\nnot have access to local scope.</p>\n<p><code>script.runInNewContext()</code> takes the same options as\n[<code>script.runInThisContext()</code>][].</p>\n<p>Example: compile code that sets a global variable, then execute the code\nmultiple times in different contexts. These globals are set on and contained in\nthe sandboxes.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\nconst vm = require(&#39;vm&#39;);\n\nconst sandboxes = [{}, {}, {}];\n\nconst script = new vm.Script(&#39;globalVar = &quot;set&quot;&#39;);\n\nsandboxes.forEach((sandbox) =&gt; {\n  script.runInNewContext(sandbox);\n});\n\nconsole.log(util.inspect(sandboxes));\n\n// [{ globalVar: &#39;set&#39; }, { globalVar: &#39;set&#39; }, { globalVar: &#39;set&#39; }]\n</code></pre>\n<p>Note that running untrusted code is a tricky business requiring great care.\n<code>script.runInNewContext()</code> is quite useful, but safely running untrusted code\nrequires a separate process.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "sandbox",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "script.runInThisContext([options])",
              "type": "method",
              "name": "runInThisContext",
              "meta": {
                "added": [
                  "v0.3.1"
                ]
              },
              "desc": "<p>Similar to <a href=\"\"><code>vm.runInThisContext()</code></a> but a method of a precompiled <code>Script</code>\nobject. <code>script.runInThisContext()</code> runs <code>script</code>&#39;s compiled code and returns\nthe result. Running code does not have access to local scope, but does have\naccess to the current <code>global</code> object.</p>\n<p>Example of using <code>script.runInThisContext()</code> to compile code once and run it\nmultiple times:</p>\n<pre><code class=\"lang-js\">const vm = require(&#39;vm&#39;);\n\nglobal.globalVar = 0;\n\nconst script = new vm.Script(&#39;globalVar += 1&#39;, { filename: &#39;myfile.vm&#39; });\n\nfor (var i = 0; i &lt; 1000; ++i) {\n  script.runInThisContext();\n}\n\nconsole.log(globalVar);\n\n// 1000\n</code></pre>\n<p>The options for running a script are:</p>\n<ul>\n<li><code>filename</code>: allows you to control the filename that shows up in any stack\ntraces produced.</li>\n<li><code>lineOffset</code>: allows you to add an offset to the line number that is\ndisplayed in stack traces</li>\n<li><code>columnOffset</code>: allows you to add an offset to the column number that is\ndisplayed in stack traces</li>\n<li><code>displayErrors</code>: whether or not to print any errors to stderr, with the\nline of code that caused them highlighted, before throwing an exception.\nApplies only to runtime errors executing the code; it is impossible to create\na <code>Script</code> instance with syntax errors, as the constructor will throw.</li>\n<li><code>timeout</code>: a number of milliseconds to execute the script before terminating\nexecution. If execution is terminated, an [<code>Error</code>][] will be thrown.</li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "vm.createContext([sandbox])",
          "type": "method",
          "name": "createContext",
          "meta": {
            "added": [
              "v0.3.1"
            ]
          },
          "desc": "<p>If given a <code>sandbox</code> object, will &quot;contextify&quot; that sandbox so that it can be\nused in calls to [<code>vm.runInContext()</code>][] or [<code>script.runInContext()</code>][]. Inside\nscripts run as such, <code>sandbox</code> will be the global object, retaining all its\nexisting properties but also having the built-in objects and functions any\nstandard [global object][] has. Outside of scripts run by the vm module,\n<code>sandbox</code> will be unchanged.</p>\n<p>If not given a sandbox object, returns a new, empty contextified sandbox object\nyou can use.</p>\n<p>This function is useful for creating a sandbox that can be used to run multiple\nscripts, e.g. if you were emulating a web browser it could be used to create a\nsingle sandbox representing a window&#39;s global object, then run all <code>&lt;script&gt;</code>\ntags together inside that sandbox.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "sandbox",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.isContext(sandbox)",
          "type": "method",
          "name": "isContext",
          "meta": {
            "added": [
              "v0.11.7"
            ]
          },
          "desc": "<p>Returns whether or not a sandbox object has been contextified by calling\n[<code>vm.createContext()</code>][] on it.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "sandbox"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInContext(code, contextifiedSandbox[, options])",
          "type": "method",
          "name": "runInContext",
          "desc": "<p><code>vm.runInContext()</code> compiles <code>code</code>, then runs it in <code>contextifiedSandbox</code> and\nreturns the result. Running code does not have access to local scope. The\n<code>contextifiedSandbox</code> object must have been previously contextified via\n[<code>vm.createContext()</code>][]; it will be used as the global object for <code>code</code>.</p>\n<p><code>vm.runInContext()</code> takes the same options as [<code>vm.runInThisContext()</code>][].</p>\n<p>Example: compile and execute different scripts in a single existing context.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\nconst vm = require(&#39;vm&#39;);\n\nconst sandbox = { globalVar: 1 };\nvm.createContext(sandbox);\n\nfor (var i = 0; i &lt; 10; ++i) {\n    vm.runInContext(&#39;globalVar *= 2;&#39;, sandbox);\n}\nconsole.log(util.inspect(sandbox));\n\n// { globalVar: 1024 }\n</code></pre>\n<p>Note that running untrusted code is a tricky business requiring great care.\n<code>vm.runInContext()</code> is quite useful, but safely running untrusted code requires\na separate process.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "contextifiedSandbox"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInDebugContext(code)",
          "type": "method",
          "name": "runInDebugContext",
          "meta": {
            "added": [
              "v0.11.14"
            ]
          },
          "desc": "<p><code>vm.runInDebugContext()</code> compiles and executes <code>code</code> inside the V8 debug\ncontext. The primary use case is to get access to the V8 debug object:</p>\n<pre><code class=\"lang-js\">const vm = require(&#39;vm&#39;);\nconst Debug = vm.runInDebugContext(&#39;Debug&#39;);\nconsole.log(Debug.findScript(process.emit).name);  // &#39;events.js&#39;\nconsole.log(Debug.findScript(process.exit).name);  // &#39;internal/process.js&#39;\n</code></pre>\n<p>Note that the debug context and object are intrinsically tied to V8&#39;s debugger\nimplementation and may change (or even get removed) without prior warning.</p>\n<p>The debug object can also be exposed with the <code>--expose_debug_as=</code> switch.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInNewContext(code[, sandbox][, options])",
          "type": "method",
          "name": "runInNewContext",
          "meta": {
            "added": [
              "v0.3.1"
            ]
          },
          "desc": "<p><code>vm.runInNewContext()</code> compiles <code>code</code>, contextifies <code>sandbox</code> if passed or\ncreates a new contextified sandbox if it&#39;s omitted, and then runs the code with\nthe sandbox as the global object and returns the result.</p>\n<p><code>vm.runInNewContext()</code> takes the same options as [<code>vm.runInThisContext()</code>][].</p>\n<p>Example: compile and execute code that increments a global variable and sets a\nnew one. These globals are contained in the sandbox.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\nconst vm = require(&#39;vm&#39;);\n\nconst sandbox = {\n  animal: &#39;cat&#39;,\n  count: 2\n};\n\nvm.runInNewContext(&#39;count += 1; name = &quot;kitty&quot;&#39;, sandbox);\nconsole.log(util.inspect(sandbox));\n\n// { animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; }\n</code></pre>\n<p>Note that running untrusted code is a tricky business requiring great care.\n<code>vm.runInNewContext()</code> is quite useful, but safely running untrusted code requires\na separate process.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "sandbox",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInThisContext(code[, options])",
          "type": "method",
          "name": "runInThisContext",
          "meta": {
            "added": [
              "v0.3.1"
            ]
          },
          "desc": "<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it and returns the result. Running\ncode does not have access to local scope, but does have access to the current\n<code>global</code> object.</p>\n<p>Example of using <code>vm.runInThisContext()</code> and [<code>eval()</code>][] to run the same code:</p>\n<pre><code class=\"lang-js\">const vm = require(&#39;vm&#39;);\nvar localVar = &#39;initial value&#39;;\n\nconst vmResult = vm.runInThisContext(&#39;localVar = &quot;vm&quot;;&#39;);\nconsole.log(&#39;vmResult: &#39;, vmResult);\nconsole.log(&#39;localVar: &#39;, localVar);\n\nconst evalResult = eval(&#39;localVar = &quot;eval&quot;;&#39;);\nconsole.log(&#39;evalResult: &#39;, evalResult);\nconsole.log(&#39;localVar: &#39;, localVar);\n\n// vmResult: &#39;vm&#39;, localVar: &#39;initial value&#39;\n// evalResult: &#39;eval&#39;, localVar: &#39;eval&#39;\n</code></pre>\n<p><code>vm.runInThisContext()</code> does not have access to the local scope, so <code>localVar</code>\nis unchanged. [<code>eval()</code>][] does have access to the local scope, so <code>localVar</code> is\nchanged.</p>\n<p>In this way <code>vm.runInThisContext()</code> is much like an [indirect <code>eval()</code> call][],\ne.g. <code>(0,eval)(&#39;code&#39;)</code>. However, it also has the following additional options:</p>\n<ul>\n<li><code>filename</code>: allows you to control the filename that shows up in any stack\ntraces produced.</li>\n<li><code>lineOffset</code>: allows you to add an offset to the line number that is\ndisplayed in stack traces</li>\n<li><code>columnOffset</code>: allows you to add an offset to the column number that is\ndisplayed in stack traces</li>\n<li><code>displayErrors</code>: whether or not to print any errors to stderr, with the\nline of code that caused them highlighted, before throwing an exception.\nWill capture both syntax errors from compiling <code>code</code> and runtime errors\nthrown by executing the compiled code. Defaults to <code>true</code>.</li>\n<li><code>timeout</code>: a number of milliseconds to execute <code>code</code> before terminating\nexecution. If execution is terminated, an [<code>Error</code>][] will be thrown.</li>\n</ul>\n<h2>Example: Run a Server within a VM</h2>\n<p>The context of <code>.runInThisContext()</code> refers to the V8 context. The code passed\nto this VM context will have it&#39;s own isolated scope. To run a simple web server\nusing the <code>http</code> module, for instance, the code passed to the context must either\ncall <code>require(&#39;http&#39;)</code> on its own, or have a reference to the <code>http</code> module passed\nto it. For instance:</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\nconst vm = require(&#39;vm&#39;);\n\nlet code =\n`(function(require) {\n\n   const http = require(&#39;http&#39;);\n\n   http.createServer( (request, response) =&gt; {\n     response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n     response.end(&#39;Hello World\\\\n&#39;);\n   }).listen(8124);\n\n   console.log(&#39;Server running at http://127.0.0.1:8124/&#39;);\n })`;\n\n vm.runInThisContext(code)(require);\n</code></pre>\n<p><em>Note: <code>require()</code> in the above case shares the state with context it is passed\nfrom. This might introduce risks when unknown code is executed, e.g. altering\nobjects from the calling thread&#39;s context in unwanted ways. It is advisable to\nrun <code>vm</code> code in a separate process.</em></p>\n<!-- [end-include:vm.md] -->\n<!-- [start-include:zlib.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "vm"
    },
    {
      "textRaw": "Zlib",
      "name": "zlib",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>You can access this module with:</p>\n<pre><code>const zlib = require(&#39;zlib&#39;);\n</code></pre><p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and\nDeflateRaw/InflateRaw classes.  Each class takes the same options, and\nis a readable/writable Stream.</p>\n<h2>Examples</h2>\n<p>Compressing or decompressing a file can be done by piping an\nfs.ReadStream into a zlib stream, then into an fs.WriteStream.</p>\n<pre><code class=\"lang-js\">const gzip = zlib.createGzip();\nconst fs = require(&#39;fs&#39;);\nconst inp = fs.createReadStream(&#39;input.txt&#39;);\nconst out = fs.createWriteStream(&#39;input.txt.gz&#39;);\n\ninp.pipe(gzip).pipe(out);\n</code></pre>\n<p>Compressing or decompressing data in one step can be done by using\nthe convenience methods.</p>\n<pre><code class=\"lang-js\">const input = &#39;.................................&#39;;\nzlib.deflate(input, (err, buffer) =&gt; {\n  if (!err) {\n    console.log(buffer.toString(&#39;base64&#39;));\n  } else {\n    // handle error\n  }\n});\n\nconst buffer = new Buffer(&#39;eJzT0yMAAGTvBe8=&#39;, &#39;base64&#39;);\nzlib.unzip(buffer, (err, buffer) =&gt; {\n  if (!err) {\n    console.log(buffer.toString());\n  } else {\n    // handle error\n  }\n});\n</code></pre>\n<p>To use this module in an HTTP client or server, use the [accept-encoding][]\non requests, and the [content-encoding][] header on responses.</p>\n<p><strong>Note: these examples are drastically simplified to show\nthe basic concept.</strong>  Zlib encoding can be expensive, and the results\nought to be cached.  See [Memory Usage Tuning][] for more information\non the speed/memory/compression tradeoffs involved in zlib usage.</p>\n<pre><code class=\"lang-js\">// client request example\nconst zlib = require(&#39;zlib&#39;);\nconst http = require(&#39;http&#39;);\nconst fs = require(&#39;fs&#39;);\nconst request = http.get({ host: &#39;izs.me&#39;,\n                         path: &#39;/&#39;,\n                         port: 80,\n                         headers: { &#39;accept-encoding&#39;: &#39;gzip,deflate&#39; } });\nrequest.on(&#39;response&#39;, (response) =&gt; {\n  var output = fs.createWriteStream(&#39;izs.me_index.html&#39;);\n\n  switch (response.headers[&#39;content-encoding&#39;]) {\n    // or, just use zlib.createUnzip() to handle both cases\n    case &#39;gzip&#39;:\n      response.pipe(zlib.createGunzip()).pipe(output);\n      break;\n    case &#39;deflate&#39;:\n      response.pipe(zlib.createInflate()).pipe(output);\n      break;\n    default:\n      response.pipe(output);\n      break;\n  }\n});\n\n// server example\n// Running a gzip operation on every request is quite expensive.\n// It would be much more efficient to cache the compressed buffer.\nconst zlib = require(&#39;zlib&#39;);\nconst http = require(&#39;http&#39;);\nconst fs = require(&#39;fs&#39;);\nhttp.createServer((request, response) =&gt; {\n  var raw = fs.createReadStream(&#39;index.html&#39;);\n  var acceptEncoding = request.headers[&#39;accept-encoding&#39;];\n  if (!acceptEncoding) {\n    acceptEncoding = &#39;&#39;;\n  }\n\n  // Note: this is not a conformant accept-encoding parser.\n  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n  if (acceptEncoding.match(/\\bdeflate\\b/)) {\n    response.writeHead(200, { &#39;content-encoding&#39;: &#39;deflate&#39; });\n    raw.pipe(zlib.createDeflate()).pipe(response);\n  } else if (acceptEncoding.match(/\\bgzip\\b/)) {\n    response.writeHead(200, { &#39;content-encoding&#39;: &#39;gzip&#39; });\n    raw.pipe(zlib.createGzip()).pipe(response);\n  } else {\n    response.writeHead(200, {});\n    raw.pipe(response);\n  }\n}).listen(1337);\n</code></pre>\n",
      "miscs": [
        {
          "textRaw": "Memory Usage Tuning",
          "name": "Memory Usage Tuning",
          "type": "misc",
          "desc": "<p>From <code>zlib/zconf.h</code>, modified to node.js&#39;s usage:</p>\n<p>The memory requirements for deflate are (in bytes):</p>\n<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))\n</code></pre><p>that is: 128K for windowBits=15  +  128K for memLevel = 8\n(default values) plus a few kilobytes for small objects.</p>\n<p>For example, if you want to reduce\nthe default memory requirements from 256K to 128K, set the options to:</p>\n<pre><code>{ windowBits: 14, memLevel: 7 }\n</code></pre><p>Of course this will generally degrade compression (there&#39;s no free lunch).</p>\n<p>The memory requirements for inflate are (in bytes)</p>\n<pre><code>1 &lt;&lt; windowBits\n</code></pre><p>that is, 32K for windowBits=15 (default value) plus a few kilobytes\nfor small objects.</p>\n<p>This is in addition to a single internal output slab buffer of size\n<code>chunkSize</code>, which defaults to 16K.</p>\n<p>The speed of zlib compression is affected most dramatically by the\n<code>level</code> setting.  A higher level will result in better compression, but\nwill take longer to complete.  A lower level will result in less\ncompression, but will be much faster.</p>\n<p>In general, greater memory usage options will mean that node.js has to make\nfewer calls to zlib, since it&#39;ll be able to process more data in a\nsingle <code>write</code> operation.  So, this is another factor that affects the\nspeed, at the cost of memory usage.</p>\n"
        },
        {
          "textRaw": "Constants",
          "name": "Constants",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "type": "misc",
          "desc": "<p>All of the constants defined in zlib.h are also defined on\n<code>require(&#39;zlib&#39;)</code>.\nIn the normal course of operations, you will not need to ever set any of\nthese.  They are documented here so that their presence is not\nsurprising.  This section is taken almost directly from the\n[zlib documentation][].  See <a href=\"http://zlib.net/manual.html#Constants\">http://zlib.net/manual.html#Constants</a> for more\ndetails.</p>\n<p>Allowed flush values.</p>\n<ul>\n<li><code>zlib.Z_NO_FLUSH</code></li>\n<li><code>zlib.Z_PARTIAL_FLUSH</code></li>\n<li><code>zlib.Z_SYNC_FLUSH</code></li>\n<li><code>zlib.Z_FULL_FLUSH</code></li>\n<li><code>zlib.Z_FINISH</code></li>\n<li><code>zlib.Z_BLOCK</code></li>\n<li><code>zlib.Z_TREES</code></li>\n</ul>\n<p>Return codes for the compression/decompression functions. Negative\nvalues are errors, positive values are used for special but normal\nevents.</p>\n<ul>\n<li><code>zlib.Z_OK</code></li>\n<li><code>zlib.Z_STREAM_END</code></li>\n<li><code>zlib.Z_NEED_DICT</code></li>\n<li><code>zlib.Z_ERRNO</code></li>\n<li><code>zlib.Z_STREAM_ERROR</code></li>\n<li><code>zlib.Z_DATA_ERROR</code></li>\n<li><code>zlib.Z_MEM_ERROR</code></li>\n<li><code>zlib.Z_BUF_ERROR</code></li>\n<li><code>zlib.Z_VERSION_ERROR</code></li>\n</ul>\n<p>Compression levels.</p>\n<ul>\n<li><code>zlib.Z_NO_COMPRESSION</code></li>\n<li><code>zlib.Z_BEST_SPEED</code></li>\n<li><code>zlib.Z_BEST_COMPRESSION</code></li>\n<li><code>zlib.Z_DEFAULT_COMPRESSION</code></li>\n</ul>\n<p>Compression strategy.</p>\n<ul>\n<li><code>zlib.Z_FILTERED</code></li>\n<li><code>zlib.Z_HUFFMAN_ONLY</code></li>\n<li><code>zlib.Z_RLE</code></li>\n<li><code>zlib.Z_FIXED</code></li>\n<li><code>zlib.Z_DEFAULT_STRATEGY</code></li>\n</ul>\n<p>Possible values of the data_type field.</p>\n<ul>\n<li><code>zlib.Z_BINARY</code></li>\n<li><code>zlib.Z_TEXT</code></li>\n<li><code>zlib.Z_ASCII</code></li>\n<li><code>zlib.Z_UNKNOWN</code></li>\n</ul>\n<p>The deflate compression method (the only one supported in this version).</p>\n<ul>\n<li><code>zlib.Z_DEFLATED</code></li>\n</ul>\n<p>For initializing zalloc, zfree, opaque.</p>\n<ul>\n<li><code>zlib.Z_NULL</code></li>\n</ul>\n"
        },
        {
          "textRaw": "Class Options",
          "name": "Class Options",
          "meta": {
            "added": [
              "v0.11.1"
            ]
          },
          "type": "misc",
          "desc": "<p>Each class takes an options object.  All options are optional.</p>\n<p>Note that some options are only relevant when compressing, and are\nignored by the decompression classes.</p>\n<ul>\n<li>flush (default: <code>zlib.Z_NO_FLUSH</code>)</li>\n<li>chunkSize (default: 16*1024)</li>\n<li>windowBits</li>\n<li>level (compression only)</li>\n<li>memLevel (compression only)</li>\n<li>strategy (compression only)</li>\n<li>dictionary (deflate/inflate only, empty dictionary by default)</li>\n</ul>\n<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at\n<a href=\"http://zlib.net/manual.html#Advanced\">http://zlib.net/manual.html#Advanced</a> for more information on these.</p>\n"
        },
        {
          "textRaw": "Convenience Methods",
          "name": "Convenience Methods",
          "type": "misc",
          "desc": "<p>All of these take a [Buffer][] or string as the first argument, an optional second\nargument to supply options to the zlib classes and will call the supplied\ncallback with <code>callback(error, result)</code>.</p>\n<p>Every method has a <code>*Sync</code> counterpart, which accept the same arguments, but\nwithout a callback.</p>\n",
          "methods": [
            {
              "textRaw": "zlib.deflate(buf[, options], callback)",
              "type": "method",
              "name": "deflate",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Compress a Buffer or string with Deflate.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.deflateSync(buf[, options])",
              "type": "method",
              "name": "deflateSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Compress a Buffer or string with Deflate.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.deflateRaw(buf[, options], callback)",
              "type": "method",
              "name": "deflateRaw",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Compress a Buffer or string with DeflateRaw.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.deflateRawSync(buf[, options])",
              "type": "method",
              "name": "deflateRawSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Compress a Buffer or string with DeflateRaw.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.gunzip(buf[, options], callback)",
              "type": "method",
              "name": "gunzip",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with Gunzip.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.gunzipSync(buf[, options])",
              "type": "method",
              "name": "gunzipSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with Gunzip.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.gzip(buf[, options], callback)",
              "type": "method",
              "name": "gzip",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Compress a Buffer or string with Gzip.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.gzipSync(buf[, options])",
              "type": "method",
              "name": "gzipSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Compress a Buffer or string with Gzip.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.inflate(buf[, options], callback)",
              "type": "method",
              "name": "inflate",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with Inflate.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.inflateSync(buf[, options])",
              "type": "method",
              "name": "inflateSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with Inflate.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.inflateRaw(buf[, options], callback)",
              "type": "method",
              "name": "inflateRaw",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with InflateRaw.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.inflateRawSync(buf[, options])",
              "type": "method",
              "name": "inflateRawSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with InflateRaw.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.unzip(buf[, options], callback)",
              "type": "method",
              "name": "unzip",
              "meta": {
                "added": [
                  "v0.6.0"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with Unzip.</p>\n<!-- [end-include:zlib.md] -->\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.unzipSync(buf[, options])",
              "type": "method",
              "name": "unzipSync",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Decompress a Buffer or string with Unzip.</p>\n<!-- [end-include:zlib.md] -->\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Flushing",
          "name": "flushing",
          "desc": "<p>Calling [<code>.flush()</code>][] on a compression stream will make zlib return as much\noutput as currently possible. This may come at the cost of degraded compression\nquality, but can be useful when data needs to be available as soon as possible.</p>\n<p>In the following example, <code>flush()</code> is used to write a compressed partial\nHTTP response to the client:</p>\n<pre><code class=\"lang-js\">const zlib = require(&#39;zlib&#39;);\nconst http = require(&#39;http&#39;);\n\nhttp.createServer((request, response) =&gt; {\n  // For the sake of simplicity, the Accept-Encoding checks are omitted.\n  response.writeHead(200, { &#39;content-encoding&#39;: &#39;gzip&#39; });\n  const output = zlib.createGzip();\n  output.pipe(response);\n\n  setInterval(() =&gt; {\n    output.write(`The current time is ${Date()}\\n`, () =&gt; {\n      // The data has been passed to zlib, but the compression algorithm may\n      // have decided to buffer the data for more efficient compression.\n      // Calling .flush() will make the data available as soon as the client\n      // is ready to receive it.\n      output.flush();\n    });\n  }, 1000);\n}).listen(1337);\n</code></pre>\n",
          "type": "module",
          "displayName": "Flushing"
        }
      ],
      "meta": {
        "added": [
          "v0.5.8"
        ]
      },
      "classes": [
        {
          "textRaw": "Class: zlib.Deflate",
          "type": "class",
          "name": "zlib.Deflate",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Compress data using deflate.</p>\n"
        },
        {
          "textRaw": "Class: zlib.DeflateRaw",
          "type": "class",
          "name": "zlib.DeflateRaw",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Compress data using deflate, and do not append a zlib header.</p>\n"
        },
        {
          "textRaw": "Class: zlib.Gunzip",
          "type": "class",
          "name": "zlib.Gunzip",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Decompress a gzip stream.</p>\n"
        },
        {
          "textRaw": "Class: zlib.Gzip",
          "type": "class",
          "name": "zlib.Gzip",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Compress data using gzip.</p>\n"
        },
        {
          "textRaw": "Class: zlib.Inflate",
          "type": "class",
          "name": "zlib.Inflate",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Decompress a deflate stream.</p>\n"
        },
        {
          "textRaw": "Class: zlib.InflateRaw",
          "type": "class",
          "name": "zlib.InflateRaw",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Decompress a raw deflate stream.</p>\n"
        },
        {
          "textRaw": "Class: zlib.Unzip",
          "type": "class",
          "name": "zlib.Unzip",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting\nthe header.</p>\n"
        },
        {
          "textRaw": "Class: zlib.Zlib",
          "type": "class",
          "name": "zlib.Zlib",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Not exported by the <code>zlib</code> module. It is documented here because it is the base\nclass of the compressor/decompressor classes.</p>\n",
          "methods": [
            {
              "textRaw": "zlib.flush([kind], callback)",
              "type": "method",
              "name": "flush",
              "meta": {
                "added": [
                  "v0.5.8"
                ]
              },
              "desc": "<p><code>kind</code> defaults to <code>zlib.Z_FULL_FLUSH</code>.</p>\n<p>Flush pending data. Don&#39;t call this frivolously, premature flushes negatively\nimpact the effectiveness of the compression algorithm.</p>\n<p>Calling this only flushes data from the internal zlib state, and does not\nperform flushing of any kind on the streams level. Rather, it behaves like a\nnormal call to <code>.write()</code>, i.e. it will be queued up behind other pending\nwrites and will only produce output when data is being read from the stream.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "kind",
                      "optional": true
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.params(level, strategy, callback)",
              "type": "method",
              "name": "params",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>Dynamically update the compression level and compression strategy.\nOnly applicable to deflate algorithm.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "level"
                    },
                    {
                      "name": "strategy"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.reset()",
              "type": "method",
              "name": "reset",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p>Reset the compressor/decompressor to factory defaults. Only applicable to\nthe inflate and deflate algorithms.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "zlib.createDeflate([options])",
          "type": "method",
          "name": "createDeflate",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [Deflate][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createDeflateRaw([options])",
          "type": "method",
          "name": "createDeflateRaw",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [DeflateRaw][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createGunzip([options])",
          "type": "method",
          "name": "createGunzip",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [Gunzip][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createGzip([options])",
          "type": "method",
          "name": "createGzip",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [Gzip][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createInflate([options])",
          "type": "method",
          "name": "createInflate",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [Inflate][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createInflateRaw([options])",
          "type": "method",
          "name": "createInflateRaw",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [InflateRaw][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createUnzip([options])",
          "type": "method",
          "name": "createUnzip",
          "meta": {
            "added": [
              "v0.5.8"
            ]
          },
          "desc": "<p>Returns a new [Unzip][] object with an [options][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Zlib"
    }
  ],
  "stability": 2,
  "stabilityText": "Stable",
  "classes": [
    {
      "textRaw": "Class: Error",
      "type": "class",
      "name": "Error",
      "desc": "<p>A generic JavaScript <code>Error</code> object that does not denote any specific\ncircumstance of why the error occurred. <code>Error</code> objects capture a &quot;stack trace&quot;\ndetailing the point in the code at which the <code>Error</code> was instantiated, and may\nprovide a text description of the error.</p>\n<p>All errors generated by Node.js, including all System and JavaScript errors,\nwill either be instances of, or inherit from, the <code>Error</code> class.</p>\n",
      "methods": [
        {
          "textRaw": "Error.captureStackTrace(targetObject[, constructorOpt])",
          "type": "method",
          "name": "captureStackTrace",
          "desc": "<p>Creates a <code>.stack</code> property on <code>targetObject</code>, which when accessed returns\na string representing the location in the code at which\n<code>Error.captureStackTrace()</code> was called.</p>\n<pre><code class=\"lang-js\">const myObject = {};\nError.captureStackTrace(myObject);\nmyObject.stack  // similar to `new Error().stack`\n</code></pre>\n<p>The first line of the trace, instead of being prefixed with <code>ErrorType:\nmessage</code>, will be the result of calling <code>targetObject.toString()</code>.</p>\n<p>The optional <code>constructorOpt</code> argument accepts a function. If given, all frames\nabove <code>constructorOpt</code>, including <code>constructorOpt</code>, will be omitted from the\ngenerated stack trace.</p>\n<p>The <code>constructorOpt</code> argument is useful for hiding implementation\ndetails of error generation from an end user. For instance:</p>\n<pre><code class=\"lang-js\">function MyError() {\n  Error.captureStackTrace(this, MyError);\n}\n\n// Without passing MyError to captureStackTrace, the MyError\n// frame would show up in the .stack property. By passing\n// the constructor, we omit that frame and all frames above it.\nnew MyError().stack\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "targetObject"
                },
                {
                  "name": "constructorOpt",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "Error.stackTraceLimit",
          "name": "stackTraceLimit",
          "desc": "<p>The <code>Error.stackTraceLimit</code> property specifies the number of stack frames\ncollected by a stack trace (whether generated by <code>new Error().stack</code> or\n<code>Error.captureStackTrace(obj)</code>).</p>\n<p>The default value is <code>10</code> but may be set to any valid JavaScript number. Changes\nwill affect any stack trace captured <em>after</em> the value has been changed.</p>\n<p>If set to a non-number value, or set to a negative number, stack traces will\nnot capture any frames.</p>\n",
          "properties": [
            {
              "textRaw": "error.message",
              "name": "message",
              "desc": "<p>Returns the string description of error as set by calling <code>new Error(message)</code>.\nThe <code>message</code> passed to the constructor will also appear in the first line of\nthe stack trace of the <code>Error</code>, however changing this property after the\n<code>Error</code> object is created <em>may not</em> change the first line of the stack trace.</p>\n<pre><code class=\"lang-js\">const err = new Error(&#39;The message&#39;);\nconsole.log(err.message);\n  // Prints: The message\n</code></pre>\n"
            },
            {
              "textRaw": "error.stack",
              "name": "stack",
              "desc": "<p>Returns a string describing the point in the code at which the <code>Error</code> was\ninstantiated.</p>\n<p>For example:</p>\n<pre><code>Error: Things keep happening!\n   at /home/gbusey/file.js:525:2\n   at Frobnicator.refrobulate (/home/gbusey/business-logic.js:424:21)\n   at Actor.&lt;anonymous&gt; (/home/gbusey/actors.js:400:8)\n   at increaseSynergy (/home/gbusey/actors.js:701:6)\n</code></pre><p>The first line is formatted as <code>&lt;error class name&gt;: &lt;error message&gt;</code>, and\nis followed by a series of stack frames (each line beginning with &quot;at &quot;).\nEach frame describes a call site within the code that lead to the error being\ngenerated. V8 attempts to display a name for each function (by variable name,\nfunction name, or object method name), but occasionally it will not be able to\nfind a suitable name. If V8 cannot determine a name for the function, only\nlocation information will be displayed for that frame. Otherwise, the\ndetermined function name will be displayed with location information appended\nin parentheses.</p>\n<p>It is important to note that frames are <strong>only</strong> generated for JavaScript\nfunctions. If, for example, execution synchronously passes through a C++ addon\nfunction called <code>cheetahify</code>, which itself calls a JavaScript function, the\nframe representing the <code>cheetahify</code> call will <strong>not</strong> be present in the stack\ntraces:</p>\n<pre><code class=\"lang-js\">const cheetahify = require(&#39;./native-binding.node&#39;);\n\nfunction makeFaster() {\n  // cheetahify *synchronously* calls speedy.\n  cheetahify(function speedy() {\n    throw new Error(&#39;oh no!&#39;);\n  });\n}\n\nmakeFaster(); // will throw:\n  // /home/gbusey/file.js:6\n  //     throw new Error(&#39;oh no!&#39;);\n  //           ^\n  // Error: oh no!\n  //     at speedy (/home/gbusey/file.js:6:11)\n  //     at makeFaster (/home/gbusey/file.js:5:3)\n  //     at Object.&lt;anonymous&gt; (/home/gbusey/file.js:10:1)\n  //     at Module._compile (module.js:456:26)\n  //     at Object.Module._extensions..js (module.js:474:10)\n  //     at Module.load (module.js:356:32)\n  //     at Function.Module._load (module.js:312:12)\n  //     at Function.Module.runMain (module.js:497:10)\n  //     at startup (node.js:119:16)\n  //     at node.js:906:3\n</code></pre>\n<p>The location information will be one of:</p>\n<ul>\n<li><code>native</code>, if the frame represents a call internal to V8 (as in <code>[].forEach</code>).</li>\n<li><code>plain-filename.js:line:column</code>, if the frame represents a call internal\n to Node.js.</li>\n<li><code>/absolute/path/to/file.js:line:column</code>, if the frame represents a call in\na user program, or its dependencies.</li>\n</ul>\n<p>The string representing the stack trace is lazily generated when the\n<code>error.stack</code> property is <strong>accessed</strong>.</p>\n<p>The number of frames captured by the stack trace is bounded by the smaller of\n<code>Error.stackTraceLimit</code> or the number of available frames on the current event\nloop tick.</p>\n<p>System-level errors are generated as augmented <code>Error</code> instances, which are\ndetailed <a href=\"#errors_system_errors\">here</a>.</p>\n"
            }
          ]
        }
      ],
      "signatures": [
        {
          "params": [
            {
              "name": "message"
            }
          ],
          "desc": "<p>Creates a new <code>Error</code> object and sets the <code>error.message</code> property to the\nprovided text message. If an object is passed as <code>message</code>, the text message\nis generated by calling <code>message.toString()</code>. The <code>error.stack</code> property will\nrepresent the point in the code at which <code>new Error()</code> was called. Stack traces\nare dependent on [V8&#39;s stack trace API][]. Stack traces extend only to either\n(a) the beginning of  <em>synchronous code execution</em>, or (b) the number of frames\ngiven by the property <code>Error.stackTraceLimit</code>, whichever is smaller.</p>\n"
        }
      ]
    },
    {
      "textRaw": "Class: RangeError",
      "type": "class",
      "name": "RangeError",
      "desc": "<p>A subclass of <code>Error</code> that indicates that a provided argument was not within the\nset or range of acceptable values for a function; whether that is a numeric\nrange, or outside the set of options for a given function parameter.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">require(&#39;net&#39;).connect(-1);\n  // throws RangeError, port should be &gt; 0 &amp;&amp; &lt; 65536\n</code></pre>\n<p>Node.js will generate and throw <code>RangeError</code> instances <em>immediately</em> as a form\nof argument validation.</p>\n"
    },
    {
      "textRaw": "Class: ReferenceError",
      "type": "class",
      "name": "ReferenceError",
      "desc": "<p>A subclass of <code>Error</code> that indicates that an attempt is being made to access a\nvariable that is not defined. Such errors commonly indicate typos in code, or\nan otherwise broken program.</p>\n<p>While client code may generate and propagate these errors, in practice, only V8\nwill do so.</p>\n<pre><code class=\"lang-js\">doesNotExist;\n  // throws ReferenceError, doesNotExist is not a variable in this program.\n</code></pre>\n<p><code>ReferenceError</code> instances will have an <code>error.arguments</code> property whose value\nis an array containing a single element: a string representing the variable\nthat was not defined.</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\ntry {\n  doesNotExist;\n} catch(err) {\n  assert(err.arguments[0], &#39;doesNotExist&#39;);\n}\n</code></pre>\n<p>Unless an application is dynamically generating and running code,\n<code>ReferenceError</code> instances should always be considered a bug in the code\nor its dependencies.</p>\n"
    },
    {
      "textRaw": "Class: SyntaxError",
      "type": "class",
      "name": "SyntaxError",
      "desc": "<p>A subclass of <code>Error</code> that indicates that a program is not valid JavaScript.\nThese errors may only be generated and propagated as a result of code\nevaluation. Code evaluation may happen as a result of <code>eval</code>, <code>Function</code>,\n<code>require</code>, or [vm][]. These errors are almost always indicative of a broken\nprogram.</p>\n<pre><code class=\"lang-js\">try {\n  require(&#39;vm&#39;).runInThisContext(&#39;binary ! isNotOk&#39;);\n} catch(err) {\n  // err will be a SyntaxError\n}\n</code></pre>\n<p><code>SyntaxError</code> instances are unrecoverable in the context that created them â€“\nthey may only be caught by other contexts.</p>\n"
    },
    {
      "textRaw": "Class: TypeError",
      "type": "class",
      "name": "TypeError",
      "desc": "<p>A subclass of <code>Error</code> that indicates that a provided argument is not an\nallowable type. For example, passing a function to a parameter which expects a\nstring would be considered a TypeError.</p>\n<pre><code class=\"lang-js\">require(&#39;url&#39;).parse(() =&gt; { });\n  // throws TypeError, since it expected a string\n</code></pre>\n<p>Node.js will generate and throw <code>TypeError</code> instances <em>immediately</em> as a form\nof argument validation.</p>\n"
    }
  ],
  "globals": [
    {
      "textRaw": "Class: Buffer",
      "type": "global",
      "name": "Buffer",
      "desc": "<ul>\n<li>{Function}</li>\n</ul>\n<p>Used to handle binary data. See the [buffer section][].</p>\n"
    },
    {
      "textRaw": "clearImmediate(immediateObject)",
      "type": "global",
      "name": "clearImmediate",
      "desc": "<p>[<code>clearImmediate</code>] is described in the [timers][] section.</p>\n"
    },
    {
      "textRaw": "clearInterval(intervalObject)",
      "type": "global",
      "name": "clearInterval",
      "desc": "<p>[<code>clearInterval</code>] is described in the [timers][] section.</p>\n"
    },
    {
      "textRaw": "clearTimeout(timeoutObject)",
      "type": "global",
      "name": "clearTimeout",
      "desc": "<p>[<code>clearTimeout</code>] is described in the [timers][] section.</p>\n"
    },
    {
      "textRaw": "console",
      "name": "console",
      "type": "global",
      "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>Used to print to stdout and stderr. See the [<code>console</code>][] section.</p>\n"
    },
    {
      "textRaw": "global",
      "name": "global",
      "type": "global",
      "desc": "<ul>\n<li>{Object} The global namespace object.</li>\n</ul>\n<p>In browsers, the top-level scope is the global scope. That means that in\nbrowsers if you&#39;re in the global scope <code>var something</code> will define a global\nvariable. In Node.js this is different. The top-level scope is not the global\nscope; <code>var something</code> inside an Node.js module will be local to that module.</p>\n"
    },
    {
      "textRaw": "process",
      "name": "process",
      "type": "global",
      "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>The process object. See the [<code>process</code> object][] section.</p>\n"
    },
    {
      "textRaw": "setImmediate(callback[, arg][, ...])",
      "type": "global",
      "name": "setImmediate",
      "desc": "<p>[<code>setImmediate</code>] is described in the [timers][] section.</p>\n"
    },
    {
      "textRaw": "setInterval(callback, delay[, arg][, ...])",
      "type": "global",
      "name": "setInterval",
      "desc": "<p>[<code>setInterval</code>] is described in the [timers][] section.</p>\n"
    },
    {
      "textRaw": "setTimeout(callback, delay[, arg][, ...])",
      "type": "global",
      "name": "setTimeout",
      "desc": "<p>[<code>setTimeout</code>] is described in the [timers][] section.</p>\n<!-- [end-include:globals.md] -->\n<!-- [start-include:http.md] -->\n"
    },
    {
      "textRaw": "process",
      "name": "process",
      "type": "global",
      "desc": "<p>The <code>process</code> object is a global object and can be accessed from anywhere.\nIt is an instance of [<code>EventEmitter</code>][].</p>\n",
      "events": [
        {
          "textRaw": "Event: 'beforeExit'",
          "type": "event",
          "name": "beforeExit",
          "meta": {
            "added": [
              "v0.11.12"
            ]
          },
          "desc": "<p>This event is emitted when Node.js empties its event loop and has nothing else\nto schedule. Normally, Node.js exits when there is no work scheduled, but a\nlistener for <code>&#39;beforeExit&#39;</code> can make asynchronous calls, and cause Node.js to\ncontinue.</p>\n<p><code>&#39;beforeExit&#39;</code> is not emitted for conditions causing explicit termination, such\nas [<code>process.exit()</code>][] or uncaught exceptions, and should not be used as an\nalternative to the <code>&#39;exit&#39;</code> event unless the intention is to schedule more work.</p>\n",
          "params": []
        },
        {
          "textRaw": "Event: 'exit'",
          "type": "event",
          "name": "exit",
          "meta": {
            "added": [
              "v0.1.7"
            ]
          },
          "desc": "<p>Emitted when the process is about to exit. There is no way to prevent the\nexiting of the event loop at this point, and once all <code>&#39;exit&#39;</code> listeners have\nfinished running the process will exit. Therefore you <strong>must</strong> only perform\n<strong>synchronous</strong> operations in this handler. This is a good hook to perform\nchecks on the module&#39;s state (like for unit tests). The callback takes one\nargument, the code the process is exiting with.</p>\n<p>This event is only emitted when Node.js exits explicitly by process.exit() or\nimplicitly by the event loop draining.</p>\n<p>Example of listening for <code>&#39;exit&#39;</code>:</p>\n<pre><code class=\"lang-js\">process.on(&#39;exit&#39;, (code) =&gt; {\n  // do *NOT* do this\n  setTimeout(() =&gt; {\n    console.log(&#39;This will not run&#39;);\n  }, 0);\n  console.log(&#39;About to exit with code:&#39;, code);\n});\n</code></pre>\n",
          "params": []
        },
        {
          "textRaw": "Event: 'message'",
          "type": "event",
          "name": "message",
          "meta": {
            "added": [
              "v0.5.10"
            ]
          },
          "params": [],
          "desc": "<p>Messages sent by [<code>ChildProcess.send()</code>][] are obtained using the <code>&#39;message&#39;</code>\nevent on the child&#39;s process object.</p>\n"
        },
        {
          "textRaw": "Event: 'rejectionHandled'",
          "type": "event",
          "name": "rejectionHandled",
          "meta": {
            "added": [
              "v1.4.1"
            ]
          },
          "desc": "<p>Emitted whenever a Promise was rejected and an error handler was attached to it\n(for example with <code>.catch()</code>) later than after an event loop turn. This event\nis emitted with the following arguments:</p>\n<ul>\n<li><code>p</code> the promise that was previously emitted in an <code>&#39;unhandledRejection&#39;</code>\nevent, but which has now gained a rejection handler.</li>\n</ul>\n<p>There is no notion of a top level for a promise chain at which rejections can\nalways be handled. Being inherently asynchronous in nature, a promise rejection\ncan be handled at a future point in time â€” possibly much later than the\nevent loop turn it takes for the <code>&#39;unhandledRejection&#39;</code> event to be emitted.</p>\n<p>Another way of stating this is that, unlike in synchronous code where there is\nan ever-growing list of unhandled exceptions, with promises there is a\ngrowing-and-shrinking list of unhandled rejections. In synchronous code, the\n<code>&#39;uncaughtException&#39;</code> event tells you when the list of unhandled exceptions\ngrows. And in asynchronous code, the <code>&#39;unhandledRejection&#39;</code> event tells you\nwhen the list of unhandled rejections grows, while the <code>&#39;rejectionHandled&#39;</code>\nevent tells you when the list of unhandled rejections shrinks.</p>\n<p>For example using the rejection detection hooks in order to keep a map of all\nthe rejected promise reasons at a given time:</p>\n<pre><code class=\"lang-js\">const unhandledRejections = new Map();\nprocess.on(&#39;unhandledRejection&#39;, (reason, p) =&gt; {\n  unhandledRejections.set(p, reason);\n});\nprocess.on(&#39;rejectionHandled&#39;, (p) =&gt; {\n  unhandledRejections.delete(p);\n});\n</code></pre>\n<p>This map will grow and shrink over time, reflecting rejections that start\nunhandled and then become handled. You could record the errors in some error\nlog, either periodically (probably best for long-running programs, allowing\nyou to clear the map, which in the case of a very buggy program could grow\nindefinitely) or upon process exit (more convenient for scripts).</p>\n",
          "params": []
        },
        {
          "textRaw": "Event: 'uncaughtException'",
          "type": "event",
          "name": "uncaughtException",
          "meta": {
            "added": [
              "v0.1.18"
            ]
          },
          "desc": "<p>The <code>&#39;uncaughtException&#39;</code> event is emitted when an exception bubbles all the\nway back to the event loop. By default, Node.js handles such exceptions by\nprinting the stack trace to stderr and exiting. Adding a handler for the\n<code>&#39;uncaughtException&#39;</code> event overrides this default behavior.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">process.on(&#39;uncaughtException&#39;, (err) =&gt; {\n  console.log(`Caught exception: ${err}`);\n});\n\nsetTimeout(() =&gt; {\n  console.log(&#39;This will still run.&#39;);\n}, 500);\n\n// Intentionally cause an exception, but don&#39;t catch it.\nnonexistentFunc();\nconsole.log(&#39;This will not run.&#39;);\n</code></pre>\n",
          "modules": [
            {
              "textRaw": "Warning: Using `'uncaughtException'` correctly",
              "name": "warning:_using_`'uncaughtexception'`_correctly",
              "desc": "<p>Note that <code>&#39;uncaughtException&#39;</code> is a crude mechanism for exception handling\nintended to be used only as a last resort. The event <em>should not</em> be used as\nan equivalent to <code>On Error Resume Next</code>. Unhandled exceptions inherently mean\nthat an application is in an undefined state. Attempting to resume application\ncode without properly recovering from the exception can cause additional\nunforeseen and unpredictable issues.</p>\n<p>Exceptions thrown from within the event handler will not be caught. Instead the\nprocess will exit with a non-zero exit code and the stack trace will be printed.\nThis is to avoid infinite recursion.</p>\n<p>Attempting to resume normally after an uncaught exception can be similar to\npulling out of the power cord when upgrading a computer -- nine out of ten\ntimes nothing happens - but the 10th time, the system becomes corrupted.</p>\n<p>The correct use of <code>&#39;uncaughtException&#39;</code> is to perform synchronous cleanup\nof allocated resources (e.g. file descriptors, handles, etc) before shutting\ndown the process. It is not safe to resume normal operation after\n<code>&#39;uncaughtException&#39;</code>.</p>\n",
              "type": "module",
              "displayName": "Warning: Using `'uncaughtException'` correctly"
            }
          ],
          "params": []
        },
        {
          "textRaw": "Event: 'unhandledRejection'",
          "type": "event",
          "name": "unhandledRejection",
          "meta": {
            "added": [
              "v1.4.1"
            ]
          },
          "desc": "<p>Emitted whenever a <code>Promise</code> is rejected and no error handler is attached to\nthe promise within a turn of the event loop. When programming with promises\nexceptions are encapsulated as rejected promises. Such promises can be caught\nand handled using [<code>promise.catch(...)</code>][] and rejections are propagated through\na promise chain. This event is useful for detecting and keeping track of\npromises that were rejected whose rejections were not handled yet. This event\nis emitted with the following arguments:</p>\n<ul>\n<li><code>reason</code> the object with which the promise was rejected (usually an\n[<code>Error</code>][] instance).</li>\n<li><code>p</code> the promise that was rejected.</li>\n</ul>\n<p>Here is an example that logs every unhandled rejection to the console</p>\n<pre><code class=\"lang-js\">process.on(&#39;unhandledRejection&#39;, (reason, p) =&gt; {\n    console.log(&quot;Unhandled Rejection at: Promise &quot;, p, &quot; reason: &quot;, reason);\n    // application specific logging, throwing an error, or other logic here\n});\n</code></pre>\n<p>For example, here is a rejection that will trigger the <code>&#39;unhandledRejection&#39;</code>\nevent:</p>\n<pre><code class=\"lang-js\">somePromise.then((res) =&gt; {\n  return reportToUser(JSON.pasre(res)); // note the typo (`pasre`)\n}); // no `.catch` or `.then`\n</code></pre>\n<p>Here is an example of a coding pattern that will also trigger\n<code>&#39;unhandledRejection&#39;</code>:</p>\n<pre><code class=\"lang-js\">function SomeResource() {\n  // Initially set the loaded status to a rejected promise\n  this.loaded = Promise.reject(new Error(&#39;Resource not yet loaded!&#39;));\n}\n\nvar resource = new SomeResource();\n// no .catch or .then on resource.loaded for at least a turn\n</code></pre>\n<p>In cases like this, you may not want to track the rejection as a developer\nerror like you would for other <code>&#39;unhandledRejection&#39;</code> events. To address\nthis, you can either attach a dummy <code>.catch(() =&gt; { })</code> handler to\n<code>resource.loaded</code>, preventing the <code>&#39;unhandledRejection&#39;</code> event from being\nemitted, or you can use the [<code>&#39;rejectionHandled&#39;</code>][] event.</p>\n",
          "params": []
        },
        {
          "textRaw": "Signal Events",
          "name": "SIGINT, SIGHUP, etc.",
          "type": "event",
          "desc": "<p>Emitted when the processes receives a signal. See sigaction(2) for a list of\nstandard POSIX signal names such as <code>SIGINT</code>, <code>SIGHUP</code>, etc.</p>\n<p>Example of listening for <code>SIGINT</code>:</p>\n<pre><code class=\"lang-js\">// Start reading from stdin so we don&#39;t exit.\nprocess.stdin.resume();\n\nprocess.on(&#39;SIGINT&#39;, () =&gt; {\n  console.log(&#39;Got SIGINT.  Press Control-D to exit.&#39;);\n});\n</code></pre>\n<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal\nprograms.</p>\n<p>Note:</p>\n<ul>\n<li><code>SIGUSR1</code> is reserved by Node.js to start the debugger.  It&#39;s possible to\ninstall a listener but that won&#39;t stop the debugger from starting.</li>\n<li><code>SIGTERM</code> and <code>SIGINT</code> have default handlers on non-Windows platforms that\nresets the terminal mode before exiting with code <code>128 + signal number</code>. If\none of these signals has a listener installed, its default behavior will be\nremoved (Node.js will no longer exit).</li>\n<li><code>SIGPIPE</code> is ignored by default. It can have a listener installed.</li>\n<li><code>SIGHUP</code> is generated on Windows when the console window is closed, and on other\nplatforms under various similar conditions, see signal(7). It can have a\nlistener installed, however Node.js will be unconditionally terminated by\nWindows about 10 seconds later. On non-Windows platforms, the default\nbehavior of <code>SIGHUP</code> is to terminate Node.js, but once a listener has been\ninstalled its default behavior will be removed.</li>\n<li><code>SIGTERM</code> is not supported on Windows, it can be listened on.</li>\n<li><code>SIGINT</code> from the terminal is supported on all platforms, and can usually be\ngenerated with <code>CTRL+C</code> (though this may be configurable). It is not generated\nwhen terminal raw mode is enabled.</li>\n<li><code>SIGBREAK</code> is delivered on Windows when <code>CTRL+BREAK</code> is pressed, on\nnon-Windows\nplatforms it can be listened on, but there is no way to send or generate it.</li>\n<li><code>SIGWINCH</code> is delivered when the console has been resized. On Windows, this\nwill only happen on write to the console when the cursor is being moved, or\nwhen a readable tty is used in raw mode.</li>\n<li><code>SIGKILL</code> cannot have a listener installed, it will unconditionally terminate\nNode.js on all platforms.</li>\n<li><code>SIGSTOP</code> cannot have a listener installed.</li>\n</ul>\n<p>Note that Windows does not support sending Signals, but Node.js offers some\nemulation with <code>process.kill()</code>, and <code>child_process.kill()</code>. Sending signal <code>0</code>\ncan be used to test for the existence of a process. Sending <code>SIGINT</code>,\n<code>SIGTERM</code>, and <code>SIGKILL</code> cause the unconditional termination of the target\nprocess.</p>\n",
          "params": []
        }
      ],
      "modules": [
        {
          "textRaw": "Exit Codes",
          "name": "exit_codes",
          "desc": "<p>Node.js will normally exit with a <code>0</code> status code when no more async\noperations are pending.  The following status codes are used in other\ncases:</p>\n<ul>\n<li><code>1</code> <strong>Uncaught Fatal Exception</strong> - There was an uncaught exception,\nand it was not handled by a domain or an <code>&#39;uncaughtException&#39;</code> event\nhandler.</li>\n<li><code>2</code> - Unused (reserved by Bash for builtin misuse)</li>\n<li><code>3</code> <strong>Internal JavaScript Parse Error</strong> - The JavaScript source code\ninternal in Node.js&#39;s bootstrapping process caused a parse error.  This\nis extremely rare, and generally can only happen during development\nof Node.js itself.</li>\n<li><code>4</code> <strong>Internal JavaScript Evaluation Failure</strong> - The JavaScript\nsource code internal in Node.js&#39;s bootstrapping process failed to\nreturn a function value when evaluated.  This is extremely rare, and\ngenerally can only happen during development of Node.js itself.</li>\n<li><code>5</code> <strong>Fatal Error</strong> - There was a fatal unrecoverable error in V8.\nTypically a message will be printed to stderr with the prefix <code>FATAL\nERROR</code>.</li>\n<li><code>6</code> <strong>Non-function Internal Exception Handler</strong> - There was an\nuncaught exception, but the internal fatal exception handler\nfunction was somehow set to a non-function, and could not be called.</li>\n<li><code>7</code> <strong>Internal Exception Handler Run-Time Failure</strong> - There was an\nuncaught exception, and the internal fatal exception handler\nfunction itself threw an error while attempting to handle it.  This\ncan happen, for example, if a <code>process.on(&#39;uncaughtException&#39;)</code> or\n<code>domain.on(&#39;error&#39;)</code> handler throws an error.</li>\n<li><code>8</code> - Unused.  In previous versions of Node.js, exit code 8 sometimes\nindicated an uncaught exception.</li>\n<li><code>9</code> - <strong>Invalid Argument</strong> - Either an unknown option was specified,\nor an option requiring a value was provided without a value.</li>\n<li><code>10</code> <strong>Internal JavaScript Run-Time Failure</strong> - The JavaScript\nsource code internal in Node.js&#39;s bootstrapping process threw an error\nwhen the bootstrapping function was called.  This is extremely rare,\nand generally can only happen during development of Node.js itself.</li>\n<li><code>12</code> <strong>Invalid Debug Argument</strong> - The <code>--debug</code> and/or <code>--debug-brk</code>\noptions were set, but an invalid port number was chosen.</li>\n<li><code>&gt;128</code> <strong>Signal Exits</strong> - If Node.js receives a fatal signal such as\n<code>SIGKILL</code> or <code>SIGHUP</code>, then its exit code will be <code>128</code> plus the\nvalue of the signal code.  This is a standard Unix practice, since\nexit codes are defined to be 7-bit integers, and signal exits set\nthe high-order bit, and then contain the value of the signal code.</li>\n</ul>\n",
          "type": "module",
          "displayName": "Exit Codes"
        }
      ],
      "methods": [
        {
          "textRaw": "process.abort()",
          "type": "method",
          "name": "abort",
          "meta": {
            "added": [
              "v0.7.0"
            ]
          },
          "desc": "<p>This causes Node.js to emit an abort. This will cause Node.js to exit and\ngenerate a core file.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.chdir(directory)",
          "type": "method",
          "name": "chdir",
          "meta": {
            "added": [
              "v0.1.17"
            ]
          },
          "desc": "<p>Changes the current working directory of the process or throws an exception if that fails.</p>\n<pre><code class=\"lang-js\">console.log(`Starting directory: ${process.cwd()}`);\ntry {\n  process.chdir(&#39;/tmp&#39;);\n  console.log(`New directory: ${process.cwd()}`);\n}\ncatch (err) {\n  console.log(`chdir: ${err}`);\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "directory"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.cwd()",
          "type": "method",
          "name": "cwd",
          "meta": {
            "added": [
              "v0.1.8"
            ]
          },
          "desc": "<p>Returns the current working directory of the process.</p>\n<pre><code class=\"lang-js\">console.log(`Current directory: ${process.cwd()}`);\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.disconnect()",
          "type": "method",
          "name": "disconnect",
          "meta": {
            "added": [
              "v0.7.2"
            ]
          },
          "desc": "<p>Close the IPC channel to the parent process, allowing this child to exit\ngracefully once there are no other connections keeping it alive.</p>\n<p>Identical to the parent process&#39;s [<code>ChildProcess.disconnect()</code>][].</p>\n<p>If Node.js was not spawned with an IPC channel, <code>process.disconnect()</code> will be\nundefined.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.exit([code])",
          "type": "method",
          "name": "exit",
          "meta": {
            "added": [
              "v0.1.13"
            ]
          },
          "desc": "<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the\n&#39;success&#39; code <code>0</code>.</p>\n<p>To exit with a &#39;failure&#39; code:</p>\n<pre><code class=\"lang-js\">process.exit(1);\n</code></pre>\n<p>The shell that executed Node.js should see the exit code as 1.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.getegid()",
          "type": "method",
          "name": "getegid",
          "meta": {
            "added": [
              "v2.0.0"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the effective group identity of the process. (See getegid(2).)\nThis is the numerical group id, not the group name.</p>\n<pre><code class=\"lang-js\">if (process.getegid) {\n  console.log(`Current gid: ${process.getegid()}`);\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.geteuid()",
          "type": "method",
          "name": "geteuid",
          "meta": {
            "added": [
              "v2.0.0"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the effective user identity of the process. (See geteuid(2).)\nThis is the numerical userid, not the username.</p>\n<pre><code class=\"lang-js\">if (process.geteuid) {\n  console.log(`Current uid: ${process.geteuid()}`);\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.getgid()",
          "type": "method",
          "name": "getgid",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the group identity of the process. (See getgid(2).)\nThis is the numerical group id, not the group name.</p>\n<pre><code class=\"lang-js\">if (process.getgid) {\n  console.log(`Current gid: ${process.getgid()}`);\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.getgroups()",
          "type": "method",
          "name": "getgroups",
          "meta": {
            "added": [
              "v0.9.4"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Returns an array with the supplementary group IDs. POSIX leaves it unspecified\nif the effective group ID is included but Node.js ensures it always is.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.getuid()",
          "type": "method",
          "name": "getuid",
          "meta": {
            "added": [
              "v0.1.28"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Gets the user identity of the process. (See getuid(2).)\nThis is the numerical userid, not the username.</p>\n<pre><code class=\"lang-js\">if (process.getuid) {\n  console.log(`Current uid: ${process.getuid()}`);\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.hrtime()",
          "type": "method",
          "name": "hrtime",
          "meta": {
            "added": [
              "v0.7.6"
            ]
          },
          "desc": "<p>Returns the current high-resolution real time in a <code>[seconds, nanoseconds]</code>\ntuple Array. It is relative to an arbitrary time in the past. It is not\nrelated to the time of day and therefore not subject to clock drift. The\nprimary use is for measuring performance between intervals.</p>\n<p>You may pass in the result of a previous call to <code>process.hrtime()</code> to get\na diff reading, useful for benchmarks and measuring intervals:</p>\n<pre><code class=\"lang-js\">var time = process.hrtime();\n// [ 1800216, 25 ]\n\nsetTimeout(() =&gt; {\n  var diff = process.hrtime(time);\n  // [ 1, 552 ]\n\n  console.log(&#39;benchmark took %d nanoseconds&#39;, diff[0] * 1e9 + diff[1]);\n  // benchmark took 1000000527 nanoseconds\n}, 1000);\n</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.initgroups(user, extra_group)",
          "type": "method",
          "name": "initgroups",
          "meta": {
            "added": [
              "v0.9.4"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Reads /etc/group and initializes the group access list, using all groups of\nwhich the user is a member. This is a privileged operation, meaning you need\nto be root or have the <code>CAP_SETGID</code> capability.</p>\n<p><code>user</code> is a user name or user ID. <code>extra_group</code> is a group name or group ID.</p>\n<p>Some care needs to be taken when dropping privileges. Example:</p>\n<pre><code class=\"lang-js\">console.log(process.getgroups());         // [ 0 ]\nprocess.initgroups(&#39;bnoordhuis&#39;, 1000);   // switch user\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]\nprocess.setgid(1000);                     // drop root gid\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000 ]\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "user"
                },
                {
                  "name": "extra_group"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.kill(pid[, signal])",
          "type": "method",
          "name": "kill",
          "meta": {
            "added": [
              "v0.0.6"
            ]
          },
          "desc": "<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the\nstring describing the signal to send.  Signal names are strings like\n<code>SIGINT</code> or <code>SIGHUP</code>.  If omitted, the signal will be <code>SIGTERM</code>.\nSee [Signal Events][] and kill(2) for more information.</p>\n<p>Will throw an error if target does not exist, and as a special case, a signal\nof <code>0</code> can be used to test for the existence of a process. Windows platforms\nwill throw an error if the <code>pid</code> is used to kill a process group.</p>\n<p>Note that even though the name of this function is <code>process.kill</code>, it is really\njust a signal sender, like the <code>kill</code> system call.  The signal sent may do\nsomething other than kill the target process.</p>\n<p>Example of sending a signal to yourself:</p>\n<pre><code class=\"lang-js\">process.on(&#39;SIGHUP&#39;, () =&gt; {\n  console.log(&#39;Got SIGHUP signal.&#39;);\n});\n\nsetTimeout(() =&gt; {\n  console.log(&#39;Exiting.&#39;);\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, &#39;SIGHUP&#39;);\n</code></pre>\n<p>Note: When SIGUSR1 is received by Node.js it starts the debugger, see\n[Signal Events][].</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "pid"
                },
                {
                  "name": "signal",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.memoryUsage()",
          "type": "method",
          "name": "memoryUsage",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>Returns an object describing the memory usage of the Node.js process\nmeasured in bytes.</p>\n<pre><code class=\"lang-js\">const util = require(&#39;util&#39;);\n\nconsole.log(util.inspect(process.memoryUsage()));\n</code></pre>\n<p>This will generate:</p>\n<pre><code class=\"lang-js\">{ rss: 4935680,\n  heapTotal: 1826816,\n  heapUsed: 650472 }\n</code></pre>\n<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8&#39;s memory usage.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.nextTick(callback[, arg][, ...])",
          "type": "method",
          "name": "nextTick",
          "meta": {
            "added": [
              "v0.1.26"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Once the current event loop turn runs to completion, call the callback\nfunction.</p>\n<p>This is <em>not</em> a simple alias to [<code>setTimeout(fn, 0)</code>][], it&#39;s much more\nefficient.  It runs before any additional I/O events (including\ntimers) fire in subsequent ticks of the event loop.</p>\n<pre><code class=\"lang-js\">console.log(&#39;start&#39;);\nprocess.nextTick(() =&gt; {\n  console.log(&#39;nextTick callback&#39;);\n});\nconsole.log(&#39;scheduled&#39;);\n// Output:\n// start\n// scheduled\n// nextTick callback\n</code></pre>\n<p>This is important in developing APIs where you want to give the user the\nchance to assign event handlers after an object has been constructed,\nbut before any I/O has occurred.</p>\n<pre><code class=\"lang-js\">function MyThing(options) {\n  this.setupOptions(options);\n\n  process.nextTick(() =&gt; {\n    this.startDoingStuff();\n  });\n}\n\nvar thing = new MyThing();\nthing.getReadyForStuff();\n\n// thing.startDoingStuff() gets called now, not before.\n</code></pre>\n<p>It is very important for APIs to be either 100% synchronous or 100%\nasynchronous.  Consider this example:</p>\n<pre><code class=\"lang-js\">// WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat(&#39;file&#39;, cb);\n}\n</code></pre>\n<p>This API is hazardous.  If you do this:</p>\n<pre><code class=\"lang-js\">maybeSync(true, () =&gt; {\n  foo();\n});\nbar();\n</code></pre>\n<p>then it&#39;s not clear whether <code>foo()</code> or <code>bar()</code> will be called first.</p>\n<p>This approach is much better:</p>\n<pre><code class=\"lang-js\">function definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\n  fs.stat(&#39;file&#39;, cb);\n}\n</code></pre>\n<p>Note: the nextTick queue is completely drained on each pass of the\nevent loop <strong>before</strong> additional I/O is processed.  As a result,\nrecursively setting nextTick callbacks will block any I/O from\nhappening, just like a <code>while(true);</code> loop.</p>\n"
        },
        {
          "textRaw": "process.send(message[, sendHandle][, callback])",
          "type": "method",
          "name": "send",
          "meta": {
            "added": [
              "v0.5.9"
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Return: {Boolean} ",
                "name": "return",
                "type": "Boolean"
              },
              "params": [
                {
                  "textRaw": "`message` {Object} ",
                  "name": "message",
                  "type": "Object"
                },
                {
                  "textRaw": "`sendHandle` {Handle object} ",
                  "name": "sendHandle",
                  "type": "Handle object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "message"
                },
                {
                  "name": "sendHandle",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>When Node.js is spawned with an IPC channel attached, it can send messages to its\nparent process using <code>process.send()</code>. Each will be received as a\n[<code>&#39;message&#39;</code>][] event on the parent&#39;s <code>ChildProcess</code> object.</p>\n<p><em>Note: this function uses [<code>JSON.stringify()</code>][] internally to serialize the <code>message</code>.</em></p>\n<p>If Node.js was not spawned with an IPC channel, <code>process.send()</code> will be undefined.</p>\n"
        },
        {
          "textRaw": "process.setegid(id)",
          "type": "method",
          "name": "setegid",
          "meta": {
            "added": [
              "v2.0.0"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the effective group identity of the process. (See setegid(2).)\nThis accepts either a numerical ID or a groupname string. If a groupname\nis specified, this method blocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.getegid &amp;&amp; process.setegid) {\n  console.log(`Current gid: ${process.getegid()}`);\n  try {\n    process.setegid(501);\n    console.log(`New gid: ${process.getegid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set gid: ${err}`);\n  }\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.seteuid(id)",
          "type": "method",
          "name": "seteuid",
          "meta": {
            "added": [
              "v2.0.0"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the effective user identity of the process. (See seteuid(2).)\nThis accepts either a numerical ID or a username string.  If a username\nis specified, this method blocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.geteuid &amp;&amp; process.seteuid) {\n  console.log(`Current uid: ${process.geteuid()}`);\n  try {\n    process.seteuid(501);\n    console.log(`New uid: ${process.geteuid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set uid: ${err}`);\n  }\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.setgid(id)",
          "type": "method",
          "name": "setgid",
          "meta": {
            "added": [
              "v0.1.31"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the group identity of the process. (See setgid(2).)  This accepts either\na numerical ID or a groupname string. If a groupname is specified, this method\nblocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.getgid &amp;&amp; process.setgid) {\n  console.log(`Current gid: ${process.getgid()}`);\n  try {\n    process.setgid(501);\n    console.log(`New gid: ${process.getgid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set gid: ${err}`);\n  }\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.setgroups(groups)",
          "type": "method",
          "name": "setgroups",
          "meta": {
            "added": [
              "v0.9.4"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the supplementary group IDs. This is a privileged operation, meaning you\nneed to be root or have the <code>CAP_SETGID</code> capability.</p>\n<p>The list can contain group IDs, group names or both.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "groups"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.setuid(id)",
          "type": "method",
          "name": "setuid",
          "meta": {
            "added": [
              "v0.1.28"
            ]
          },
          "desc": "<p>Note: this function is only available on POSIX platforms (i.e. not Windows,\nAndroid)</p>\n<p>Sets the user identity of the process. (See setuid(2).)  This accepts either\na numerical ID or a username string.  If a username is specified, this method\nblocks while resolving it to a numerical ID.</p>\n<pre><code class=\"lang-js\">if (process.getuid &amp;&amp; process.setuid) {\n  console.log(`Current uid: ${process.getuid()}`);\n  try {\n    process.setuid(501);\n    console.log(`New uid: ${process.getuid()}`);\n  }\n  catch (err) {\n    console.log(`Failed to set uid: ${err}`);\n  }\n}\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.umask([mask])",
          "type": "method",
          "name": "umask",
          "meta": {
            "added": [
              "v0.1.19"
            ]
          },
          "desc": "<p>Sets or reads the process&#39;s file mode creation mask. Child processes inherit\nthe mask from the parent process. Returns the old mask if <code>mask</code> argument is\ngiven, otherwise returns the current mask.</p>\n<pre><code class=\"lang-js\">const newmask = 0o022;\nconst oldmask = process.umask(newmask);\nconsole.log(\n  `Changed umask from ${oldmask.toString(8)} to ${newmask.toString(8)}`\n);\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "mask",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.uptime()",
          "type": "method",
          "name": "uptime",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>Number of seconds Node.js has been running.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "process.arch",
          "name": "arch",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>What processor architecture you&#39;re running on: <code>&#39;arm&#39;</code>, <code>&#39;ia32&#39;</code>, or <code>&#39;x64&#39;</code>.</p>\n<pre><code class=\"lang-js\">console.log(&#39;This processor architecture is &#39; + process.arch);\n</code></pre>\n"
        },
        {
          "textRaw": "process.argv",
          "name": "argv",
          "meta": {
            "added": [
              "v0.1.27"
            ]
          },
          "desc": "<p>An array containing the command line arguments.  The first element will be\n&#39;node&#39;, the second element will be the name of the JavaScript file.  The\nnext elements will be any additional command line arguments.</p>\n<pre><code class=\"lang-js\">// print process.argv\nprocess.argv.forEach((val, index, array) =&gt; {\n  console.log(`${index}: ${val}`);\n});\n</code></pre>\n<p>This will generate:</p>\n<pre><code>$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four\n</code></pre>"
        },
        {
          "textRaw": "process.config",
          "name": "config",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>An Object containing the JavaScript representation of the configure options\nthat were used to compile the current Node.js executable. This is the same as\nthe <code>config.gypi</code> file that was produced when running the <code>./configure</code> script.</p>\n<p>An example of the possible output looks like:</p>\n<pre><code>{\n  target_defaults:\n   { cflags: [],\n     default_configuration: &#39;Release&#39;,\n     defines: [],\n     include_dirs: [],\n     libraries: [] },\n  variables:\n   {\n     host_arch: &#39;x64&#39;,\n     node_install_npm: &#39;true&#39;,\n     node_prefix: &#39;&#39;,\n     node_shared_cares: &#39;false&#39;,\n     node_shared_http_parser: &#39;false&#39;,\n     node_shared_libuv: &#39;false&#39;,\n     node_shared_zlib: &#39;false&#39;,\n     node_use_dtrace: &#39;false&#39;,\n     node_use_openssl: &#39;true&#39;,\n     node_shared_openssl: &#39;false&#39;,\n     strict_aliasing: &#39;true&#39;,\n     target_arch: &#39;x64&#39;,\n     v8_use_snapshot: &#39;true&#39;\n   }\n}\n</code></pre><p><em>Note: the <code>process.config</code> property is <strong>not</strong> read-only and there are existing\nmodules in the ecosystem that are known to extend, modify, or entirely replace\nthe value of <code>process.config</code>.</em></p>\n"
        },
        {
          "textRaw": "`connected` {Boolean} Set to false after `process.disconnect()` is called ",
          "type": "Boolean",
          "name": "connected",
          "meta": {
            "added": [
              "v0.7.2"
            ]
          },
          "desc": "<p>If <code>process.connected</code> is false, it is no longer possible to send messages.</p>\n",
          "shortDesc": "Set to false after `process.disconnect()` is called"
        },
        {
          "textRaw": "process.env",
          "name": "env",
          "meta": {
            "added": [
              "v0.1.27"
            ]
          },
          "desc": "<p>An object containing the user environment. See environ(7).</p>\n<p>An example of this object looks like:</p>\n<pre><code class=\"lang-js\">{ TERM: &#39;xterm-256color&#39;,\n  SHELL: &#39;/usr/local/bin/bash&#39;,\n  USER: &#39;maciej&#39;,\n  PATH: &#39;~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#39;,\n  PWD: &#39;/Users/maciej&#39;,\n  EDITOR: &#39;vim&#39;,\n  SHLVL: &#39;1&#39;,\n  HOME: &#39;/Users/maciej&#39;,\n  LOGNAME: &#39;maciej&#39;,\n  _: &#39;/usr/local/bin/node&#39; }\n</code></pre>\n<p>You can write to this object, but changes won&#39;t be reflected outside of your\nprocess. That means that the following won&#39;t work:</p>\n<pre><code>$ node -e &#39;process.env.foo = &quot;bar&quot;&#39; &amp;&amp; echo $foo\n</code></pre><p>But this will:</p>\n<pre><code class=\"lang-js\">process.env.foo = &#39;bar&#39;;\nconsole.log(process.env.foo);\n</code></pre>\n<p>Assigning a property on <code>process.env</code> will implicitly convert the value\nto a string.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">process.env.test = null;\nconsole.log(process.env.test);\n// =&gt; &#39;null&#39;\nprocess.env.test = undefined;\nconsole.log(process.env.test);\n// =&gt; &#39;undefined&#39;\n</code></pre>\n<p>Use <code>delete</code> to delete a property from <code>process.env</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">process.env.TEST = 1;\ndelete process.env.TEST;\nconsole.log(process.env.TEST);\n// =&gt; undefined\n</code></pre>\n"
        },
        {
          "textRaw": "process.execArgv",
          "name": "execArgv",
          "meta": {
            "added": [
              "v0.7.7"
            ]
          },
          "desc": "<p>This is the set of Node.js-specific command line options from the\nexecutable that started the process.  These options do not show up in\n<code>process.argv</code>, and do not include the Node.js executable, the name of\nthe script, or any options following the script name. These options\nare useful in order to spawn child processes with the same execution\nenvironment as the parent.</p>\n<p>Example:</p>\n<pre><code>$ node --harmony script.js --version\n</code></pre><p>results in process.execArgv:</p>\n<pre><code class=\"lang-js\">[&#39;--harmony&#39;]\n</code></pre>\n<p>and process.argv:</p>\n<pre><code class=\"lang-js\">[&#39;/usr/local/bin/node&#39;, &#39;script.js&#39;, &#39;--version&#39;]\n</code></pre>\n"
        },
        {
          "textRaw": "process.execPath",
          "name": "execPath",
          "meta": {
            "added": [
              "v0.1.100"
            ]
          },
          "desc": "<p>This is the absolute pathname of the executable that started the process.</p>\n<p>Example:</p>\n<pre><code>/usr/local/bin/node\n</code></pre>"
        },
        {
          "textRaw": "process.exitCode",
          "name": "exitCode",
          "meta": {
            "added": [
              "v0.11.8"
            ]
          },
          "desc": "<p>A number which will be the process exit code, when the process either\nexits gracefully, or is exited via [<code>process.exit()</code>][] without specifying\na code.</p>\n<p>Specifying a code to <code>process.exit(code)</code> will override any previous\nsetting of <code>process.exitCode</code>.</p>\n"
        },
        {
          "textRaw": "process.mainModule",
          "name": "mainModule",
          "meta": {
            "added": [
              "v0.1.17"
            ]
          },
          "desc": "<p>Alternate way to retrieve [<code>require.main</code>][]. The difference is that if the main\nmodule changes at runtime, <code>require.main</code> might still refer to the original main\nmodule in modules that were required before the change occurred. Generally it&#39;s\nsafe to assume that the two refer to the same module.</p>\n<p>As with <code>require.main</code>, it will be <code>undefined</code> if there was no entry script.</p>\n"
        },
        {
          "textRaw": "process.pid",
          "name": "pid",
          "meta": {
            "added": [
              "v0.1.15"
            ]
          },
          "desc": "<p>The PID of the process.</p>\n<pre><code class=\"lang-js\">console.log(`This process is pid ${process.pid}`);\n</code></pre>\n"
        },
        {
          "textRaw": "process.platform",
          "name": "platform",
          "meta": {
            "added": [
              "v0.1.16"
            ]
          },
          "desc": "<p>What platform you&#39;re running on:\n<code>&#39;darwin&#39;</code>, <code>&#39;freebsd&#39;</code>, <code>&#39;linux&#39;</code>, <code>&#39;sunos&#39;</code> or <code>&#39;win32&#39;</code></p>\n<pre><code class=\"lang-js\">console.log(`This platform is ${process.platform}`);\n</code></pre>\n"
        },
        {
          "textRaw": "process.release",
          "name": "release",
          "meta": {
            "added": [
              "v3.0.0"
            ]
          },
          "desc": "<p>An Object containing metadata related to the current release, including URLs\nfor the source tarball and headers-only tarball.</p>\n<p><code>process.release</code> contains the following properties:</p>\n<ul>\n<li><code>name</code>: a string with a value that will always be <code>&#39;node&#39;</code> for Node.js. For\nlegacy io.js releases, this will be <code>&#39;io.js&#39;</code>.</li>\n<li><code>sourceUrl</code>: a complete URL pointing to a <em>.tar.gz</em> file containing the\nsource of the current release.</li>\n<li><code>headersUrl</code>: a complete URL pointing to a <em>.tar.gz</em> file containing only\nthe header files for the current release. This file is significantly smaller\nthan the full source file and can be used for compiling add-ons against\nNode.js.</li>\n<li><code>libUrl</code>: a complete URL pointing to an <em>node.lib</em> file matching the\narchitecture and version of the current release. This file is used for\ncompiling add-ons against Node.js. <em>This property is only present on Windows\nbuilds of Node.js and will be missing on all other platforms.</em></li>\n</ul>\n<p>e.g.</p>\n<pre><code class=\"lang-js\">{ name: &#39;node&#39;,\n  sourceUrl: &#39;https://nodejs.org/download/release/v4.0.0/node-v4.0.0.tar.gz&#39;,\n  headersUrl: &#39;https://nodejs.org/download/release/v4.0.0/node-v4.0.0-headers.tar.gz&#39;,\n  libUrl: &#39;https://nodejs.org/download/release/v4.0.0/win-x64/node.lib&#39; }\n</code></pre>\n<p>In custom builds from non-release versions of the source tree, only the\n<code>name</code> property may be present. The additional properties should not be\nrelied upon to exist.</p>\n"
        },
        {
          "textRaw": "process.stderr",
          "name": "stderr",
          "desc": "<p>A writable stream to stderr (on fd <code>2</code>).</p>\n<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node.js in\nthat they cannot be closed (<code>end()</code> will throw), they never emit the <code>finish</code>\nevent and that writes can block when output is redirected to a file (although\ndisks are fast and operating systems normally employ write-back caching so it\nshould be a very rare occurrence indeed.)</p>\n<p>Additionally, <code>process.stderr</code> and <code>process.stdout</code> are blocking when outputting\nto TTYs (terminals) on OS X as a workaround for the OS&#39;s very small, 1kb\nbuffer size. This is to prevent interleaving between <code>stdout</code> and <code>stderr</code>.</p>\n"
        },
        {
          "textRaw": "process.stdin",
          "name": "stdin",
          "desc": "<p>A <code>Readable Stream</code> for stdin (on fd <code>0</code>).</p>\n<p>Example of opening standard input and listening for both events:</p>\n<pre><code class=\"lang-js\">process.stdin.setEncoding(&#39;utf8&#39;);\n\nprocess.stdin.on(&#39;readable&#39;, () =&gt; {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    process.stdout.write(`data: ${chunk}`);\n  }\n});\n\nprocess.stdin.on(&#39;end&#39;, () =&gt; {\n  process.stdout.write(&#39;end&#39;);\n});\n</code></pre>\n<p>As a Stream, <code>process.stdin</code> can also be used in &quot;old&quot; mode that is compatible\nwith scripts written for node.js prior to v0.10.\nFor more information see [Stream compatibility][].</p>\n<p>In &quot;old&quot; Streams mode the stdin stream is paused by default, so one\nmust call <code>process.stdin.resume()</code> to read from it. Note also that calling\n<code>process.stdin.resume()</code> itself would switch stream to &quot;old&quot; mode.</p>\n<p>If you are starting a new project you should prefer a more recent &quot;new&quot; Streams\nmode over &quot;old&quot; one.</p>\n"
        },
        {
          "textRaw": "process.stdout",
          "name": "stdout",
          "desc": "<p>A <code>Writable Stream</code> to <code>stdout</code> (on fd <code>1</code>).</p>\n<p>For example, a <code>console.log</code> equivalent could look like this:</p>\n<pre><code class=\"lang-js\">console.log = (msg) =&gt; {\n  process.stdout.write(`${msg}\\n`);\n};\n</code></pre>\n<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node.js in\nthat they cannot be closed (<code>end()</code> will throw), they never emit the <code>&#39;finish&#39;</code>\nevent and that writes can block when output is redirected to a file (although\ndisks are fast and operating systems normally employ write-back caching so it\nshould be a very rare occurrence indeed.)</p>\n<p>Additionally, <code>process.stderr</code> and <code>process.stdout</code> are blocking when outputting\nto TTYs (terminals) on OS X as a workaround for the OS&#39;s very small, 1kb\nbuffer size. This is to prevent interleaving between <code>stdout</code> and <code>stderr</code>.</p>\n<p>To check if Node.js is being run in a TTY context, read the <code>isTTY</code> property\non <code>process.stderr</code>, <code>process.stdout</code>, or <code>process.stdin</code>:</p>\n<pre><code>$ node -p &quot;Boolean(process.stdin.isTTY)&quot;\ntrue\n$ echo &quot;foo&quot; | node -p &quot;Boolean(process.stdin.isTTY)&quot;\nfalse\n\n$ node -p &quot;Boolean(process.stdout.isTTY)&quot;\ntrue\n$ node -p &quot;Boolean(process.stdout.isTTY)&quot; | cat\nfalse\n</code></pre><p>See [the tty docs][] for more information.</p>\n"
        },
        {
          "textRaw": "process.title",
          "name": "title",
          "meta": {
            "added": [
              "v0.1.104"
            ]
          },
          "desc": "<p>Getter/setter to set what is displayed in <code>ps</code>.</p>\n<p>When used as a setter, the maximum length is platform-specific and probably\nshort.</p>\n<p>On Linux and OS X, it&#39;s limited to the size of the binary name plus the\nlength of the command line arguments because it overwrites the argv memory.</p>\n<p>v0.8 allowed for longer process title strings by also overwriting the environ\nmemory but that was potentially insecure/confusing in some (rather obscure)\ncases.</p>\n"
        },
        {
          "textRaw": "process.version",
          "name": "version",
          "meta": {
            "added": [
              "v0.1.3"
            ]
          },
          "desc": "<p>A compiled-in property that exposes <code>NODE_VERSION</code>.</p>\n<pre><code class=\"lang-js\">console.log(`Version: ${process.version}`);\n</code></pre>\n"
        },
        {
          "textRaw": "process.versions",
          "name": "versions",
          "meta": {
            "added": [
              "v0.2.0"
            ]
          },
          "desc": "<p>A property exposing version strings of Node.js and its dependencies.</p>\n<pre><code class=\"lang-js\">console.log(process.versions);\n</code></pre>\n<p>Will print something like:</p>\n<pre><code class=\"lang-js\">{ http_parser: &#39;2.3.0&#39;,\n  node: &#39;1.1.1&#39;,\n  v8: &#39;4.1.0.14&#39;,\n  uv: &#39;1.3.0&#39;,\n  zlib: &#39;1.2.8&#39;,\n  ares: &#39;1.10.0-DEV&#39;,\n  modules: &#39;43&#39;,\n  icu: &#39;55.1&#39;,\n  openssl: &#39;1.0.1k&#39; }\n</code></pre>\n<!-- [end-include:process.md] -->\n<!-- [start-include:punycode.md] -->\n"
        }
      ]
    }
  ],
  "vars": [
    {
      "textRaw": "\\_\\_dirname",
      "name": "\\_\\_dirname",
      "type": "var",
      "desc": "<ul>\n<li>{String}</li>\n</ul>\n<p>The name of the directory that the currently executing script resides in.</p>\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>\n<pre><code class=\"lang-js\">console.log(__dirname);\n// /Users/mjr\n</code></pre>\n<p><code>__dirname</code> isn&#39;t actually a global but rather local to each module.</p>\n<p>For instance, given two modules: <code>a</code> and <code>b</code>, where <code>b</code> is a dependency of\n<code>a</code> and there is a directory structure of:</p>\n<ul>\n<li><code>/Users/mjr/app/a.js</code></li>\n<li><code>/Users/mjr/app/node_modules/b/b.js</code></li>\n</ul>\n<p>References to <code>__dirname</code> within <code>b.js</code> will return\n<code>/Users/mjr/app/node_modules/b</code> while references to <code>__dirname</code> within <code>a.js</code>\nwill return <code>/Users/mjr/app</code>.</p>\n"
    },
    {
      "textRaw": "\\_\\_filename",
      "name": "\\_\\_filename",
      "type": "var",
      "desc": "<ul>\n<li>{String}</li>\n</ul>\n<p>The filename of the code being executed.  This is the resolved absolute path\nof this code file.  For a main program this is not necessarily the same\nfilename used in the command line.  The value inside a module is the path\nto that module file.</p>\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>\n<pre><code class=\"lang-js\">console.log(__filename);\n// /Users/mjr/example.js\n</code></pre>\n<p><code>__filename</code> isn&#39;t actually a global but rather local to each module.</p>\n"
    },
    {
      "textRaw": "exports",
      "name": "exports",
      "type": "var",
      "desc": "<p>A reference to the <code>module.exports</code> that is shorter to type.\nSee [module system documentation][] for details on when to use <code>exports</code> and\nwhen to use <code>module.exports</code>.</p>\n<p><code>exports</code> isn&#39;t actually a global but rather local to each module.</p>\n<p>See the [module system documentation][] for more information.</p>\n"
    },
    {
      "textRaw": "module",
      "name": "module",
      "type": "var",
      "desc": "<ul>\n<li>{Object}</li>\n</ul>\n<p>A reference to the current module. In particular\n<code>module.exports</code> is used for defining what a module exports and makes\navailable through <code>require()</code>.</p>\n<p><code>module</code> isn&#39;t actually a global but rather local to each module.</p>\n<p>See the [module system documentation][] for more information.</p>\n"
    },
    {
      "textRaw": "require()",
      "type": "var",
      "name": "require",
      "desc": "<ul>\n<li>{Function}</li>\n</ul>\n<p>To require modules. See the [Modules][] section.  <code>require</code> isn&#39;t actually a\nglobal but rather local to each module.</p>\n",
      "properties": [
        {
          "textRaw": "`cache` {Object} ",
          "type": "Object",
          "name": "cache",
          "desc": "<p>Modules are cached in this object when they are required. By deleting a key\nvalue from this object, the next <code>require</code> will reload the module. Note that\nthis does not apply to [native addons][], for which reloading will result in an\nError.</p>\n"
        },
        {
          "textRaw": "`extensions` {Object} ",
          "type": "Object",
          "name": "extensions",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<p>Instruct <code>require</code> on how to handle certain file extensions.</p>\n<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:</p>\n<pre><code class=\"lang-js\">require.extensions[&#39;.sjs&#39;] = require.extensions[&#39;.js&#39;];\n</code></pre>\n<p><strong>Deprecated</strong>  In the past, this list has been used to load\nnon-JavaScript modules into Node.js by compiling them on-demand.\nHowever, in practice, there are much better ways to do this, such as\nloading modules via some other Node.js program, or compiling them to\nJavaScript ahead of time.</p>\n<p>Since the Module system is locked, this feature will probably never go\naway.  However, it may have subtle bugs and complexities that are best\nleft untouched.</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "require.resolve()",
          "type": "method",
          "name": "resolve",
          "desc": "<p>Use the internal <code>require()</code> machinery to look up the location of a module,\nbut rather than loading the module, just return the resolved filename.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ]
    }
  ]
}
